{"name":"Mathlib.Tactic.Lift","instances":[{"typeNames":["Int","Nat","Nat","Nat.cast","Int","instNatCastInt","Int","LE.le","Int.instLEInt","OfNat.ofNat","instOfNatInt"],"name":"instCanLiftIntNatCastInstNatCastIntLeInstLEIntOfNatInstOfNatInt","className":"CanLift"},{"typeNames":[],"name":"Pi.canLift","className":"CanLift"},{"typeNames":["Subtype","Subtype.val","Subtype","Subtype.val","Subtype","Subtype.val","True"],"name":"PiSubtype.canLift","className":"CanLift"},{"typeNames":["Subtype","Subtype","Subtype.val","Subtype","True"],"name":"PiSubtype.canLift'","className":"CanLift"},{"typeNames":["Subtype","Subtype.val"],"name":"Subtype.canLift","className":"CanLift"}],"imports":["Init","Mathlib.Tactic.Cases","Mathlib.Tactic.PermuteGoals","Mathlib.Init.Data.Int.Order"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L118-L168","name":"Mathlib.Tactic.Lift.main","kind":"def","docLink":"./Mathlib/Tactic/Lift.html#Mathlib.Tactic.Lift.main","doc":"Main function for the `lift` tactic. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L110-L115","name":"Mathlib.Tactic.Lift.getInst","kind":"def","docLink":"./Mathlib/Tactic/Lift.html#Mathlib.Tactic.Lift.getInst","doc":"Generate instance for the `lift` tactic. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L68-L107","name":"Mathlib.Tactic.lift","kind":"def","docLink":"./Mathlib/Tactic/Lift.html#Mathlib.Tactic.lift","doc":"Lift an expression to another type.\n* Usage: `'lift' expr 'to' expr ('using' expr)? ('with' id (id id?)?)?`.\n* If `n : ℤ` and `hn : n ≥ 0` then the tactic `lift n to ℕ using hn` creates a new\n  constant of type `ℕ`, also named `n` and replaces all occurrences of the old variable `(n : ℤ)`\n  with `↑n` (where `n` in the new variable). It will remove `n` and `hn` from the context.\n  + So for example the tactic `lift n to ℕ using hn` transforms the goal\n    `n : ℤ, hn : n ≥ 0, h : P n ⊢ n = 3` to `n : ℕ, h : P ↑n ⊢ ↑n = 3`\n    (here `P` is some term of type `ℤ → Prop`).\n* The argument `using hn` is optional, the tactic `lift n to ℕ` does the same, but also creates a\n  new subgoal that `n ≥ 0` (where `n` is the old variable).\n  This subgoal will be placed at the top of the goal list.\n  + So for example the tactic `lift n to ℕ` transforms the goal\n    `n : ℤ, h : P n ⊢ n = 3` to two goals\n    `n : ℤ, h : P n ⊢ n ≥ 0` and `n : ℕ, h : P ↑n ⊢ ↑n = 3`.\n* You can also use `lift n to ℕ using e` where `e` is any expression of type `n ≥ 0`.\n* Use `lift n to ℕ with k` to specify the name of the new variable.\n* Use `lift n to ℕ with k hk` to also specify the name of the equality `↑k = n`. In this case, `n`\n  will remain in the context. You can use `rfl` for the name of `hk` to substitute `n` away\n  (i.e. the default behavior).\n* You can also use `lift e to ℕ with k hk` where `e` is any expression of type `ℤ`.\n  In this case, the `hk` will always stay in the context, but it will be used to rewrite `e` in\n  all hypotheses and the target.\n  + So for example the tactic `lift n + 3 to ℕ using hn with k hk` transforms the goal\n    `n : ℤ, hn : n + 3 ≥ 0, h : P (n + 3) ⊢ n + 3 = 2 * n` to the goal\n    `n : ℤ, k : ℕ, hk : ↑k = n + 3, h : P ↑k ⊢ ↑k = 2 * n`.\n* The tactic `lift n to ℕ using h` will remove `h` from the context. If you want to keep it,\n  specify it again as the third argument to `with`, like this: `lift n to ℕ using h with n rfl h`.\n* More generally, this can lift an expression from `α` to `β` assuming that there is an instance\n  of `CanLift α β`. In this case the proof obligation is specified by `CanLift.prf`.\n* Given an instance `CanLift β γ`, it can also lift `α → β` to `α → γ`; more generally, given\n  `β : Π a : α, Type _`, `γ : Π a : α, Type _`, and `[Π a : α, CanLift (β a) (γ a)]`, it\n  automatically generates an instance `CanLift (Π a, β a) (Π a, γ a)`.\n\n`lift` is in some sense dual to the `zify` tactic. `lift (z : ℤ) to ℕ` will change the type of an\ninteger `z` (in the supertype) to `ℕ` (the subtype), given a proof that `z ≥ 0`;\npropositions concerning `z` will still be over `ℤ`. `zify` changes propositions about `ℕ` (the\nsubtype) to propositions about `ℤ` (the supertype), without changing the type of any variable.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L59-L61","name":"Subtype.canLift","kind":"instance","docLink":"./Mathlib/Tactic/Lift.html#Subtype.canLift","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L54-L56","name":"PiSubtype.canLift'","kind":"instance","docLink":"./Mathlib/Tactic/Lift.html#PiSubtype.canLift'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L48-L50","name":"PiSubtype.canLift","kind":"instance","docLink":"./Mathlib/Tactic/Lift.html#PiSubtype.canLift","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L40-L45","name":"Subtype.exists_pi_extension","kind":"theorem","docLink":"./Mathlib/Tactic/Lift.html#Subtype.exists_pi_extension","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L33-L37","name":"Pi.canLift","kind":"instance","docLink":"./Mathlib/Tactic/Lift.html#Pi.canLift","doc":"Enable automatic handling of pi types in `CanLift`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L29-L30","name":"instCanLiftIntNatCastInstNatCastIntLeInstLEIntOfNatInstOfNatInt","kind":"instance","docLink":"./Mathlib/Tactic/Lift.html#instCanLiftIntNatCastInstNatCastIntLeInstLEIntOfNatInstOfNatInt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L26-L26","name":"CanLift.prf","kind":"def","docLink":"./Mathlib/Tactic/Lift.html#CanLift.prf","doc":"An element of `α` that satisfies `cond` belongs to the range of `coe`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L24-L24","name":"CanLift.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Lift.html#CanLift.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Lift.lean#L24-L26","name":"CanLift","kind":"class","docLink":"./Mathlib/Tactic/Lift.html#CanLift","doc":"A class specifying that you can lift elements from `α` to `β` assuming `cond` is true.\nUsed by the tactic `lift`. "}]}