{"name":"Std.Tactic.Congr","instances":[],"imports":["Init","Lean.Meta.Tactic.Congr","Std.Tactic.RCases","Std.Tactic.Ext"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/Congr.lean#L52-L81","name":"Std.Tactic.rcongr","kind":"def","docLink":"./Std/Tactic/Congr.html#Std.Tactic.rcongr","doc":"Repeatedly apply `congr` and `ext`, using the given patterns as arguments for `ext`.\n\nThere are two ways this tactic stops:\n* `congr` fails (makes no progress), after having already applied `ext`.\n* `congr` canceled out the last usage of `ext`. In this case, the state is reverted to before\n  the `congr` was applied.\n\nFor example, when the goal is\n```\n⊢ (λ x, f x + 3) '' s = (λ x, g x + 3) '' s\n```\nthen `rcongr x` produces the goal\n```\nx : α ⊢ f x = g x\n```\nThis gives the same result as `congr; ext x; congr`.\n\nIn contrast, `congr` would produce\n```\n⊢ (λ x, f x + 3) = (λ x, g x + 3)\n```\nand `congr with x` (or `congr; ext x`) would produce\n```\nx : α ⊢ f x + 3 = g x + 3\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/Congr.lean#L38-L50","name":"Std.Tactic.rcongrCore","kind":"opaque","docLink":"./Std/Tactic/Congr.html#Std.Tactic.rcongrCore","doc":"Recursive core of `rcongr`. Calls `ext pats <;> congr` and then itself recursively,\nunless `ext pats <;> congr` made no progress.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/Congr.lean#L15-L28","name":"Std.Tactic.congrWith","kind":"def","docLink":"./Std/Tactic/Congr.html#Std.Tactic.congrWith","doc":"Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\n* `congr n` controls the depth of the recursive applications.\n  This is useful when `congr` is too aggressive in breaking down the goal.\n  For example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n  `congr` produces the goals `⊢ x = y` and `⊢ y = x`,\n  while `congr 2` produces the intended `⊢ x + y = y + x`.\n* If, at any point, a subgoal matches a hypothesis then the subgoal will be closed.\n* You can use `congr with p (: n)?` to call `ext p (: n)?` to all subgoals generated by `congr`.\n  For example, if the goal is `⊢ f '' s = g '' s` then `congr with x` generates the goal\n  `x : α ⊢ f x = g x`.\n"}]}