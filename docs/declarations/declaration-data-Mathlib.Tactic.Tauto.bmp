{"name":"Mathlib.Tactic.Tauto","instances":[],"imports":["Init","Lean","Mathlib.Init.Logic","Mathlib.Init.Propext","Mathlib.Logic.Basic","Mathlib.Tactic.CasesM","Mathlib.Tactic.Classical","Mathlib.Tactic.Core","Mathlib.Tactic.SolveByElim","Qq"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L202-L212","name":"Mathlib.Tactic.Tauto.tauto","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.tauto","doc":"`tauto` breaks down assumptions of the form `_ ∧ _`, `_ ∨ _`, `_ ↔ _` and `∃ _, _`\nand splits a goal of the form `_ ∧ _`, `_ ↔ _` or `∃ _, _` until it can be discharged\nusing `reflexivity` or `solve_by_elim`.\nThis is a finishing tactic: it either closes the goal or raises an error.\n\nThe Lean 3 version of this tactic by default attempted to avoid classical reasoning\nwhere possible. This Lean 4 version makes no such attempt. The `itauto` tactic\nis designed for that purpose.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L193-L200","name":"Mathlib.Tactic.Tauto.tautology","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.tautology","doc":"Implementation of the `tauto` tactic. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L184-L190","name":"Mathlib.Tactic.Tauto.finishingConstructorMatcher","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.finishingConstructorMatcher","doc":"Matches propositions where we want to apply the `constructor` tactic in the\nfinishing stage of `tauto`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L163-L180","name":"Mathlib.Tactic.Tauto.tautoCore","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.tautoCore","doc":"The core loop of the `tauto` tactic. Repeatedly tries to break down propositions\nuntil no more progress can be made. Tries `assumption` and `contradiction` at every\nstep, to discharge goals as soon as possible. Does not do anything that requires\nbacktracking.\n\nTODO: The Lean 3 version uses more-powerful versions of `contradiction` and `assumption`\nthat additionally apply `symm` and use a fancy union-find data structure to avoid\nduplicated work.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L143-L149","name":"Mathlib.Tactic.Tauto.casesMatcher","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.casesMatcher","doc":"Matches propositions where we want to apply the `cases` tactic\nin the core loop of `tauto`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L134-L139","name":"Mathlib.Tactic.Tauto.coreConstructorMatcher","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.coreConstructorMatcher","doc":"Matches propositions where we want to apply the `constructor` tactic\nin the core loop of `tauto`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L129-L130","name":"Mathlib.Tactic.Tauto.elabConfig","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.elabConfig","doc":"Function elaborating `Config`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L127-L127","name":"Mathlib.Tactic.Tauto.Config","kind":"structure","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.Config","doc":"Config for the `tauto` tactic. Currently empty. TODO: add `closer` option. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L119-L124","name":"Mathlib.Tactic.Tauto.distribNot","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.distribNot","doc":"Tries to apply de-Morgan-like rules on all hypotheses.\nAlways succeeds, regardless of whether any progress was actually made.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L108-L113","name":"Mathlib.Tactic.Tauto.distribNotAux","kind":"opaque","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.distribNotAux","doc":"For each fvar in `fvars`, calls `distribNotAt` and carries along the resulting\nrenamings.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L94-L102","name":"Mathlib.Tactic.Tauto.distribNotAt","kind":"opaque","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.distribNotAt","doc":"Calls `distribNotAt` on the head of `state.fvars` up to `nIters` times, returning\nearly on failure.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L88-L88","name":"Mathlib.Tactic.Tauto.DistribNotState.currentGoal","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.DistribNotState.currentGoal","doc":"The current goal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L85-L85","name":"Mathlib.Tactic.Tauto.DistribNotState.fvars","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.DistribNotState.fvars","doc":"The list of hypothesis left to work on, renamed to be up-to-date with\nthe current goal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L82-L88","name":"Mathlib.Tactic.Tauto.DistribNotState","kind":"structure","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.DistribNotState","doc":"State of the `distribNotAt` function. We need to carry around the list of\nremaining hypothesis as fvars so that we can incrementally apply the\n`AssertAfterResult.subst` from each step to each of them. Otherwise,\nthey could end up referring to old hypotheses.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L29-L74","name":"Mathlib.Tactic.Tauto.distribNotOnceAt","kind":"def","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.distribNotOnceAt","doc":"Tries to apply de-Morgan-like rules on a hypothesis. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L1-L1","name":"Mathlib.Tactic.Tauto.Config.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.Config.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Tauto.lean#L1-L1","name":"Mathlib.Tactic.Tauto.DistribNotState.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.DistribNotState.mk","doc":""}]}