{"name":"Mathlib.Logic.Hydra","instances":[],"imports":["Init","Mathlib.Data.Finsupp.Lex","Mathlib.Data.Finsupp.Multiset","Mathlib.Order.GameAdd"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L156-L157","name":"WellFounded.cutExpand","kind":"theorem","docLink":"./Mathlib/Logic/Hydra.html#WellFounded.cutExpand","doc":"`CutExpand r` is well-founded when `r` is. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L144-L152","name":"Acc.cutExpand","kind":"theorem","docLink":"./Mathlib/Logic/Hydra.html#Acc.cutExpand","doc":"A singleton `{a}` is accessible under `CutExpand r` if `a` is accessible under `r`,\nassuming `r` is irreflexive. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L132-L139","name":"Relation.acc_of_singleton","kind":"theorem","docLink":"./Mathlib/Logic/Hydra.html#Relation.acc_of_singleton","doc":"A multiset is accessible under `CutExpand` if all its singleton subsets are,\nassuming `r` is irreflexive. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L112-L127","name":"Relation.cutExpand_fibration","kind":"theorem","docLink":"./Mathlib/Logic/Hydra.html#Relation.cutExpand_fibration","doc":"For any relation `r` on `α`, multiset addition `Multiset α × Multiset α → Multiset α` is a\nfibration between the game sum of `CutExpand r` with itself and `CutExpand r` itself. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L104-L107","name":"Relation.not_cutExpand_zero","kind":"theorem","docLink":"./Mathlib/Logic/Hydra.html#Relation.not_cutExpand_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L92-L101","name":"Relation.cutExpand_iff","kind":"theorem","docLink":"./Mathlib/Logic/Hydra.html#Relation.cutExpand_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L88-L89","name":"Relation.cutExpand_add_left","kind":"theorem","docLink":"./Mathlib/Logic/Hydra.html#Relation.cutExpand_add_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L84-L85","name":"Relation.cutExpand_singleton_singleton","kind":"theorem","docLink":"./Mathlib/Logic/Hydra.html#Relation.cutExpand_singleton_singleton","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L80-L81","name":"Relation.cutExpand_singleton","kind":"theorem","docLink":"./Mathlib/Logic/Hydra.html#Relation.cutExpand_singleton","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L65-L77","name":"Relation.cutExpand_le_invImage_lex","kind":"theorem","docLink":"./Mathlib/Logic/Hydra.html#Relation.cutExpand_le_invImage_lex","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Hydra.lean#L59-L60","name":"Relation.CutExpand","kind":"def","docLink":"./Mathlib/Logic/Hydra.html#Relation.CutExpand","doc":"The relation that specifies valid moves in our hydra game. `CutExpand r s' s`\nmeans that `s'` is obtained by removing one head `a ∈ s` and adding back an arbitrary\nmultiset `t` of heads such that all `a' ∈ t` satisfy `r a' a`.\n\nThis is most directly translated into `s' = s.erase a + t`, but `Multiset.erase` requires\n`DecidableEq α`, so we use the equivalent condition `s' + {a} = s + t` instead, which\nis also easier to verify for explicit multisets `s'`, `s` and `t`.\n\nWe also don't include the condition `a ∈ s` because `s' + {a} = s + t` already\nguarantees `a ∈ s + t`, and if `r` is irreflexive then `a ∉ t`, which is the\ncase when `r` is well-founded, the case we are primarily interested in.\n\nThe lemma `Relation.cutExpand_iff` below converts between this convenient definition\nand the direct translation when `r` is irreflexive. "}]}