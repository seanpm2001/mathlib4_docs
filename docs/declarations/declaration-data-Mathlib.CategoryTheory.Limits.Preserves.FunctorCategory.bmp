{"name":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","instances":[{"typeNames":["CategoryTheory.Functor","CategoryTheory.Functor.category","CategoryTheory.Functor","CategoryTheory.Functor.category","Prefunctor.obj","CategoryTheory.Functor","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","CategoryTheory.Functor.category","CategoryTheory.Functor","CategoryTheory.Functor","CategoryTheory.Functor.category","CategoryTheory.Functor","CategoryTheory.Functor.category","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","CategoryTheory.Functor.category","CategoryTheory.Functor.toPrefunctor","CategoryTheory.whiskeringLeft"],"name":"CategoryTheory.whiskeringLeftPreservesLimits","className":"CategoryTheory.Limits.PreservesLimitsOfSize"},{"typeNames":["CategoryTheory.Functor","CategoryTheory.Functor.category","CategoryTheory.Functor","CategoryTheory.Functor.category","Prefunctor.obj","CategoryTheory.Functor","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","CategoryTheory.Functor.category","CategoryTheory.Functor","CategoryTheory.Functor","CategoryTheory.Functor.category","CategoryTheory.Functor","CategoryTheory.Functor.category","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","CategoryTheory.Functor.category","CategoryTheory.Functor.toPrefunctor","CategoryTheory.whiskeringRight"],"name":"CategoryTheory.whiskeringRightPreservesLimitsOfShape","className":"CategoryTheory.Limits.PreservesLimitsOfShape"},{"typeNames":["CategoryTheory.Functor","CategoryTheory.Functor.category","CategoryTheory.Functor","CategoryTheory.Functor.category","Prefunctor.obj","CategoryTheory.Functor","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","CategoryTheory.Functor.category","CategoryTheory.Functor","CategoryTheory.Functor","CategoryTheory.Functor.category","CategoryTheory.Functor","CategoryTheory.Functor.category","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","CategoryTheory.Functor.category","CategoryTheory.Functor.toPrefunctor","CategoryTheory.whiskeringRight"],"name":"CategoryTheory.whiskeringRightPreservesLimits","className":"CategoryTheory.Limits.PreservesLimitsOfSize"}],"imports":["Init","Mathlib.CategoryTheory.Limits.FunctorCategory","Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts","Mathlib.CategoryTheory.Limits.Yoneda","Mathlib.CategoryTheory.Limits.Presheaf"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.lean#L111-L115","name":"CategoryTheory.preservesLimitOfLanPreservesLimit","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.html#CategoryTheory.preservesLimitOfLanPreservesLimit","doc":"If `Lan F.op : (Cᵒᵖ ⥤ Type*) ⥤ (Dᵒᵖ ⥤ Type*)` preserves limits of shape `J`, so will `F`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.lean#L103-L106","name":"CategoryTheory.whiskeringRightPreservesLimits","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.html#CategoryTheory.whiskeringRightPreservesLimits","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.lean#L92-L100","name":"CategoryTheory.whiskeringRightPreservesLimitsOfShape","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.html#CategoryTheory.whiskeringRightPreservesLimitsOfShape","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.lean#L81-L89","name":"CategoryTheory.whiskeringLeftPreservesLimits","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.html#CategoryTheory.whiskeringLeftPreservesLimits","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.lean#L61-L78","name":"CategoryTheory.FunctorCategory.prodPreservesColimits","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.html#CategoryTheory.FunctorCategory.prodPreservesColimits","doc":"If `X × -` preserves colimits in `D` for any `X : D`, then the product functor `F ⨯ -` for\n`F : C ⥤ D` also preserves colimits.\n\nNote this is (mathematically) a special case of the statement that\n\"if limits commute with colimits in `D`, then they do as well in `C ⥤ D`\"\nbut the story in Lean is a bit more complex, and this statement isn't directly a special case.\nThat is, even with a formalised proof of the general statement, there would still need to be some\nwork to convert to this version: namely, the natural isomorphism\n`(evaluation C D).obj k ⋙ prod.functor.obj (F.obj k) ≅\n  prod.functor.obj F ⋙ (evaluation C D).obj k`\n"}]}