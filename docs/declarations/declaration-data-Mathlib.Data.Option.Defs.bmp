{"name":"Mathlib.Data.Option.Defs","instances":[{"typeNames":["Membership.mem","Option","Option.instMembershipOption"],"name":"Option.decidableForallMem","className":"Decidable"},{"typeNames":["Exists","And","Membership.mem","Option","Option.instMembershipOption"],"name":"Option.decidableExistsMem","className":"Decidable"},{"typeNames":["Option","Option.liftOrGet"],"name":"Option.liftOrGet_isCommutative","className":"IsCommutative"},{"typeNames":["Option","Option.liftOrGet"],"name":"Option.liftOrGet_isAssociative","className":"IsAssociative"},{"typeNames":["Option","Option.liftOrGet"],"name":"Option.liftOrGet_isIdempotent","className":"IsIdempotent"},{"typeNames":["Option","Option.liftOrGet","Option.none"],"name":"Option.liftOrGet_isLeftId","className":"IsLeftId"},{"typeNames":["Option","Option.liftOrGet","Option.none"],"name":"Option.liftOrGet_isRightId","className":"IsRightId"}],"imports":["Init","Mathlib.Init.Algebra.Classes"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L135-L136","name":"Option.liftOrGet_isRightId","kind":"instance","docLink":"./Mathlib/Data/Option/Defs.html#Option.liftOrGet_isRightId","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L132-L133","name":"Option.liftOrGet_isLeftId","kind":"instance","docLink":"./Mathlib/Data/Option/Defs.html#Option.liftOrGet_isLeftId","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L128-L130","name":"Option.liftOrGet_isIdempotent","kind":"instance","docLink":"./Mathlib/Data/Option/Defs.html#Option.liftOrGet_isIdempotent","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L124-L126","name":"Option.liftOrGet_isAssociative","kind":"instance","docLink":"./Mathlib/Data/Option/Defs.html#Option.liftOrGet_isAssociative","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L120-L122","name":"Option.liftOrGet_isCommutative","kind":"instance","docLink":"./Mathlib/Data/Option/Defs.html#Option.liftOrGet_isCommutative","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L116-L117","name":"Option.mem_toList","kind":"theorem","docLink":"./Mathlib/Data/Option/Defs.html#Option.mem_toList","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L111-L112","name":"Option.iget_some","kind":"theorem","docLink":"./Mathlib/Data/Option/Defs.html#Option.iget_some","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L106-L108","name":"Option.iget","kind":"def","docLink":"./Mathlib/Data/Option/Defs.html#Option.iget","doc":"Inhabited `get` function. Returns `a` if the input is `some a`, otherwise returns `default`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L99-L102","name":"Option.decidableExistsMem","kind":"instance","docLink":"./Mathlib/Data/Option/Defs.html#Option.decidableExistsMem","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L92-L97","name":"Option.decidableForallMem","kind":"instance","docLink":"./Mathlib/Data/Option/Defs.html#Option.decidableForallMem","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L88-L89","name":"Option.decidableEqNone","kind":"def","docLink":"./Mathlib/Data/Option/Defs.html#Option.decidableEqNone","doc":"`o = none` is decidable even if the wrapped type does not have decidable equality.\nThis is not an instance because it is not definitionally equal to `Option.decidableEq`.\nTry to use `o.isNone` or `o.isSome` instead.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L80-L80","name":"Option.mem_some_iff","kind":"theorem","docLink":"./Mathlib/Data/Option/Defs.html#Option.mem_some_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L75-L77","name":"Option.elim'_eq_elim","kind":"theorem","docLink":"./Mathlib/Data/Option/Defs.html#Option.elim'_eq_elim","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L71-L71","name":"Option.elim'_some","kind":"theorem","docLink":"./Mathlib/Data/Option/Defs.html#Option.elim'_some","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L69-L69","name":"Option.elim'_none","kind":"theorem","docLink":"./Mathlib/Data/Option/Defs.html#Option.elim'_none","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L63-L65","name":"Option.elim'","kind":"def","docLink":"./Mathlib/Data/Option/Defs.html#Option.elim'","doc":"An elimination principle for `Option`. It is a nondependent version of `Option.rec`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L53-L54","name":"Option.getDM'","kind":"def","docLink":"./Mathlib/Data/Option/Defs.html#Option.getDM'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L44-L46","name":"Option.maybe","kind":"def","docLink":"./Mathlib/Data/Option/Defs.html#Option.maybe","doc":"If you maybe have a monadic computation in a `[Monad m]` which produces a term of type `α`,\nthen there is a naturally associated way to always perform a computation in `m` which maybe\nproduces a result. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L35-L38","name":"Option.traverse","kind":"def","docLink":"./Mathlib/Data/Option/Defs.html#Option.traverse","doc":"Traverse an object of `Option α` with a function `f : α → F β` for an applicative `F`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L30-L31","name":"Option.rel.none","kind":"ctor","docLink":"./Mathlib/Data/Option/Defs.html#Option.rel.none","doc":"`none ~ none` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L28-L29","name":"Option.rel.some","kind":"ctor","docLink":"./Mathlib/Data/Option/Defs.html#Option.rel.some","doc":"If `a ~ b`, then `some a ~ some b` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Option/Defs.lean#L27-L31","name":"Option.rel","kind":"inductive","docLink":"./Mathlib/Data/Option/Defs.html#Option.rel","doc":"Lifts a relation `α → β → Prop` to a relation `Option α → Option β → Prop` by just adding\n`none ~ none`. "}]}