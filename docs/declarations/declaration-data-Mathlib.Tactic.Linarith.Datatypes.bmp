{"name":"Mathlib.Tactic.Linarith.Datatypes","instances":[{"typeNames":["Eq","Linarith.Ineq"],"name":"Linarith.instDecidableEqIneq","className":"Decidable"},{"typeNames":["Linarith.Ineq"],"name":"Linarith.instInhabitedIneq","className":"Inhabited"},{"typeNames":["Linarith.Ineq"],"name":"Linarith.instReprIneq","className":"Repr"},{"typeNames":["Linarith.Ineq"],"name":"Linarith.Ineq.instToStringIneq","className":"ToString"},{"typeNames":["Linarith.Ineq"],"name":"Linarith.Ineq.instToFormatIneq","className":"Std.ToFormat"},{"typeNames":["Linarith.Comp"],"name":"Linarith.instInhabitedComp","className":"Inhabited"},{"typeNames":["Linarith.Comp"],"name":"Linarith.instReprComp","className":"Repr"},{"typeNames":["Linarith.Comp"],"name":"Linarith.Comp.ToFormat","className":"Std.ToFormat"},{"typeNames":["Linarith.Preprocessor","Linarith.GlobalBranchingPreprocessor"],"name":"Linarith.PreprocessorToGlobalBranchingPreprocessor","className":"Coe"},{"typeNames":["Linarith.GlobalPreprocessor","Linarith.GlobalBranchingPreprocessor"],"name":"Linarith.GlobalPreprocessorToGlobalBranchingPreprocessor","className":"Coe"}],"imports":["Init","Mathlib.Tactic.Linarith.Lemmas","Mathlib.Tactic.Ring","Mathlib.Util.SynthesizeUsing"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L395-L407","name":"Linarith.mkSingleCompZeroOf","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.mkSingleCompZeroOf","doc":"`mkSingleCompZeroOf c h` assumes that `h` is a proof of `t R 0`.\nIt produces a pair `(R', h')`, where `h'` is a proof of `c*t R' 0`.\nTypically `R` and `R'` will be the same, except when `c = 0`, in which case `R'` is `=`.\nIf `c = 1`, `h'` is the same as `h` -- specifically, it does *not* change the type to `1*t R 0`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L387-L387","name":"Linarith.parseCompAndExpr.throwNotZero","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.parseCompAndExpr.throwNotZero","doc":"helper function for error message "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L379-L387","name":"Linarith.parseCompAndExpr","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.parseCompAndExpr","doc":"`parseCompAndExpr e` checks if `e` is of the form `t < 0`, `t ≤ 0`, or `t = 0`.\nIf it is, it returns the comparison along with `t`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L365-L373","name":"Linarith.getRelSides","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.getRelSides","doc":"`getRelSides e` returns the left and right hand sides of `e` if `e` is a comparison,\nand fails otherwise.\nThis function is more naturally in the `Option` monad, but it is convenient to put in `MetaM`\nfor compositionality.\n "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L347-L351","name":"Linarith.LinarithConfig.updateReducibility","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.updateReducibility","doc":"`cfg.updateReducibility reduce_default` will change the transparency setting of `cfg` to\n`default` if `reduce_default` is true. In this case, it also sets the discharger to `ring!`,\nsince this is typically needed when using stronger unification.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L340-L340","name":"Linarith.LinarithConfig.oracle","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.oracle","doc":"Specify an oracle for identifying candidate contradictions.\nThe only implementation here is Fourier-Motzkin elimination. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L337-L337","name":"Linarith.LinarithConfig.preprocessors","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.preprocessors","doc":"Override the list of preprocessors. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L335-L335","name":"Linarith.LinarithConfig.splitNe","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.splitNe","doc":"Split `≠` in hypotheses, by branching in cases `<` and `>`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L333-L333","name":"Linarith.LinarithConfig.splitHypotheses","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.splitHypotheses","doc":"Split conjunctions in hypotheses. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L331-L331","name":"Linarith.LinarithConfig.transparency","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.transparency","doc":"Transparency mode for identifying atomic expressions in comparisons. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L329-L329","name":"Linarith.LinarithConfig.exfalso","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.exfalso","doc":"Prove goals which are not linear comparisons by first calling `exfalso`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L322-L322","name":"Linarith.LinarithConfig.discharger","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.discharger","doc":"Discharger to prove that a candidate linear combination of hypothesis is zero. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L319-L340","name":"Linarith.LinarithConfig","kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig","doc":"A configuration object for `linarith`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L313-L314","name":"Linarith.CertificateOracle","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.CertificateOracle","doc":"A `CertificateOracle` is a function\n`produceCertificate : List Comp → Nat → MetaM (HashMap Nat Nat)`.\n`produceCertificate hyps max_var` tries to derive a contradiction from the comparisons in `hyps`\nby eliminating all variables ≤ `max_var`.\nIf successful, it returns a map `coeff : Nat → Nat` as a certificate.\nThis map represents that we can find a contradiction by taking the sum  `∑ (coeff i) * hyps[i]`.\n\nThe default `CertificateOracle` used by `linarith` is\n`Linarith.FourierMotzkin.produceCertificate`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L298-L300","name":"Linarith.GlobalPreprocessorToGlobalBranchingPreprocessor","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessorToGlobalBranchingPreprocessor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L294-L296","name":"Linarith.PreprocessorToGlobalBranchingPreprocessor","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.PreprocessorToGlobalBranchingPreprocessor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L284-L292","name":"Linarith.GlobalBranchingPreprocessor.process","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.process","doc":"`process pp l` runs `pp.transform` on `l` and returns the result,\ntracing the result if `trace.linarith` is on.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L276-L278","name":"Linarith.GlobalPreprocessor.branching","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.branching","doc":"A `GlobalPreprocessor` lifts to a `GlobalBranchingPreprocessor` by producing only one branch.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L269-L271","name":"Linarith.Preprocessor.globalize","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.globalize","doc":"A `Preprocessor` lifts to a `GlobalPreprocessor` by folding it over the input list.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L264-L264","name":"Linarith.GlobalBranchingPreprocessor.transform","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.transform","doc":"Given a goal, and a list of hypotheses,\nproduce a list of pairs (consisting of a goal and list of hypotheses). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L261-L261","name":"Linarith.GlobalBranchingPreprocessor.name","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.name","doc":"The name of the global branching preprocessor, used in trace output. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L259-L264","name":"Linarith.GlobalBranchingPreprocessor","kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor","doc":"Some preprocessors perform branching case splits.\nA `GlobalBranchingPreprocessor` produces a list of branches to run.\nEach branch is independent, so hypotheses that appear in multiple branches should be duplicated.\nThe preprocessor is responsible for making sure that each branch contains the correct goal\nmetavariable.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L250-L250","name":"Linarith.Branch","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Branch","doc":"Some preprocessors perform branching case splits. A `Branch` is used to track one of these case\nsplits. The first component, an `MVarId`, is the goal corresponding to this branch of the split,\ngiven as a metavariable. The `List Expr` component is the list of hypotheses for `linarith`\nin this branch.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L242-L242","name":"Linarith.GlobalPreprocessor.transform","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.transform","doc":"Replace the collection of all hypotheses with new hypotheses.\nThese expressions are proof terms. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L239-L239","name":"Linarith.GlobalPreprocessor.name","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.name","doc":"The name of the global preprocessor, used in trace output. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L237-L242","name":"Linarith.GlobalPreprocessor","kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor","doc":"Some preprocessors need to examine the full list of hypotheses instead of working item by item.\nAs with `Preprocessor`, the input to a `GlobalPreprocessor` is replaced by, not added to, its\noutput.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L230-L230","name":"Linarith.Preprocessor.transform","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.transform","doc":"Replace a hypothesis by a list of hypotheses. These expressions are the proof terms. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L228-L228","name":"Linarith.Preprocessor.name","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.name","doc":"The name of the preprocessor, used in trace output. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L226-L230","name":"Linarith.Preprocessor","kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor","doc":"A preprocessor transforms a proof of a proposition into a proof of a different proposition.\nThe return type is `List Expr`, since some preprocessing steps may create multiple new hypotheses,\nand some may remove a hypothesis from the list.\nA \"no-op\" preprocessor should return its input as a singleton list.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L212-L213","name":"Linarith.Comp.ToFormat","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.ToFormat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L210-L210","name":"Linarith.Comp.isContr","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.isContr","doc":"A `Comp` represents a contradiction if its expression has no coefficients and its strength is <,\nthat is, it represents the fact `0 < 0`.\n "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L199-L204","name":"Linarith.Comp.cmp","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.cmp","doc":"`Comp` has a lex order. First the `ineq`s are compared, then the `coeff`s. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L195-L196","name":"Linarith.Comp.add","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.add","doc":"`Comp.add c1 c2` adds the expressions represented by `c1` and `c2`.\nThe coefficient of variable `a` in `c1.add c2`\nis the sum of the coefficients of `a` in `c1` and `c2`.\n "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L187-L188","name":"Linarith.Comp.scale","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.scale","doc":"`c.scale n` scales the coefficients of `c` by `n`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L183-L184","name":"Linarith.Comp.coeffOf","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.coeffOf","doc":"`c.coeffOf a` projects the coefficient of variable `a` out of `c`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L180-L180","name":"Linarith.Comp.vars","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.vars","doc":"`c.vars` returns the list of variables that appear in the linear expression contained in `c`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L177-L177","name":"Linarith.instReprComp","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instReprComp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L177-L177","name":"Linarith.instInhabitedComp","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instInhabitedComp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L176-L176","name":"Linarith.Comp.coeffs","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.coeffs","doc":"The coefficients of the comparison, stored as list of pairs `(i, a)`,\nwhere `i` is the index of a recorded atom, and `a` is the coefficient. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L173-L173","name":"Linarith.Comp.str","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.str","doc":"The strength of the comparison, `<`, `≤`, or `=`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L171-L177","name":"Linarith.Comp","kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp","doc":"The main datatype for FM elimination.\nVariables are represented by natural numbers, each of which has an integer coefficient.\nIndex 0 is reserved for constants, i.e. `coeffs.find 0` is the coefficient of 1.\nThe represented term is `coeffs.sum (λ ⟨k, v⟩, v * Var[k])`.\nstr determines the strength of the comparison -- is it < 0, ≤ 0, or = 0?\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L158-L158","name":"Linarith.Ineq.instToFormatIneq","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.instToFormatIneq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L156-L156","name":"Linarith.Ineq.instToStringIneq","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.instToStringIneq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L151-L154","name":"Linarith.Ineq.toConstMulName","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.toConstMulName","doc":"Finds the name of a multiplicative lemma corresponding to an inequality strength. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L145-L148","name":"Linarith.Ineq.toString","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.toString","doc":"Prints an `Ineq` as the corresponding infix symbol. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L136-L142","name":"Linarith.Ineq.cmp","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.cmp","doc":"`Ineq` is ordered `eq < le < lt`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L128-L133","name":"Linarith.Ineq.max","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.max","doc":"`max R1 R2` computes the strength of the sum of two inequalities. If `t1 R1 0` and `t2 R2 0`,\nthen `t1 + t2 (max R1 R2) 0`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L120-L120","name":"Linarith.instReprIneq","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instReprIneq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L120-L120","name":"Linarith.instInhabitedIneq","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instInhabitedIneq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L120-L120","name":"Linarith.instDecidableEqIneq","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instDecidableEqIneq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L119-L119","name":"Linarith.Ineq.lt","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.lt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L119-L119","name":"Linarith.Ineq.le","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.le","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L119-L119","name":"Linarith.Ineq.eq","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L118-L120","name":"Linarith.Ineq","kind":"inductive","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq","doc":"The three-element type `Ineq` is used to represent the strength of a comparison between\nterms. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L101-L110","name":"Linarith.Linexp.cmp","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.cmp","doc":"Defines a lex ordering on `Linexp`. This function is performance critical.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L95-L96","name":"Linarith.Linexp.vars","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.vars","doc":"`l.vars` returns the list of variables that occur in `l`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L89-L92","name":"Linarith.Linexp.zfind","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.zfind","doc":"`l.zfind n` returns the value associated with key `n` if there is one, and 0 otherwise.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L84-L84","name":"Linarith.Linexp.contains","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.contains","doc":"`l.contains n` is true iff `n` is the first element of a pair in `l`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L74-L79","name":"Linarith.Linexp.get","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.get","doc":"`l.get n` returns the value in `l` associated with key `n`, if it exists, and `none` otherwise.\nThis function assumes that `l` is sorted in decreasing order of the first argument,\nthat is, it will return `none` as soon as it finds a key smaller than `n`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L64-L67","name":"Linarith.Linexp.scale","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.scale","doc":"`l.scale c` scales the values in `l` by `c` without modifying the order or keys. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L53-L61","name":"Linarith.Linexp.add","kind":"opaque","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.add","doc":"Add two `Linexp`s together componentwise.\nPreserves sorting and uniqueness of the first argument.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L46-L46","name":"Linarith.Linexp","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp","doc":"A linear expression is a list of pairs of variable indices and coefficients,\nrepresenting the sum of the products of each coefficient with its corresponding variable.\n\nSome functions on `Linexp` assume that `n : Nat` occurs at most once as the first element of a pair,\nand that the list is sorted in decreasing order of the first argument.\nThis is not enforced by the type but the operations here preserve it.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L31-L33","name":"Linarith.linarithTraceProofs","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.linarithTraceProofs","doc":"A shorthand for tracing the types of a list of proof terms\nwhen the `trace.linarith` option is set to true.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L1-L1","name":"Linarith.LinarithConfig.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L1-L1","name":"Linarith.Preprocessor.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L1-L1","name":"Linarith.GlobalPreprocessor.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L1-L1","name":"Linarith.Comp.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Datatypes.lean#L1-L1","name":"Linarith.GlobalBranchingPreprocessor.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.mk","doc":""}]}