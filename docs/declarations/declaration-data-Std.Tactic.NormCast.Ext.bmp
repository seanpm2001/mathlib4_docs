{"name":"Std.Tactic.NormCast.Ext","instances":[{"typeNames":["Eq","Std.Tactic.NormCast.Label"],"name":"Std.Tactic.NormCast.instDecidableEqLabel","className":"Decidable"},{"typeNames":["Std.Tactic.NormCast.Label"],"name":"Std.Tactic.NormCast.instReprLabel","className":"Repr"},{"typeNames":["Std.Tactic.NormCast.Label"],"name":"Std.Tactic.NormCast.instInhabitedLabel","className":"Inhabited"},{"typeNames":["Std.Tactic.NormCast.NormCastExtension"],"name":"Std.Tactic.NormCast.instInhabitedNormCastExtension","className":"Inhabited"}],"imports":["Init","Lean.Meta.CongrTheorems","Lean.Meta.Tactic.Simp.SimpTheorems","Std.Tactic.CoeExt"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L153-L201","name":"Std.Tactic.NormCast.Attr.norm_cast","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Attr.norm_cast","doc":"The `norm_cast` attribute should be given to lemmas that describe the\nbehaviour of a coercion in regard to an operator, a relation, or a particular\nfunction.\n\nIt only concerns equality or iff lemmas involving `↑`, `⇑` and `↥`, describing the behavior of\nthe coercion functions.\nIt does not apply to the explicit functions that define the coercions.\n\nExamples:\n```lean\n@[norm_cast] theorem coe_nat_inj' {m n : ℕ} : (↑m : ℤ) = ↑n ↔ m = n\n\n@[norm_cast] theorem coe_int_denom (n : ℤ) : (n : ℚ).denom = 1\n\n@[norm_cast] theorem cast_id : ∀ n : ℚ, ↑n = n\n\n@[norm_cast] theorem coe_nat_add (m n : ℕ) : (↑(m + n) : ℤ) = ↑m + ↑n\n\n@[norm_cast] theorem cast_coe_nat (n : ℕ) : ((n : ℤ) : α) = n\n\n@[norm_cast] theorem cast_one : ((1 : ℚ) : α) = 1\n```\n\nLemmas tagged with `@[norm_cast]` are classified into three categories: `move`, `elim`, and\n`squash`. They are classified roughly as follows:\n\n* elim lemma:   LHS has 0 head coes and ≥ 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes\n* squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes\n\n`norm_cast` uses `move` and `elim` lemmas to factor coercions toward the root of an expression\nand to cancel them from both sides of an equation or relation. It uses `squash` lemmas to clean\nup the result.\n\nOccasionally you may want to override the automatic classification.\nYou can do this by giving an optional `elim`, `move`, or `squash` parameter to the attribute.\n\n```lean\n@[simp, norm_cast elim] lemma nat_cast_re (n : ℕ) : (n : ℂ).re = n := by\n  rw [← of_real_nat_cast, of_real_re]\n```\n\nDon't do this unless you understand what you are doing.\n\nA full description of the tactic, and the use of each lemma category, can be found at\n<https://lean-forward.github.io/norm_cast/norm_cast.pdf>.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L149-L150","name":"Std.Tactic.NormCast.Attr.normCastLabel","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Attr.normCastLabel","doc":"The possible `norm_cast` kinds: `elim`, `move`, or `squash`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L140-L146","name":"Std.Tactic.NormCast.addInfer","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addInfer","doc":"`addInfer decl` infers the label of `decl` and adds it to the cache.\n\n* elim lemma:   LHS has 0 head coes and ≥ 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes\n* squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L128-L132","name":"Std.Tactic.NormCast.addSquash","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addSquash","doc":"`addSquash decl` adds `decl` as a `squash` lemma to the cache. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L121-L125","name":"Std.Tactic.NormCast.addMove","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addMove","doc":"`addMove decl` adds `decl` as a `move` lemma to the cache. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L116-L118","name":"Std.Tactic.NormCast.addElim","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addElim","doc":"`addElim decl` adds `decl` as an `elim` lemma to the cache. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L108-L113","name":"Std.Tactic.NormCast.normCastExt","kind":"opaque","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.normCastExt","doc":"The `norm_cast` extension data. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L106-L106","name":"Std.Tactic.NormCast.instInhabitedNormCastExtension","kind":"instance","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instInhabitedNormCastExtension","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L105-L105","name":"Std.Tactic.NormCast.NormCastExtension.squash","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.squash","doc":"A simp set which simplifies transitive coercions. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L103-L103","name":"Std.Tactic.NormCast.NormCastExtension.down","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.down","doc":"A simp set which pushes coercion arrows to the leaves. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L101-L101","name":"Std.Tactic.NormCast.NormCastExtension.up","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.up","doc":"A simp set which lifts coercion arrows to the top level. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L99-L106","name":"Std.Tactic.NormCast.NormCastExtension","kind":"structure","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension","doc":"The `norm_cast` attribute stores three simp sets. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L92-L96","name":"Std.Tactic.NormCast.pushCastExt","kind":"opaque","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.pushCastExt","doc":"The `push_cast` simp attribute. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L67-L90","name":"Std.Tactic.NormCast.classifyType","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.classifyType","doc":"Classifies a declaration of type `ty` as a `norm_cast` rule. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L63-L64","name":"Std.Tactic.NormCast.countInternalCoes","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.countInternalCoes","doc":"Count how many coercions are inside the expression, excluding the top ones. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L51-L60","name":"Std.Tactic.NormCast.countCoes","kind":"opaque","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.countCoes","doc":"Count how many coercions are inside the expression, including the top ones. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L43-L48","name":"Std.Tactic.NormCast.countHeadCoes","kind":"opaque","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.countHeadCoes","doc":"Count how many coercions are at the top of the expression. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L32-L40","name":"Std.Tactic.NormCast.getSimpArgs","kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.getSimpArgs","doc":"Assuming `e` is an application, returns the list of subterms that `simp` will rewrite in. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L29-L29","name":"Std.Tactic.NormCast.instInhabitedLabel","kind":"instance","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instInhabitedLabel","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L29-L29","name":"Std.Tactic.NormCast.instReprLabel","kind":"instance","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instReprLabel","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L29-L29","name":"Std.Tactic.NormCast.instDecidableEqLabel","kind":"instance","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instDecidableEqLabel","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L27-L28","name":"Std.Tactic.NormCast.Label.squash","kind":"ctor","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label.squash","doc":"squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L24-L26","name":"Std.Tactic.NormCast.Label.move","kind":"ctor","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label.move","doc":"move lemma: LHS has 1 head coe and 0 internal coes,\nRHS has 0 head coes and ≥ 1 internal coes "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L22-L23","name":"Std.Tactic.NormCast.Label.elim","kind":"ctor","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label.elim","doc":"elim lemma: LHS has 0 head coes and ≥ 1 internal coe "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L21-L29","name":"Std.Tactic.NormCast.Label","kind":"inductive","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label","doc":"`Label` is a type used to classify `norm_cast` lemmas.\n* elim lemma:   LHS has 0 head coes and ≥ 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes\n* squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/NormCast/Ext.lean#L1-L1","name":"Std.Tactic.NormCast.NormCastExtension.mk","kind":"ctor","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.mk","doc":""}]}