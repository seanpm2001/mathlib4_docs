{"name":"Mathlib.Tactic.LiftLets","instances":[],"imports":["Init","Mathlib.Tactic.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LiftLets.lean#L86-L101","name":"Mathlib.lift_lets","kind":"def","docLink":"./Mathlib/Tactic/LiftLets.html#Mathlib.lift_lets","doc":"Lift all the `let` bindings in the type of an expression as far out as possible.\n\nWhen applied to the main goal, this gives one the ability to `intro` embedded `let` expressions.\nFor example,\n```lean\nexample : (let x := 1; x) = 1 := by\n  lift_lets\n  -- ‚ä¢ let x := 1; x = 1\n  intro x\n  sorry\n```\n\nDuring the lifting process, let bindings are merged if they have the same type and value.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LiftLets.lean#L81-L82","name":"Lean.Expr.liftLets","kind":"def","docLink":"./Mathlib/Tactic/LiftLets.html#Lean.Expr.liftLets","doc":"Take all the `let`s in an expression and move them outwards as far as possible.\nAll top-level `let`s are added to the local context, and then `f` is called with the list\nof local bindings (each an fvar) and the new expression.\n\nLet bindings are merged if they have the same type and value.\n\nUse `e.liftLets mkLetFVars` to get a defeq expression with all `let`s lifted as far as possible. "}]}