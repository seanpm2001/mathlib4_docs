{"name":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","instances":[{"typeNames":["HomologicalComplex.X","Nat","ComplexShape.up","AddRightCancelMonoid.toAddRightCancelSemigroup","AddCancelMonoid.toAddRightCancelMonoid","AddCancelCommMonoid.toAddCancelMonoid","OrderedCancelAddCommMonoid.toCancelAddCommMonoid","StrictOrderedSemiring.toOrderedCancelAddCommMonoid","Nat.strictOrderedSemiring","CanonicallyOrderedCommSemiring.toOne","Nat.canonicallyOrderedCommSemiring","Prefunctor.obj","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","CochainComplex","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","HomologicalComplex.instCategoryHomologicalComplex","CategoryTheory.Functor.toPrefunctor","CochainComplex.single₀","HomologicalComplex.X","Nat","ComplexShape.up","AddRightCancelMonoid.toAddRightCancelSemigroup","AddCancelMonoid.toAddRightCancelMonoid","AddCancelCommMonoid.toAddCancelMonoid","OrderedCancelAddCommMonoid.toCancelAddCommMonoid","StrictOrderedSemiring.toOrderedCancelAddCommMonoid","Nat.strictOrderedSemiring","CanonicallyOrderedCommSemiring.toOne","Nat.canonicallyOrderedCommSemiring","CategoryTheory.InjectiveResolution.cocomplex","HomologicalComplex.Hom.f","Nat","ComplexShape.up","AddRightCancelMonoid.toAddRightCancelSemigroup","AddCancelMonoid.toAddRightCancelMonoid","AddCancelCommMonoid.toAddCancelMonoid","OrderedCancelAddCommMonoid.toCancelAddCommMonoid","StrictOrderedSemiring.toOrderedCancelAddCommMonoid","Nat.strictOrderedSemiring","CanonicallyOrderedCommSemiring.toOne","Nat.canonicallyOrderedCommSemiring","Prefunctor.obj","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","CochainComplex","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","HomologicalComplex.instCategoryHomologicalComplex","CategoryTheory.Functor.toPrefunctor","CochainComplex.single₀","CategoryTheory.InjectiveResolution.cocomplex","CategoryTheory.InjectiveResolution.ι"],"name":"CategoryTheory.InjectiveResolution.instMonoXNatUpToAddRightCancelSemigroupToAddRightCancelMonoidToAddCancelMonoidToCancelAddCommMonoidToOrderedCancelAddCommMonoidStrictOrderedSemiringToOneCanonicallyOrderedCommSemiringObjToQuiverToCategoryStructCochainComplexToQuiverToCategoryStructInstCategoryHomologicalComplexToPrefunctorSingle₀CocomplexFι","className":"CategoryTheory.Mono"}],"imports":["Init","Mathlib.CategoryTheory.Preadditive.Injective","Mathlib.Algebra.Homology.Single"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L124-L139","name":"CategoryTheory.InjectiveResolution.self","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.self","doc":"An injective object admits a trivial injective resolution: itself in degree 0. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L118-L121","name":"CategoryTheory.InjectiveResolution.instMonoXNatUpToAddRightCancelSemigroupToAddRightCancelMonoidToAddCancelMonoidToCancelAddCommMonoidToOrderedCancelAddCommMonoidStrictOrderedSemiringToOneCanonicallyOrderedCommSemiringObjToQuiverToCategoryStructCochainComplexToQuiverToCategoryStructInstCategoryHomologicalComplexToPrefunctorSingle₀CocomplexFι","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.instMonoXNatUpToAddRightCancelSemigroupToAddRightCancelMonoidToAddCancelMonoidToCancelAddCommMonoidToOrderedCancelAddCommMonoidStrictOrderedSemiringToOneCanonicallyOrderedCommSemiringObjToQuiverToCategoryStructCochainComplexToQuiverToCategoryStructInstCategoryHomologicalComplexToPrefunctorSingle₀CocomplexFι","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L112-L114","name":"CategoryTheory.InjectiveResolution.complex_d_comp","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.complex_d_comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L105-L107","name":"CategoryTheory.InjectiveResolution.ι_f_zero_comp_complex_d","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.ι_f_zero_comp_complex_d","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L98-L100","name":"CategoryTheory.InjectiveResolution.ι_f_succ","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.ι_f_succ","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L88-L88","name":"CategoryTheory.HasInjectiveResolutions.out","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.HasInjectiveResolutions.out","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L87-L88","name":"CategoryTheory.HasInjectiveResolutions","kind":"class","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.HasInjectiveResolutions","doc":"You will rarely use this typeclass directly: it is implied by the combination\n`[EnoughInjectives C]` and `[Abelian C]`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L76-L76","name":"CategoryTheory.HasInjectiveResolution.out","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.HasInjectiveResolution.out","doc":"An object admits an injective resolution. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L75-L75","name":"CategoryTheory.HasInjectiveResolution.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.HasInjectiveResolution.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L75-L76","name":"CategoryTheory.HasInjectiveResolution","kind":"class","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.HasInjectiveResolution","doc":"An object admits an injective resolution. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L64-L64","name":"CategoryTheory.InjectiveResolution.mono","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.mono","doc":"An `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n\nExcept in situations where you want to provide a particular injective resolution\n(for example to compute a derived functor),\nyou will not typically need to use this bundled object, and will instead use\n* `injectiveResolution Z`: the `ℕ`-indexed cochain complex\n  (equipped with `injective` and `exact` instances)\n* `InjectiveResolution.ι Z`: the cochain map from  `(single C _ 0).obj Z` to\n  `InjectiveResolution Z` (all the components are equipped with `Mono` instances,\n  and when the category is `Abelian` we will show `ι` is a quasi-iso).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L63-L63","name":"CategoryTheory.InjectiveResolution.exact","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.exact","doc":"An `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n\nExcept in situations where you want to provide a particular injective resolution\n(for example to compute a derived functor),\nyou will not typically need to use this bundled object, and will instead use\n* `injectiveResolution Z`: the `ℕ`-indexed cochain complex\n  (equipped with `injective` and `exact` instances)\n* `InjectiveResolution.ι Z`: the cochain map from  `(single C _ 0).obj Z` to\n  `InjectiveResolution Z` (all the components are equipped with `Mono` instances,\n  and when the category is `Abelian` we will show `ι` is a quasi-iso).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L62-L62","name":"CategoryTheory.InjectiveResolution.exact₀","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.exact₀","doc":"An `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n\nExcept in situations where you want to provide a particular injective resolution\n(for example to compute a derived functor),\nyou will not typically need to use this bundled object, and will instead use\n* `injectiveResolution Z`: the `ℕ`-indexed cochain complex\n  (equipped with `injective` and `exact` instances)\n* `InjectiveResolution.ι Z`: the cochain map from  `(single C _ 0).obj Z` to\n  `InjectiveResolution Z` (all the components are equipped with `Mono` instances,\n  and when the category is `Abelian` we will show `ι` is a quasi-iso).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L61-L61","name":"CategoryTheory.InjectiveResolution.injective","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.injective","doc":"An `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n\nExcept in situations where you want to provide a particular injective resolution\n(for example to compute a derived functor),\nyou will not typically need to use this bundled object, and will instead use\n* `injectiveResolution Z`: the `ℕ`-indexed cochain complex\n  (equipped with `injective` and `exact` instances)\n* `InjectiveResolution.ι Z`: the cochain map from  `(single C _ 0).obj Z` to\n  `InjectiveResolution Z` (all the components are equipped with `Mono` instances,\n  and when the category is `Abelian` we will show `ι` is a quasi-iso).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L60-L60","name":"CategoryTheory.InjectiveResolution.ι","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.ι","doc":"An `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n\nExcept in situations where you want to provide a particular injective resolution\n(for example to compute a derived functor),\nyou will not typically need to use this bundled object, and will instead use\n* `injectiveResolution Z`: the `ℕ`-indexed cochain complex\n  (equipped with `injective` and `exact` instances)\n* `InjectiveResolution.ι Z`: the cochain map from  `(single C _ 0).obj Z` to\n  `InjectiveResolution Z` (all the components are equipped with `Mono` instances,\n  and when the category is `Abelian` we will show `ι` is a quasi-iso).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L59-L59","name":"CategoryTheory.InjectiveResolution.cocomplex","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.cocomplex","doc":"An `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n\nExcept in situations where you want to provide a particular injective resolution\n(for example to compute a derived functor),\nyou will not typically need to use this bundled object, and will instead use\n* `injectiveResolution Z`: the `ℕ`-indexed cochain complex\n  (equipped with `injective` and `exact` instances)\n* `InjectiveResolution.ι Z`: the cochain map from  `(single C _ 0).obj Z` to\n  `InjectiveResolution Z` (all the components are equipped with `Mono` instances,\n  and when the category is `Abelian` we will show `ι` is a quasi-iso).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L58-L58","name":"CategoryTheory.InjectiveResolution.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L58-L64","name":"CategoryTheory.InjectiveResolution","kind":"structure","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.InjectiveResolution","doc":"An `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n\nExcept in situations where you want to provide a particular injective resolution\n(for example to compute a derived functor),\nyou will not typically need to use this bundled object, and will instead use\n* `injectiveResolution Z`: the `ℕ`-indexed cochain complex\n  (equipped with `injective` and `exact` instances)\n* `InjectiveResolution.ι Z`: the cochain map from  `(single C _ 0).obj Z` to\n  `InjectiveResolution Z` (all the components are equipped with `Mono` instances,\n  and when the category is `Abelian` we will show `ι` is a quasi-iso).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean#L1-L1","name":"CategoryTheory.HasInjectiveResolutions.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Preadditive/InjectiveResolution.html#CategoryTheory.HasInjectiveResolutions.mk","doc":""}]}