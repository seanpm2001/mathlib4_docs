{"name":"Mathlib.Tactic.ApplyFun","instances":[],"imports":["Init","Mathlib.Lean.Expr.Basic","Mathlib.Order.Monotone.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ApplyFun.lean#L137-L170","name":"Mathlib.Tactic.applyFun","kind":"def","docLink":"./Mathlib/Tactic/ApplyFun.html#Mathlib.Tactic.applyFun","doc":"Apply a function to an equality or inequality in either a local hypothesis or the goal.\n\n* If we have `h : a = b`, then `apply_fun f at h` will replace this with `h : f a = f b`.\n* If we have `h : a ≤ b`, then `apply_fun f at h` will replace this with `h : f a ≤ f b`,\n  and create a subsidiary goal `Monotone f`.\n  `apply_fun` will automatically attempt to discharge this subsidiary goal using `mono`,\n  or an explicit solution can be provided with `apply_fun f at h using P`, where `P : Monotone f`.\n* If the goal is `a ≠ b`, `apply_fun f` will replace this with `f a ≠ f b`.\n* If the goal is `a = b`, `apply_fun f` will replace this with `f a = f b`,\n  and create a subsidiary goal `injective f`.\n  `apply_fun` will automatically attempt to discharge this subsidiary goal using local hypotheses,\n  or if `f` is actually an `Equiv`,\n  or an explicit solution can be provided with `apply_fun f using P`, where `P : Injective f`.\n* If the goal is `a ≤ b` (or similarly for `a < b`), and `f` is actually an `OrderIso`,\n  `apply_fun f` will replace the goal with `f a ≤ f b`.\n  If `f` is anything else (e.g. just a function, or an `Equiv`), `apply_fun` will fail.\n\n\nTypical usage is:\n```lean\nopen Function\n\nexample (X Y Z : Type) (f : X → Y) (g : Y → Z) (H : Injective <| g ∘ f) :\n    Injective f := by\n  intros x x' h\n  apply_fun g at h\n  exact H h\n```\n\nThe function `f` is handled similarly to how it would be handled by `refine` in that `f` can contain\nplaceholders. Named placeholders (like `?a` or `?_`) will produce new goals.\n "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ApplyFun.lean#L90-L135","name":"Mathlib.Tactic.applyFunTarget","kind":"def","docLink":"./Mathlib/Tactic/ApplyFun.html#Mathlib.Tactic.applyFunTarget","doc":"Apply a function to the main goal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ApplyFun.lean#L69-L87","name":"Mathlib.Tactic.maybeProveInjective","kind":"def","docLink":"./Mathlib/Tactic/ApplyFun.html#Mathlib.Tactic.maybeProveInjective","doc":"Given a metavariable `ginj` of type `Injective f`, try to prove it.\nReturns whether it was successful. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ApplyFun.lean#L64-L65","name":"Mathlib.Tactic.applyFunTargetFailure","kind":"def","docLink":"./Mathlib/Tactic/ApplyFun.html#Mathlib.Tactic.applyFunTargetFailure","doc":"Failure message for `applyFunTarget`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ApplyFun.lean#L26-L61","name":"Mathlib.Tactic.applyFunHyp","kind":"def","docLink":"./Mathlib/Tactic/ApplyFun.html#Mathlib.Tactic.applyFunHyp","doc":"Apply a function to a hypothesis. "}]}