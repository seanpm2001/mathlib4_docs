{"name":"Mathlib.Util.SynthesizeUsing","instances":[],"imports":["Init","Lean"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Util/SynthesizeUsing.lean#L85-L86","name":"synthesizeUsingTactic'","kind":"def","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsingTactic'","doc":"`synthesizeUsing' type tacticSyntax` synthesizes an element of type `type` by evaluating the\ngiven tactic syntax.\n\nExample:\n```lean\nlet e ← synthesizeUsingTactic' ty (← `(tactic| norm_num))\n```\n\nThe tactic must solve for all goals, in contrast to `synthesizeUsingTactic`.\n\nIf you need to insert expressions into a tactic proof, then you might use `synthesizeUsing'`\ndirectly, since the `TacticM` monad has access to the `TermElabM` monad. For example, here\nis a term elaborator that wraps the `simp at ...` tactic:\n```\ndef simpTerm (e : Expr) : MetaM Expr := do\n  let mvar ← Meta.mkFreshTypeMVar\n  let e' ← synthesizeUsing' mvar\n    (do evalTactic (← `(tactic| have h := $(← Term.exprToSyntax e); simp at h; exact h)))\n  -- Note: `simp` does not always insert type hints, so to ensure that we get a term\n  -- with the simplified type (as opposed to one that is merely defeq), we should add\n  -- a type hint ourselves.\n  Meta.mkExpectedTypeHint e' mvar\n\nelab \"simpTerm% \" t:term : term => do simpTerm (← Term.elabTerm t none)\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Util/SynthesizeUsing.lean#L55-L56","name":"synthesizeUsingTactic","kind":"def","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsingTactic","doc":"`synthesizeUsing type tacticSyntax` synthesizes an element of type `type` by evaluating the\ngiven tactic syntax.\n\nExample:\n```lean\nlet (gs, e) ← synthesizeUsingTactic ty (← `(tactic| congr!))\n```\n\nThe tactic `tac` is allowed to leave goals open, and these remain as metavariables in the\nreturned expression.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Util/SynthesizeUsing.lean#L35-L41","name":"synthesizeUsing'","kind":"def","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsing'","doc":"`synthesizeUsing type tac` synthesizes an element of type `type` using tactic `tac`.\n\nThe tactic must solve for all goals, in contrast to `synthesizeUsing`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Util/SynthesizeUsing.lean#L25-L28","name":"synthesizeUsing","kind":"def","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsing","doc":"`synthesizeUsing type tac` synthesizes an element of type `type` using tactic `tac`.\n\nThe tactic `tac` is allowed to leave goals open, and these remain as metavariables in the\nreturned expression.\n"}]}