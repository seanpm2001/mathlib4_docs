{"name":"Mathlib.Tactic.LinearCombination","instances":[{"typeNames":["Mathlib.Tactic.LinearCombination.Config"],"name":"Mathlib.Tactic.LinearCombination.instInhabitedConfig","className":"Inhabited"}],"imports":["Init","Mathlib.Tactic.Ring"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L223-L224","name":"Mathlib.Tactic.LinearCombination.tacticLinear_combination2____","kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.tacticLinear_combination2____","doc":"`linear_combination` attempts to simplify the target by creating a linear combination\n  of a list of equalities and subtracting it from the target.\n  The tactic will create a linear\n  combination by adding the equalities together from left to right, so the order\n  of the input hypotheses does matter.  If the `normalize` field of the\n  configuration is set to false, then the tactic will simply set the user up to\n  prove their target using the linear combination instead of normalizing the subtraction.\n\nNote: The left and right sides of all the equalities should have the same\n  type, and the coefficients should also have this type.  There must be\n  instances of `Mul` and `AddGroup` for this type.\n\n* The input `e` in `linear_combination e` is a linear combination of proofs of equalities,\n  given as a sum/difference of coefficients multiplied by expressions.\n  The coefficients may be arbitrary expressions.\n  The expressions can be arbitrary proof terms proving equalities.\n  Most commonly they are hypothesis names `h1, h2, ...`.\n* `linear_combination (norm := tac) e` runs the \"normalization tactic\" `tac`\n  on the subgoal(s) after constructing the linear combination.\n  * The default normalization tactic is `ring1`, which closes the goal or fails.\n  * To get a subgoal in the case that it is not immediately provable, use\n    `ring_nf` as the normalization tactic.\n  * To avoid normalization entirely, use `skip` as the normalization tactic.\n* `linear_combination2 e` is the same as `linear_combination e` but it produces two\n  subgoals instead of one: rather than proving that `(a - b) - (a' - b') = 0` where\n  `a' = b'` is the linear combination from `e` and `a = b` is the goal,\n  it instead attempts to prove `a = a'` and `b = b'`.\n  Because it does not use subtraction, this form is applicable also to semirings.\n  * Note that a goal which is provable by `linear_combination e` may not be provable\n    by `linear_combination2 e`; in general you may need to add a coefficient to `e`\n    to make both sides match, as in `linear_combination2 e + c`.\n  * You can also reverse equalities using `← h`, so for example if `h₁ : a = b`\n    then `2 * (← h)` is a proof of `2 * b = 2 * a`.\n\nExample Usage:\n```\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination 1*h1 - 2*h2\n\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination h1 - 2*h2\n\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination (norm := ring_nf) -2*h2\n  /- Goal: x * y + x * 2 - 1 = 0 -/\n\nexample (x y z : ℝ) (ha : x + 2*y - z = 4) (hb : 2*x + y + z = -2)\n    (hc : x + 2*y + z = 2) :\n    -3*x - 3*y - 4*z = 2 := by\n  linear_combination ha - hb - 2*hc\n\nexample (x y : ℚ) (h1 : x + y = 3) (h2 : 3*x = 7) :\n    x*x*y + y*x*y + 6*x = 3*x*y + 14 := by\n  linear_combination x*y*h1 + 2*h2\n\nexample (x y : ℤ) (h1 : x = -3) (h2 : y = 10) : 2*x = -6 := by\n  linear_combination (norm := skip) 2*h1\n  simp\n\naxiom qc : ℚ\naxiom hqc : qc = 2*qc\n\nexample (a b : ℚ) (h : ∀ p q : ℚ, p = q) : 3*a + qc = 3*b + 2*qc := by\n  linear_combination 3 * h a b + hqc\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L152-L219","name":"Mathlib.Tactic.LinearCombination.linearCombination","kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.linearCombination","doc":"`linear_combination` attempts to simplify the target by creating a linear combination\n  of a list of equalities and subtracting it from the target.\n  The tactic will create a linear\n  combination by adding the equalities together from left to right, so the order\n  of the input hypotheses does matter.  If the `normalize` field of the\n  configuration is set to false, then the tactic will simply set the user up to\n  prove their target using the linear combination instead of normalizing the subtraction.\n\nNote: The left and right sides of all the equalities should have the same\n  type, and the coefficients should also have this type.  There must be\n  instances of `Mul` and `AddGroup` for this type.\n\n* The input `e` in `linear_combination e` is a linear combination of proofs of equalities,\n  given as a sum/difference of coefficients multiplied by expressions.\n  The coefficients may be arbitrary expressions.\n  The expressions can be arbitrary proof terms proving equalities.\n  Most commonly they are hypothesis names `h1, h2, ...`.\n* `linear_combination (norm := tac) e` runs the \"normalization tactic\" `tac`\n  on the subgoal(s) after constructing the linear combination.\n  * The default normalization tactic is `ring1`, which closes the goal or fails.\n  * To get a subgoal in the case that it is not immediately provable, use\n    `ring_nf` as the normalization tactic.\n  * To avoid normalization entirely, use `skip` as the normalization tactic.\n* `linear_combination2 e` is the same as `linear_combination e` but it produces two\n  subgoals instead of one: rather than proving that `(a - b) - (a' - b') = 0` where\n  `a' = b'` is the linear combination from `e` and `a = b` is the goal,\n  it instead attempts to prove `a = a'` and `b = b'`.\n  Because it does not use subtraction, this form is applicable also to semirings.\n  * Note that a goal which is provable by `linear_combination e` may not be provable\n    by `linear_combination2 e`; in general you may need to add a coefficient to `e`\n    to make both sides match, as in `linear_combination2 e + c`.\n  * You can also reverse equalities using `← h`, so for example if `h₁ : a = b`\n    then `2 * (← h)` is a proof of `2 * b = 2 * a`.\n\nExample Usage:\n```\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination 1*h1 - 2*h2\n\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination h1 - 2*h2\n\nexample (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by\n  linear_combination (norm := ring_nf) -2*h2\n  /- Goal: x * y + x * 2 - 1 = 0 -/\n\nexample (x y z : ℝ) (ha : x + 2*y - z = 4) (hb : 2*x + y + z = -2)\n    (hc : x + 2*y + z = 2) :\n    -3*x - 3*y - 4*z = 2 := by\n  linear_combination ha - hb - 2*hc\n\nexample (x y : ℚ) (h1 : x + y = 3) (h2 : 3*x = 7) :\n    x*x*y + y*x*y + 6*x = 3*x*y + 14 := by\n  linear_combination x*y*h1 + 2*h2\n\nexample (x y : ℤ) (h1 : x = -3) (h2 : y = 10) : 2*x = -6 := by\n  linear_combination (norm := skip) 2*h1\n  simp\n\naxiom qc : ℚ\naxiom hqc : qc = 2*qc\n\nexample (a b : ℚ) (h : ∀ p q : ℚ, p = q) : 3*a + qc = 3*b + 2*qc := by\n  linear_combination 3 * h a b + hqc\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L145-L150","name":"Mathlib.Tactic.LinearCombination.normStx","kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.normStx","doc":"The `(norm := $tac)` syntax says to use `tac` as a normalization postprocessor for\n`linear_combination`. The default normalizer is `ring1`, but you can override it with `ring_nf`\nto get subgoals from `linear_combination` or with `skip` to disable normalization.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L127-L143","name":"Mathlib.Tactic.LinearCombination.elabLinearCombination","kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.elabLinearCombination","doc":"Implementation of `linear_combination` and `linear_combination2`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L123-L124","name":"Mathlib.Tactic.LinearCombination.eq_of_add","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.eq_of_add","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L121-L121","name":"Mathlib.Tactic.LinearCombination.eq_trans₃","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.eq_trans₃","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L118-L119","name":"Mathlib.Tactic.LinearCombination.elabConfig","kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.elabConfig","doc":"Function elaborating `LinearCombination.Config` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L116-L116","name":"Mathlib.Tactic.LinearCombination.instInhabitedConfig","kind":"instance","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.instInhabitedConfig","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L115-L115","name":"Mathlib.Tactic.LinearCombination.Config.normTac","kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config.normTac","doc":"the tactic used for normalization when checking\nif the weighted sum is equivalent to the goal (when `normalize` is `true`). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L112-L112","name":"Mathlib.Tactic.LinearCombination.Config.twoGoals","kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config.twoGoals","doc":"whether to make separate subgoals for both sides or just one for `lhs - rhs = 0` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L110-L110","name":"Mathlib.Tactic.LinearCombination.Config.normalize","kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config.normalize","doc":"whether or not the normalization step should be used "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L108-L116","name":"Mathlib.Tactic.LinearCombination.Config","kind":"structure","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config","doc":"A configuration object for `linear_combination`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L61-L105","name":"Mathlib.Tactic.LinearCombination.expandLinearCombo","kind":"opaque","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.expandLinearCombo","doc":"Performs macro expansion of a linear combination expression,\nusing `+`/`-`/`*`/`/` on equations and values.\n* `some p` means that `p` is a syntax corresponding to a proof of an equation.\n  For example, if `h : a = b` then `expandLinearCombo (2 * h)` returns `some (c_add_pf 2 h)`\n  which is a proof of `2 * a = 2 * b`.\n* `none` means that the input expression is not an equation but a value;\n  the input syntax itself is used in this case.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L50-L50","name":"Mathlib.Tactic.LinearCombination.div_pf","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.div_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L49-L49","name":"Mathlib.Tactic.LinearCombination.c_div_pf","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.c_div_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L48-L48","name":"Mathlib.Tactic.LinearCombination.pf_div_c","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.pf_div_c","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L47-L47","name":"Mathlib.Tactic.LinearCombination.inv_pf","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.inv_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L46-L46","name":"Mathlib.Tactic.LinearCombination.mul_pf","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.mul_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L45-L45","name":"Mathlib.Tactic.LinearCombination.c_mul_pf","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.c_mul_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L44-L44","name":"Mathlib.Tactic.LinearCombination.pf_mul_c","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.pf_mul_c","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L43-L43","name":"Mathlib.Tactic.LinearCombination.neg_pf","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.neg_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L42-L42","name":"Mathlib.Tactic.LinearCombination.sub_pf","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.sub_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L41-L41","name":"Mathlib.Tactic.LinearCombination.c_sub_pf","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.c_sub_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L40-L40","name":"Mathlib.Tactic.LinearCombination.pf_sub_c","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.pf_sub_c","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L39-L39","name":"Mathlib.Tactic.LinearCombination.add_pf","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.add_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L38-L38","name":"Mathlib.Tactic.LinearCombination.c_add_pf","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.c_add_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L37-L37","name":"Mathlib.Tactic.LinearCombination.pf_add_c","kind":"theorem","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.pf_add_c","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L1-L1","name":"Mathlib.Tactic.LinearCombination.Config.mk","kind":"ctor","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config.mk","doc":""}]}