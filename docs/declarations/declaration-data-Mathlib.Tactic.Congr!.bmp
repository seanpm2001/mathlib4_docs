{"name":"Mathlib.Tactic.Congr!","instances":[],"imports":["Init","Lean","Mathlib.Tactic.Relation.Rfl","Std.Logic","Std.Tactic.RCases"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L869-L937","name":"Congr!.congr!","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.congr!","doc":"Equates pieces of the left-hand side of a goal to corresponding pieces of the right-hand side by\nrecursively applying congruence lemmas. For example, with `⊢ f as = g bs` we could get\ntwo goals `⊢ f = g` and `⊢ as = bs`.\n\nSyntax:\n```\ncongr!\ncongr! n\ncongr! with x y z\ncongr! n with x y z\n```\nHere, `n` is a natural number and `x`, `y`, `z` are `rintro` patterns (like `h`, `rfl`, `⟨x, y⟩`,\n`_`, `-`, `(h | h)`, etc.).\n\nThe `congr!` tactic is similar to `congr` but is more insistent in trying to equate left-hand sides\nto right-hand sides of goals. Here is a list of things it can try:\n\n- If `R` in `⊢ R x y` is a reflexive relation, it will convert the goal to `⊢ x = y` if possible.\n  The list of reflexive relations is maintained using the `@[refl]` attribute.\n  As a special case, `⊢ p ↔ q` is converted to `⊢ p = q` during congruence processing and then\n  returned to `⊢ p ↔ q` form at the end.\n\n- If there is a user congruence lemma associated to the goal (for instance, a `@[congr]`-tagged\n  lemma applying to `⊢ List.map f xs = List.map g ys`), then it will use that.\n\n- It uses a congruence lemma generator at least as capable as the one used by `congr` and `simp`.\n  If there is a subexpression that can be rewritten by `simp`, then `congr!` should be able\n  to generate an equality for it.\n\n- It can do congruences of pi types using lemmas like `implies_congr` and `pi_congr`.\n\n- Before applying congruences, it will run the `intros` tactic automatically.\n  The introduced variables can be given names using a `with` clause.\n  This helps when congruence lemmas provide additional assumptions in hypotheses.\n\n- When there is an equality between functions, so long as at least one is obviously a lambda, we\n  apply `funext` or `Function.hfunext`, which allows for congruence of lambda bodies.\n\n- It can try to close goals using a few strategies, including checking\n  definitional equality, trying to apply `Subsingleton.elim` or `proof_irrel_heq`, and using the\n  `assumption` tactic.\n\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr!` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr!` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr! 2` produces the intended `⊢ x + y = y + x`.\n\nThe `congr!` tactic also takes a configuration option, for example\n```lean\ncongr! (config := {transparency := .default}) 2\n```\nThis overrides the default, which is to apply congruence lemmas at reducible transparency.\n\nThe `congr!` tactic is aggressive with equating two sides of everything. There is a predefined\nconfiguration that uses a different strategy:\nTry\n```lean\ncongr! (config := .unfoldSameFun)\n```\nThis only allows congruences between functions applications of definitionally equal functions,\nand it applies congruence lemmas at default transparency (rather than just reducible).\nThis is somewhat like `congr`.\n\nSee `Congr!.Config` for all options.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L867-L867","name":"Congr!.elabConfig","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.elabConfig","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L852-L863","name":"Lean.MVarId.congrN!.go","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.congrN!.go","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L846-L851","name":"Lean.MVarId.congrN!.post","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.congrN!.post","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L835-L863","name":"Lean.MVarId.congrN!","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.congrN!","doc":"A more insistent version of `Lean.MVarId.congrN`.\nSee the documentation on the `congr!` syntax.\n\nThe `depth?` argument controls the depth of the recursion. If `none`, then it uses a reasonably\nlarge bound that is linear in the expression depth. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L818-L828","name":"Lean.MVarId.postCongr!","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.postCongr!","doc":"A pass to clean up after `Lean.MVarId.preCongr!` and `Lean.MVarId.congrCore!`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L795-L815","name":"Lean.MVarId.congrCore!","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.congrCore!","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L780-L793","name":"Lean.MVarId.preCongr!","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.preCongr!","doc":"Convert a goal into an `Eq` goal if possible (since we have a better shot at those).\nAlso try to dispatch the goal using an assumption, `Subsingleton.Elim`, or definitional equality. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L765-L776","name":"Lean.MVarId.introsClean.isTrivialType","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.introsClean.isTrivialType","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L743-L764","name":"Lean.MVarId.introsClean.loop","kind":"opaque","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.introsClean.loop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L739-L742","name":"Lean.MVarId.introsClean.eqImpOfIffImp","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.introsClean.eqImpOfIffImp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L735-L738","name":"Lean.MVarId.introsClean.heqImpOfEqImp","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.introsClean.heqImpOfEqImp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L732-L776","name":"Lean.MVarId.introsClean","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.introsClean","doc":"Does `Lean.MVarId.intros` but then cleans up the introduced hypotheses, removing anything\nthat is trivial. If there are any patterns in the current `CongrMetaM` state then instead\nof `Lean.MVarId.intros` it does `Std.Tactic.RCases.rintro`.\n\nCleaning up includes:\n- deleting hypotheses of the form `HEq x x`, `x = x`, and `x ↔ x`.\n- deleting Prop hypotheses that are already in the local context.\n- converting `HEq x y` to `x = y` if possible.\n- converting `x = y` to `x ↔ y` if possible.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L703-L708","name":"CongrMetaM.nextPattern","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#CongrMetaM.nextPattern","doc":"Pop the next pattern from the current state. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L700-L700","name":"CongrMetaM","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#CongrMetaM","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L698-L698","name":"CongrState.patterns","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#CongrState.patterns","doc":"Patterns to use when doing intro. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L696-L696","name":"CongrState.goals","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#CongrState.goals","doc":"Accumulated goals that `congr!` could not handle. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L694-L698","name":"CongrState","kind":"structure","docLink":"./Mathlib/Tactic/Congr!.html#CongrState","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L683-L692","name":"Lean.MVarId.congrPasses!","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.congrPasses!","doc":"A list of all the congruence strategies used by `Lean.MVarId.congrCore!`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L664-L678","name":"Lean.MVarId.subsingletonHelim?","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.subsingletonHelim?","doc":"Try to apply `Subsingleton.helim` if the goal is a `HEq`. Tries synthesizing a `Subsingleton`\ninstance for both the LHS and the RHS.\n\nIf successful, this reduces proving `@HEq α x β y` to proving `α = β`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L652-L656","name":"Lean.MVarId.congrImplies?'","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.congrImplies?'","doc":"A version of `Lean.MVarId.congrImplies?` that uses `implies_congr'`\ninstead of `implies_congr`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L636-L640","name":"Lean.MVarId.obviousHfunext?","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.obviousHfunext?","doc":"Try to apply `Function.hfunext`, returning the new goals if it succeeds.\nLike `Lean.MVarId.obviousFunext?`, we only do so if at least one side of the `HEq` is a lambda.\nThis prevents unfolding of things like `Set`.\n\nNeed to have `Mathlib.Logic.Function.Basic` imported for this to succeed.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L623-L627","name":"Lean.MVarId.obviousFunext?","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.obviousFunext?","doc":"Try to apply `funext`, but only if it is an equality of two functions where at least one is\na lambda expression.\n\nOne thing this check prevents is accidentally applying `funext` to a set equality, but also when\ndoing congruence we don't want to apply `funext` unnecessarily.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L613-L614","name":"Lean.MVarId.congrPi?","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.congrPi?","doc":"Try to apply `pi_congr`. This is similar to `Lean.MVar.congrImplies?`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L588-L608","name":"Lean.MVarId.liftReflToEq","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.liftReflToEq","doc":"Use a `refl`-tagged lemma to convert the goal into an `Eq`. If this can't be done, returns\nthe original `MVarId`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L581-L582","name":"Lean.MVarId.rel_of_eq_and_refl","kind":"theorem","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.rel_of_eq_and_refl","doc":"Helper theorem for `Lean.MVar.liftReflToEq`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L563-L578","name":"Lean.MVarId.userCongr?.forSide","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.userCongr?.forSide","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L550-L578","name":"Lean.MVarId.userCongr?","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.userCongr?","doc":"Try applying user-provided congruence lemmas. If any are applicable,\nreturns a list of new goals.\n\nTries a congruence lemma associated to the LHS and then, if that failed, the RHS.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L538-L542","name":"Lean.MVarId.congrSimp?.mkCongrSimpNArgs","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.congrSimp?.mkCongrSimpNArgs","doc":"Like `mkCongrSimp?` but takes in a specific arity. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L524-L536","name":"Lean.MVarId.congrSimp?.forSide","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.congrSimp?.forSide","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L510-L542","name":"Lean.MVarId.congrSimp?","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.congrSimp?","doc":"Like `Lean.MVarId.congr?` but instead of using only the congruence lemma associated to the LHS,\nit tries the RHS too, in the order specified by `config.preferLHS`.\n\nIt uses `Lean.Meta.mkCongrSimp?` to generate a congruence lemma, like in the `congr` tactic.\n\nApplies the congruence generated congruence lemmas according to `config`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L471-L500","name":"Lean.MVarId.smartHCongr?.forSide","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.smartHCongr?.forSide","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L430-L470","name":"Lean.MVarId.smartHCongr?.loop","kind":"opaque","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.smartHCongr?.loop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L407-L500","name":"Lean.MVarId.smartHCongr?","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.smartHCongr?","doc":"This is like `Lean.MVarId.hcongr?` but (1) looks at both sides when generating the congruence lemma\nand (2) inserts additional hypotheses from equalities from previous arguments.\n\nIt uses `Congr!.mkHCongrThm` to generate the congruence lemmas.\n\nIf the goal is an `Eq`, uses `eq_of_heq` first.\n\nAs a backup strategy, it uses the LHS/RHS method like in `Lean.MVarId.congrSimp?`\n(where `Congr!.Config.preferLHS` determines which side to try first). This uses a particular side\nof the target, generates the congruence lemma, then tries applying it. This can make progress\nwith higher transparency settings. To help the unifier, in this mode it assumes both sides have the\nexact same function.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L371-L390","name":"Congr!.possiblyEqualTypes","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.possiblyEqualTypes","doc":"Returns whether or not it's reasonable to consider an equality between types  `ty1` and `ty2`.\nThe heuristic is the following:\n\n- If `ty1` and `ty2` are in `Prop`, then yes.\n- If in whnf both `ty1` and `ty2` have the same head and if (recursively) it's reasonable to\n  consider an equality between corresponding type arguments, then yes.\n- Otherwise, no.\n\nThis helps keep congr from going too far and generating hypotheses like `ℝ = ℤ`.\n\nTo keep things from going out of control, there is a `maxDepth`. Additionally, if we do the check\nwith `maxDepth = 0` then the heuristic answers \"no\". "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L350-L357","name":"Congr!.mkHCongrThm.trySolve","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.mkHCongrThm.trySolve","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L336-L349","name":"Congr!.mkHCongrThm.trySolveCore","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.mkHCongrThm.trySolveCore","doc":"Given a type that is a bunch of equalities implying a goal (for example, a basic\ncongruence lemma), prove it if possible. Basic congruence lemmas should be provable by this.\nThere are some extra tricks for handling arguments to richer congruence lemmas. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L317-L331","name":"Congr!.mkHCongrThm.withNewEqs.loop","kind":"opaque","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.mkHCongrThm.withNewEqs.loop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L315-L332","name":"Congr!.mkHCongrThm.withNewEqs","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.mkHCongrThm.withNewEqs","doc":"Introduce variables for equalities between the arrays of variables. Uses `fixedParams`\nto control whether to introduce an equality for each pair. The array of triples passed to `k`\nconsists of (1) the simple congr lemma HEq arg, (2) the richer HEq arg, and (3) how to\ncompute 1 in terms of 2. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L289-L309","name":"Congr!.mkHCongrThm.doubleTelescope.loop","kind":"opaque","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.mkHCongrThm.doubleTelescope.loop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L287-L310","name":"Congr!.mkHCongrThm.doubleTelescope","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.mkHCongrThm.doubleTelescope","doc":"Similar to doing `forallBoundedTelescope` twice, but makes use of the `fixed` array, which\nis used as a hint for whether both variables should be the same. This is only a hint though,\nsince we only respect it if the binding domains are equal.\nWe affix `'` to the second list of variables, and all the variables are introduced\nwith default binder info. Calls `k` with the xs, ys, and a revised `fixed` array "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L224-L357","name":"Congr!.mkHCongrThm","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.mkHCongrThm","doc":"Create a congruence lemma to prove that `HEq (f a₁ ... aₙ) (f' a₁' ... aₙ')`.\nEach argument produces a `HEq aᵢ aᵢ'` hypothesis, but we also supply these hypotheses the\nhypotheses that the preceding equalities have been proved (unlike in `mkHCongrWithArity`).\nThe first two arguments of the resulting theorem are for `f` and `f'`, followed by a proof\nof `f = f'`.\n\nWhen including hypotheses about previous hypotheses, we make use of dependency information\nand only include relevant equalities.\n\nThe argument `fty` denotes the type of `f`. Returns `(congrThmType, congrThmProof)`.\n\nFor the purpose of generating nicer lemmas that have a better chance at something like\n`to_additive` rewriting, this function supports generating lemmas where certain parameters\nare meant to be fixed.\n\n* If `fixedFun` is `false` (the default) then the lemma starts with three arguments for `f`, `f'`,\nand `h : f = f'`. Otherwise, if `fixedFun` is `true` then the lemma starts with just `f`.\n\n* If the `fixedParams` argument has `true` for a particular argument index, then this is a hint\nthat the congruence lemma may use the same parameter for both sides of the equality. There is\nno guarantee -- it respects it if the types are equal for that parameter (i.e., if the parameter\ndoes not depend on non-fixed parameters).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L167-L177","name":"Lean.MVarId.subsingletonElim","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.subsingletonElim","doc":"Try to close the goal using `Subsingleton.elim`. Returns whether or not it succeeds.\n\nWe are careful to apply `Subsingleton.elim` in a way that does not assign any metavariables.\nThis is to prevent the `Subsingleton Prop` instance from being used as justification to specialize\n`Sort _` to `Prop`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L148-L158","name":"Lean.MVarId.proofIrrelHeq","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.proofIrrelHeq","doc":"Try to close the goal with using `proof_irrel_heq`. Returns whether or not it succeeds.\n\nWe need to be somewhat careful not to assign metavariables while doing this, otherwise we might\nspecialize `Sort _` to `Prop`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L131-L140","name":"Lean.MVarId.propext","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.propext","doc":"Try to convert an `Eq` into an `Iff` by applying `propext`.\nIf successful, then returns then new goal, otherwise returns the original `MVarId`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L121-L125","name":"Lean.MVarId.iffOfEq","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Lean.MVarId.iffOfEq","doc":"Try to convert an `Iff` into an `Eq` by applying `iff_of_eq`.\nIf successful, returns the new goal, and otherwise returns the original `MVarId`.\n\nThis may be regarded as being a special case of `Lean.MVarId.liftReflToEq`, specifically for `Iff`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L112-L113","name":"Congr!.Config.maxArgsFor","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.maxArgsFor","doc":"According to the configuration, how many of the arguments in `numArgs` should be considered. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L108-L109","name":"Congr!.Config.numArgsOk","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.numArgsOk","doc":"Whether the given number of arguments is allowed to be considered. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L101-L105","name":"Congr!.Config.unfoldSameFun","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.unfoldSameFun","doc":"A configuration option that makes `congr!` do the sorts of aggressive unfoldings that `congr`\ndoes while also similarly preventing `congr!` from considering partial applications or congruences\nbetween different functions being applied. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L96-L96","name":"Congr!.Config.useCongrSimp","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.useCongrSimp","doc":"Whether to use the congruence generator that is used by `simp` and `congr`. This generator\nis more strict, and it does not respect all configuration settings. It does respect\n`preferLHS`, `partialApp` and `maxArgs` and transparency settings. It acts as if `sameFun := true`\nand it ignores `typeEqs`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L91-L91","name":"Congr!.Config.etaExpand","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.etaExpand","doc":"As a last pass, perform eta expansion of both sides of an equality. For example,\nthis transforms a bare `HAdd.hAdd` into `fun x y => x + y`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L88-L88","name":"Congr!.Config.typeEqs","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.typeEqs","doc":"Whether or not `congr!` should generate equalities between types even if the types\ndo not look plausibly equal. We have a heuristic in the main congruence generator that types\n`α` and `β` are *plausibly equal* according to the following algorithm:\n\n- If the types are both propositions, they are plausibly equal (iffs are plausible).\n- If the types are from different universes, they are not plausibly equal.\n- Suppose in whnf we have `α = f a₁ ... aₘ` and `β = g b₁ ... bₘ`. If `f` is not definitionally\n  equal to `g` or `m ≠ n`, then `α` and `β` are not plausibly equal.\n- If there is some `i` such that `aᵢ` and `bᵢ` are not plausibly equal, then `α` and `β` are\n  not plausibly equal.\n- Otherwise, `α` and `β` are plausibly equal.\n\nThe purpose of this is to prevent considering equalities like `ℕ = ℤ` while allowing equalities\nsuch as `Fin n = Fin m` or `Subtype p = Subtype q` (so long as these are subtypes of the\nsame type).\n\nThe way this is implemented is that the congruence generator, when it is comparing arguments\nin an equality of function applications, marks a function parameter to \"fixed\" if the provided\narguments are types that are not plausibly equal. The effect of this is that congruence succeeds\nif those arguments are defeq at `transparency` transparency. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L67-L67","name":"Congr!.Config.maxArgs","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.maxArgs","doc":"The maximum number of arguments to consider when doing congruence of function applications.\nFor example, with `f a b c = g w x y z`, setting `maxArgs := some 2` means it will only consider\neither `f a b = g w x y` and `c = z` or `f a = g w x`, `b = y`, and `c = z`. Setting\n`maxArgs := none` (the default) means no limit.\n\nWhen the functions are dependent, `maxArgs` can prevent congruence from working at all.\nIn `Fintype.card α = Fintype.card β`, one needs to have `maxArgs` at `2` or higher since\nthere is a `Fintype` instance argument that depends on the first.\n\nWhen there aren't such dependency issues, setting `maxArgs := some 1` causes `congr!` to\ndo congruence on a single argument at a time. This can be used in conjunction with the\niteration limit to control exactly how many arguments are to be processed by congruence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L54-L54","name":"Congr!.Config.sameFun","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.sameFun","doc":"Whether to require that both sides of an equality are applications of defeq functions.\nThat is, if true, `f a = g x` is only considered if `f` and `g` are defeq (making it be similar\nto the `congr` tactic). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L50-L50","name":"Congr!.Config.partialApp","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.partialApp","doc":"Allow both sides to be a partial applications.\nWhen false, given an equality `f a b = g x y z` this means we never consider\nproving `f a = g x y`.\n\nIn this case, we might still consider `f = g x` if a pass generates a congruence lemma using the\nleft-hand side. Use `sameFun := true` to ensure both sides are applications\nof the same function (making it be similar to the `congr` tactic). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L42-L42","name":"Congr!.Config.preferLHS","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.preferLHS","doc":"For passes that synthesize a congruence lemma using one side of the equality,\nwe run the pass both for the left-hand side and the right-hand side. If `preferLHS` is `true`\nthen we start with the left-hand side.\n\nThis can be used to control which side's definitions are expanded when applying the\ncongruence lemma (if `preferLHS = true` then the RHS can be expanded). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L35-L35","name":"Congr!.Config.preTransparency","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.preTransparency","doc":"The transparency level to use when doing transformations before applying congruence lemmas.\nThis includes trying to prove the goal by `rfl` and using the `assumption` tactic.\nBy default this is `.reducible`, which prevents unfolding of most definitions. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L31-L31","name":"Congr!.Config.transparency","kind":"def","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.transparency","doc":"The transparency level to use when applying a congruence theorem.\nBy default this is `.reducible`, which prevents unfolding of most definitions. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L28-L96","name":"Congr!.Config","kind":"structure","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config","doc":"The configuration for the `congr!` tactic. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L1-L1","name":"Congr!.Config.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Congr!.html#Congr!.Config.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Congr!.lean#L1-L1","name":"CongrState.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Congr!.html#CongrState.mk","doc":""}]}