{"name":"Std.Data.RBMap.Basic","instances":[{"typeNames":["Std.RBColor"],"name":"Std.instReprRBColor","className":"Repr"},{"typeNames":["Std.RBNode"],"name":"Std.instReprRBNode","className":"Repr"},{"typeNames":["Std.RBNode"],"name":"Std.RBNode.instEmptyCollectionRBNode","className":"EmptyCollection"},{"typeNames":["Std.RBNode"],"name":"Std.RBNode.instForInRBNode","className":"ForIn"},{"typeNames":["Std.RBNode","Std.RBNode.Stream"],"name":"Std.RBNode.instToStreamRBNodeStream","className":"ToStream"},{"typeNames":["Std.RBNode.Stream"],"name":"Std.RBNode.instStreamStream","className":"Stream"},{"typeNames":["Std.RBNode.All"],"name":"Std.RBNode.instDecidableAll","className":"Decidable"},{"typeNames":["Std.RBNode.Any"],"name":"Std.RBNode.instDecidableAny","className":"Decidable"},{"typeNames":["Std.RBNode"],"name":"Std.RBNode.instMembershipRBNode","className":"Membership"},{"typeNames":["Std.RBNode"],"name":"Std.RBNode.instBEqRBNode","className":"BEq"},{"typeNames":["Std.RBNode.cmpLT"],"name":"Std.RBNode.instDecidableCmpLT","className":"Decidable"},{"typeNames":["Std.RBNode.cmpEq"],"name":"Std.RBNode.instDecidableCmpEq","className":"Decidable"},{"typeNames":["Std.RBSet"],"name":"Std.RBSet.instEmptyCollectionRBSet","className":"EmptyCollection"},{"typeNames":["Std.RBSet"],"name":"Std.RBSet.instInhabitedRBSet","className":"Inhabited"},{"typeNames":["Std.RBSet"],"name":"Std.RBSet.instForInRBSet","className":"ForIn"},{"typeNames":["Std.RBSet","Std.RBNode.Stream"],"name":"Std.RBSet.instToStreamRBSetStream","className":"ToStream"},{"typeNames":["Std.RBSet"],"name":"Std.RBSet.instReprRBSet","className":"Repr"},{"typeNames":["Std.RBSet"],"name":"Std.RBSet.instMembershipRBSet","className":"Membership"},{"typeNames":["Std.RBSet"],"name":"Std.RBSet.instBEqRBSet","className":"BEq"},{"typeNames":["Std.RBMap"],"name":"Std.instEmptyCollectionRBMap","className":"EmptyCollection"},{"typeNames":["Std.RBMap"],"name":"Std.instInhabitedRBMap","className":"Inhabited"},{"typeNames":["Std.RBMap","Prod"],"name":"Std.RBMap.instForInRBMapProd","className":"ForIn"},{"typeNames":["Std.RBMap","Std.RBNode.Stream","Prod"],"name":"Std.RBMap.instToStreamRBMapStreamProd","className":"ToStream"},{"typeNames":["Std.RBMap.Keys","Array"],"name":"Std.RBMap.instCoeHeadKeysArray","className":"CoeHead"},{"typeNames":["Std.RBMap.Keys","List"],"name":"Std.RBMap.instCoeHeadKeysList","className":"CoeHead"},{"typeNames":["Std.RBMap.Keys"],"name":"Std.RBMap.instForInKeys","className":"ForIn"},{"typeNames":["Std.RBMap.Keys"],"name":"Std.RBMap.instForMKeys","className":"ForM"},{"typeNames":["Std.RBMap.Keys","Std.RBMap.Keys.Stream"],"name":"Std.RBMap.instToStreamKeysStream","className":"ToStream"},{"typeNames":["Std.RBMap.Keys.Stream"],"name":"Std.RBMap.instStreamStream","className":"Stream"},{"typeNames":["Std.RBMap.Values","Array"],"name":"Std.RBMap.instCoeHeadValuesArray","className":"CoeHead"},{"typeNames":["Std.RBMap.Values","List"],"name":"Std.RBMap.instCoeHeadValuesList","className":"CoeHead"},{"typeNames":["Std.RBMap.Values"],"name":"Std.RBMap.instForInValues","className":"ForIn"},{"typeNames":["Std.RBMap.Values"],"name":"Std.RBMap.instForMValues","className":"ForM"},{"typeNames":["Std.RBMap.Values","Std.RBMap.Values.Stream"],"name":"Std.RBMap.instToStreamValuesStream","className":"ToStream"},{"typeNames":["Std.RBMap.Values.Stream"],"name":"Std.RBMap.instStreamStream_1","className":"Stream"},{"typeNames":["Std.RBMap"],"name":"Std.RBMap.instReprRBMap","className":"Repr"},{"typeNames":["Std.RBMap"],"name":"Std.RBMap.instBEqRBMap","className":"BEq"}],"imports":["Init","Std.Classes.Order","Std.Control.ForInStep.Basic","Std.Logic","Std.Tactic.HaveI"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1105-L1106","name":"List.toRBMap","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#List.toRBMap","doc":"`O(n log n)`. Build a tree from an unsorted list by inserting them one at a time. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1098-L1098","name":"Std.RBMap.sdiff","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.sdiff","doc":"`O(n₁ * (log n₁ + log n₂))`. Constructs the set of all elements of `t₁` that are not in `t₂`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1092-L1093","name":"Std.RBMap.filter","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.filter","doc":"`O(n * log n)`. Constructs the set of all elements satisfying `p`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1087-L1089","name":"Std.RBMap.intersectWith","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.intersectWith","doc":"`O(n₁ * log (n₁ + n₂))`. Intersects the maps `t₁` and `t₂`\nusing `mergeFn a b` to produce the new value.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1080-L1081","name":"Std.RBMap.mergeWith","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.mergeWith","doc":"`O(n₂ * log (n₁ + n₂))`. Merges the maps `t₁` and `t₂`, if a key `a : α` exists in both,\nthen use `mergeFn a b₁ b₂` to produce the new merged value.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1073-L1074","name":"Std.RBMap.find!","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.find!","doc":"Attempts to find the value with key `k : α` in `t` and panics if there is no such key. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1070-L1070","name":"Std.RBMap.max!","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.max!","doc":"`O(log n)`. Returns the maximum element of the map, or panics if the map is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1067-L1067","name":"Std.RBMap.min!","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.min!","doc":"`O(log n)`. Returns the minimum element of the map, or panics if the map is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1064-L1064","name":"Std.RBMap.size","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.size","doc":"`O(n)`. The number of items in the RBMap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1061-L1061","name":"Std.RBMap.instBEqRBMap","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instBEqRBMap","doc":"Returns true if `t₁` and `t₂` have the same keys and values\n(assuming `cmp` and `==` are compatible), ignoring the internal tree structure.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1054-L1055","name":"Std.RBMap.eqKeys","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.eqKeys","doc":"Asserts that `t₁` and `t₂` have the same set of keys (up to equality). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1050-L1051","name":"Std.RBMap.all₂","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.all₂","doc":"Asserts that `t₁` and `t₂` have the same number of elements in the same order,\nand `R` holds pairwise between them. The tree structure is ignored.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1044-L1044","name":"Std.RBMap.any","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.any","doc":"`O(n)`. Returns true if the given predicate is true for any item in the RBMap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1041-L1041","name":"Std.RBMap.all","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.all","doc":"`O(n)`. Returns true if the given predicate is true for all items in the RBMap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1038-L1038","name":"Std.RBMap.contains","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.contains","doc":"`O(log n)`. Returns true if the given key `a` is in the RBMap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1034-L1035","name":"Std.RBMap.lowerBound?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.lowerBound?","doc":"`O(log n)`. `lowerBound? k` retrieves the key-value pair of the largest key\nsmaller than or equal to `k`, if it exists.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1028-L1028","name":"Std.RBMap.findD","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.findD","doc":"`O(log n)`. Find the value corresponding to key `k`, or return `v₀` if it is not in the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1025-L1025","name":"Std.RBMap.find?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.find?","doc":"`O(log n)`. Find the value corresponding to key `k`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1022-L1022","name":"Std.RBMap.findEntry?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.findEntry?","doc":"`O(log n)`. Find an entry in the tree with key equal to `k`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1018-L1019","name":"Std.RBMap.ofArray","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.ofArray","doc":"`O(n log n)`. Build a tree from an unsorted array by inserting them one at a time. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1014-L1015","name":"Std.RBMap.ofList","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.ofList","doc":"`O(n log n)`. Build a tree from an unsorted list by inserting them one at a time. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1011-L1011","name":"Std.RBMap.erase","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.erase","doc":"`O(log n)`. Remove an element `k` from the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1008-L1008","name":"Std.RBMap.insert","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.insert","doc":"`O(log n)`. Insert key-value pair `(k, v)` into the tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1004-L1005","name":"Std.RBMap.instReprRBMap","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instReprRBMap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L1002-L1002","name":"Std.RBMap.max","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.max","doc":"`O(log n)`. Returns the key-value pair `(a, b)` such that `a ≥ k` for all keys in the RBMap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L999-L999","name":"Std.RBMap.min","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.min","doc":"`O(log n)`. Returns the key-value pair `(a, b)` such that `a ≤ k` for all keys in the RBMap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L996-L996","name":"Std.RBMap.toList","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.toList","doc":"`O(n)`. Convert the tree to a list in ascending order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L993-L993","name":"Std.RBMap.isEmpty","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.isEmpty","doc":"`O(1)`. Is the tree empty? "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L990-L990","name":"Std.RBMap.instStreamStream_1","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instStreamStream_1","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L989-L989","name":"Std.RBMap.instToStreamValuesStream","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instToStreamValuesStream","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L984-L987","name":"Std.RBMap.Values.Stream.next?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Values.Stream.next?","doc":"`O(1)` amortized, `O(log n)` worst case: Get the next element from the stream. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L981-L981","name":"Std.RBMap.Values.toStream","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Values.toStream","doc":"A stream over the iterator. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L978-L978","name":"Std.RBMap.Values.Stream","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Values.Stream","doc":"The result of `toStream` on a `Values`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L974-L975","name":"Std.RBMap.instForMValues","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instForMValues","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L971-L972","name":"Std.RBMap.instForInValues","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instForInValues","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L969-L969","name":"Std.RBMap.instCoeHeadValuesList","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instCoeHeadValuesList","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L967-L967","name":"Std.RBMap.instCoeHeadValuesArray","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instCoeHeadValuesArray","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L965-L965","name":"Std.RBMap.Values.toList","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Values.toList","doc":"`O(n)`. Constructs the list of values of the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L963-L963","name":"Std.RBMap.Values.toArray","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Values.toArray","doc":"`O(n)`. Constructs the array of values of the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L961-L961","name":"Std.RBMap.values","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.values","doc":"The \"keys\" of the map. This is an `O(1)` wrapper operation, which\ncan be used in `for` loops or converted to an array or list.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L955-L955","name":"Std.RBMap.Values","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Values","doc":"An \"iterator\" over the values of the map. This is a trivial wrapper over the underlying map,\nbut it comes with a small API to use it in a `for` loop or convert it to an array or list.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L948-L949","name":"Std.RBMap.valuesList","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.valuesList","doc":"`O(n)`. Constructs the list of values of the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L944-L945","name":"Std.RBMap.valuesArray","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.valuesArray","doc":"`O(n)`. Constructs the array of values of the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L941-L941","name":"Std.RBMap.instStreamStream","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instStreamStream","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L940-L940","name":"Std.RBMap.instToStreamKeysStream","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instToStreamKeysStream","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L935-L938","name":"Std.RBMap.Keys.Stream.next?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Keys.Stream.next?","doc":"`O(1)` amortized, `O(log n)` worst case: Get the next element from the stream. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L932-L932","name":"Std.RBMap.Keys.toStream","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Keys.toStream","doc":"A stream over the iterator. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L929-L929","name":"Std.RBMap.Keys.Stream","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Keys.Stream","doc":"The result of `toStream` on a `Keys`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L925-L926","name":"Std.RBMap.instForMKeys","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instForMKeys","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L922-L923","name":"Std.RBMap.instForInKeys","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instForInKeys","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L920-L920","name":"Std.RBMap.instCoeHeadKeysList","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instCoeHeadKeysList","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L918-L918","name":"Std.RBMap.instCoeHeadKeysArray","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instCoeHeadKeysArray","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L916-L916","name":"Std.RBMap.Keys.toList","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Keys.toList","doc":"`O(n)`. Constructs the list of keys of the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L914-L914","name":"Std.RBMap.Keys.toArray","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Keys.toArray","doc":"`O(n)`. Constructs the array of keys of the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L912-L912","name":"Std.RBMap.keys","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.keys","doc":"The keys of the map. This is an `O(1)` wrapper operation, which\ncan be used in `for` loops or converted to an array or list.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L906-L906","name":"Std.RBMap.Keys","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.Keys","doc":"An \"iterator\" over the keys of the map. This is a trivial wrapper over the underlying map,\nbut it comes with a small API to use it in a `for` loop or convert it to an array or list.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L899-L900","name":"Std.RBMap.keysList","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.keysList","doc":"`O(n)`. Constructs the list of keys of the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L895-L896","name":"Std.RBMap.keysArray","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.keysArray","doc":"`O(n)`. Constructs the array of keys of the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L891-L892","name":"Std.RBMap.instToStreamRBMapStreamProd","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instToStreamRBMapStreamProd","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L889-L889","name":"Std.RBMap.instForInRBMapProd","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.instForInRBMapProd","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L886-L887","name":"Std.RBMap.forM","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.forM","doc":"`O(n)`. Run monadic function `f` on each element of the tree (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L882-L883","name":"Std.RBMap.foldlM","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.foldlM","doc":"`O(n)`. Fold a monadic function on the values from left to right (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L878-L879","name":"Std.RBMap.foldr","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.foldr","doc":"`O(n)`. Fold a function on the values from right to left (in decreasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L874-L875","name":"Std.RBMap.foldl","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.foldl","doc":"`O(n)`. Fold a function on the values from left to right (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L868-L868","name":"Std.RBMap.single","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.single","doc":"`O(1)`. Construct a new tree with one key-value pair `k, v`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L865-L865","name":"Std.instInhabitedRBMap","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.instInhabitedRBMap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L862-L863","name":"Std.instEmptyCollectionRBMap","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.instEmptyCollectionRBMap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L859-L860","name":"Std.RBMap.empty","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap.empty","doc":"`O(1)`. Construct a new empty map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L855-L856","name":"Std.mkRBMap","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.mkRBMap","doc":"`O(1)`. Construct a new empty map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L851-L852","name":"Std.RBMap","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBMap","doc":"An `RBMap` is a self-balancing binary search tree, used to store a key-value map.\nThe `cmp` function is the comparator that will be used for performing searches;\nit should satisfy the requirements of `TransCmp` for it to have sensible behavior.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L840-L840","name":"Std.RBSet.sdiff","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.sdiff","doc":"`O(n₁ * (log n₁ + log n₂))`. Constructs the set of all elements of `t₁` that are not in `t₂`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L834-L835","name":"Std.RBSet.filter","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.filter","doc":"`O(n * log n)`. Constructs the set of all elements satisfying `p`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L826-L831","name":"Std.RBSet.intersectWith","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.intersectWith","doc":"`O(n₁ * log (n₁ + n₂))`. Intersects the maps `t₁` and `t₂`\nusing `mergeFn a b` to produce the new value.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L818-L820","name":"Std.RBSet.mergeWith","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.mergeWith","doc":"`O(n₂ * log (n₁ + n₂))`. Merges the maps `t₁` and `t₂`. If equal keys exist in both,\nthen use `mergeFn a₁ a₂` to produce the new merged value.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L811-L812","name":"Std.RBSet.union","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.union","doc":"`O(n₂ * log (n₁ + n₂))`. Merges the maps `t₁` and `t₂`.\nIf equal keys exist in both, the key from `t₂` is preferred.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L804-L805","name":"Std.RBSet.alterP","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.alterP","doc":"`O(log n)`. `alterP cut f t` simultaneously handles inserting, erasing and replacing an element\nusing a function `f : Option α → Option α`. It is passed the result of `t.findP? cut`\nand can either return `none` to remove the element or `some a` to replace/insert\nthe element with `a` (which must have the same ordering properties as the original element).\n\nThe element is used linearly if `t` is unshared.\n\nThe `AlterWF` assumption is required because `f` may change\nthe ordering properties of the element, which would break the invariants.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L791-L791","name":"Std.RBSet.AlterWF.wf","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.AlterWF.wf","doc":"The resulting tree is well formed. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L789-L789","name":"Std.RBSet.AlterWF.mk","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.AlterWF.mk","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L789-L791","name":"Std.RBSet.AlterWF","kind":"class","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.AlterWF","doc":"The predicate asserting that the result of `alterP` is safe to construct. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L785-L786","name":"Std.RBSet.modifyP","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.modifyP","doc":"`O(log n)`. In-place replace an element found by `cut`.\nThis takes the element out of the tree while `f` runs,\nso it uses the element linearly if `t` is unshared.\n\nThe `ModifyWF` assumption is required because `f` may change\nthe ordering properties of the element, which would break the invariants.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L775-L775","name":"Std.RBSet.ModifyWF.wf","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.ModifyWF.wf","doc":"The resulting tree is well formed. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L773-L773","name":"Std.RBSet.ModifyWF.mk","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.ModifyWF.mk","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L773-L775","name":"Std.RBSet.ModifyWF","kind":"class","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.ModifyWF","doc":"The predicate asserting that the result of `modifyP` is safe to construct. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L769-L770","name":"Std.RBSet.find!","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.find!","doc":"`O(log n)`. Attempts to find the value with key `k : α` in `t` and panics if there is no such key.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L763-L764","name":"Std.RBSet.findP!","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.findP!","doc":"`O(log n)`. Attempts to find the value with key `k : α` in `t` and panics if there is no such key.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L758-L758","name":"Std.RBSet.max!","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.max!","doc":"`O(log n)`. Returns the maximum element of the tree, or panics if the tree is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L755-L755","name":"Std.RBSet.min!","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.min!","doc":"`O(log n)`. Returns the minimum element of the tree, or panics if the tree is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L752-L752","name":"Std.RBSet.size","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.size","doc":"`O(n)`. The number of items in the RBSet. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L748-L749","name":"Std.RBSet.instBEqRBSet","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.instBEqRBSet","doc":"Returns true if `t₁` and `t₂` are equal as sets (assuming `cmp` and `==` are compatible),\nignoring the internal tree structure.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L741-L742","name":"Std.RBSet.Slow.instDecidableMem","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.Slow.instDecidableMem","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L738-L739","name":"Std.RBSet.Slow.instDecidableMemP","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.Slow.instDecidableMemP","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L735-L736","name":"Std.RBSet.Slow.instDecidableEMem","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.Slow.instDecidableEMem","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L730-L730","name":"Std.RBSet.instMembershipRBSet","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.instMembershipRBSet","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L728-L728","name":"Std.RBSet.Mem","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.Mem","doc":"True if `x` is equivalent to an element of `t`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L725-L725","name":"Std.RBSet.MemP","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.MemP","doc":"True if the specified `cut` matches at least one element of of `t`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L722-L722","name":"Std.RBSet.EMem","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.EMem","doc":"True if `x` is an element of `t` \"exactly\", i.e. up to equality, not the `cmp` relation. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L718-L719","name":"Std.RBSet.all₂","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.all₂","doc":"Asserts that `t₁` and `t₂` have the same number of elements in the same order,\nand `R` holds pairwise between them. The tree structure is ignored.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L712-L712","name":"Std.RBSet.any","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.any","doc":"`O(n)`. Returns true if the given predicate is true for any item in the RBSet. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L709-L709","name":"Std.RBSet.all","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.all","doc":"`O(n)`. Returns true if the given predicate is true for all items in the RBSet. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L705-L706","name":"Std.RBSet.ofArray","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.ofArray","doc":"`O(n log n)`. Build a tree from an unsorted array by inserting them one at a time. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L701-L702","name":"Std.RBSet.ofList","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.ofList","doc":"`O(n log n)`. Build a tree from an unsorted list by inserting them one at a time. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L698-L698","name":"Std.RBSet.contains","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.contains","doc":"`O(log n)`. Returns true if the given key `a` is in the RBSet. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L695-L695","name":"Std.RBSet.containsP","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.containsP","doc":"`O(log n)`. Returns true if the given cut returns `eq` for something in the RBSet. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L692-L692","name":"Std.RBSet.lowerBound?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.lowerBound?","doc":"`O(log n)`. `lowerBound? k` retrieves the largest entry smaller than or equal to `k`,\nif it exists.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L685-L686","name":"Std.RBSet.lowerBoundP?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.lowerBoundP?","doc":"`O(log n)`. `lowerBoundP cut` retrieves the largest entry comparing `lt` or `eq` under `cut`,\nif it exists.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L679-L679","name":"Std.RBSet.findPD","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.findPD","doc":"`O(log n)`. Find an element in the tree, or return a default value `v₀`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L676-L676","name":"Std.RBSet.find?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.find?","doc":"`O(log n)`. Returns an element in the tree equivalent to `x` if one exists. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L673-L673","name":"Std.RBSet.findP?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.findP?","doc":"`O(log n)`. Find an element in the tree using a cut function. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L669-L670","name":"Std.RBSet.erase","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.erase","doc":"`O(log n)`. Remove an element from the tree using a cut function.\nThe `cut` function is used to locate an element in the tree:\nit returns `.gt` if we go too high and `.lt` if we go too low;\nif it returns `.eq` we will remove the element.\n(The function `cmp k` for some key `k` is a valid cut function, but we can also use cuts that\nare not of this form as long as they are suitably monotonic.)\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L659-L659","name":"Std.RBSet.insert","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.insert","doc":"`O(log n)`. Insert element `v` into the tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L655-L656","name":"Std.RBSet.instReprRBSet","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.instReprRBSet","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L653-L653","name":"Std.RBSet.max","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.max","doc":"`O(log n)`. Returns the entry `a` such that `a ≥ k` for all keys in the RBSet. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L650-L650","name":"Std.RBSet.min","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.min","doc":"`O(log n)`. Returns the entry `a` such that `a ≤ k` for all keys in the RBSet. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L647-L647","name":"Std.RBSet.toList","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.toList","doc":"`O(n)`. Convert the tree to a list in ascending order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L642-L644","name":"Std.RBSet.isEmpty","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.isEmpty","doc":"`O(1)`. Is the tree empty? "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L639-L639","name":"Std.RBSet.instToStreamRBSetStream","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.instToStreamRBSetStream","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L636-L637","name":"Std.RBSet.instForInRBSet","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.instForInRBSet","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L634-L634","name":"Std.RBSet.forM","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.forM","doc":"`O(n)`. Run monadic function `f` on each element of the tree (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L630-L631","name":"Std.RBSet.foldlM","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.foldlM","doc":"`O(n)`. Fold a monadic function on the values from left to right (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L627-L627","name":"Std.RBSet.foldr","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.foldr","doc":"`O(n)`. Fold a function on the values from right to left (in decreasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L624-L624","name":"Std.RBSet.foldl","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.foldl","doc":"`O(n)`. Fold a function on the values from left to right (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L620-L621","name":"Std.RBSet.single","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.single","doc":"`O(1)`. Construct a new tree with one element `v`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L617-L617","name":"Std.RBSet.instInhabitedRBSet","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.instInhabitedRBSet","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L615-L615","name":"Std.RBSet.instEmptyCollectionRBSet","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.instEmptyCollectionRBSet","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L613-L613","name":"Std.RBSet.empty","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet.empty","doc":"`O(1)`. Construct a new empty tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L608-L608","name":"Std.mkRBSet","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.mkRBSet","doc":"`O(1)`. Construct a new empty tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L605-L605","name":"Std.RBSet","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBSet","doc":"An `RBSet` is a self-balancing binary search tree.\nThe `cmp` function is the comparator that will be used for performing searches;\nit should satisfy the requirements of `TransCmp` for it to have sensible behavior.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L592-L594","name":"Std.RBNode.WF.erase","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.WF.erase","doc":"Erasing from a well-formed tree yields another well-formed tree.\n(See `Ordered.erase` and `Balanced.erase` for the actual proofs.) "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L589-L591","name":"Std.RBNode.WF.insert","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.WF.insert","doc":"Inserting into a well-formed tree yields another well-formed tree.\n(See `Ordered.insert` and `Balanced.insert` for the actual proofs.) "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L586-L588","name":"Std.RBNode.WF.mk","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.WF.mk","doc":"The actual well-formedness invariant: a red-black tree has the\nordering and balance invariants. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L585-L594","name":"Std.RBNode.WF","kind":"inductive","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.WF","doc":"The well-formedness invariant for a red-black tree. The first constructor is the real invariant,\nand the others allow us to \"cheat\" in this file and define `insert` and `erase`,\nwhich have more complex proofs that are delayed to `Std.Data.RBMap.Lemmas`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L576-L578","name":"Std.RBNode.Balanced.black","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Balanced.black","doc":"A black node is balanced with black-height `n + 1`\nif its children both have black-height `n`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L573-L575","name":"Std.RBNode.Balanced.red","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Balanced.red","doc":"A red node is balanced with black-height `n`\nif its children are both black with with black-height `n`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L571-L572","name":"Std.RBNode.Balanced.nil","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Balanced.nil","doc":"A nil node is balanced with black-height 0, and it is considered black. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L570-L578","name":"Std.RBNode.Balanced","kind":"inductive","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Balanced","doc":"The red-black balance invariant. `Balanced t c n` says that the color of the root node is `c`,\nand the black-height (the number of black nodes on any path from the root) of the tree is `n`.\nAdditionally, every red node must have black children.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L557-L563","name":"Std.RBNode.Slow.instDecidableOrdered","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Slow.instDecidableOrdered","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L551-L553","name":"Std.RBNode.Ordered","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Ordered","doc":"The ordering invariant of a red-black tree, which is a binary search tree.\nThis says that every element of a left subtree is less than the root, and\nevery element in the right subtree is greater than the root, where the\nless than relation `x < y` is understood to mean `cmp x y = .lt`.\n\nBecause we do not assume that `cmp` is lawful when stating this property,\nwe write it in such a way that if `cmp` is not lawful then the condition holds trivially.\nThat way we can prove the ordering invariants without assuming `cmp` is lawful.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L530-L539","name":"Std.RBNode.alter","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.alter","doc":"`alter cut f t` simultaneously handles inserting, erasing and replacing an element\nusing a function `f : Option α → Option α`. It is passed the result of `t.find? cut`\nand can either return `none` to remove the element or `some a` to replace/insert\nthe element with `a` (which must have the same ordering properties as the original element).\n\nThe element is used linearly if `t` is unshared.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L517-L520","name":"Std.RBNode.modify","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.modify","doc":"`modify cut f t` uses `cut` to find an element,\nthen modifies the element using `f` and reinserts it into the tree.\n\nBecause the tree structure is not modified,\n`f` must not modify the ordering properties of the element.\n\nThe element in `t` is used linearly if `t` is unshared.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L503-L506","name":"Std.RBNode.Path.erase","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Path.erase","doc":"`path.erase t v` removes the root element of `t` from the tree, assuming that `(t, path)` was\nthe result of a previous `zoom` operation.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L492-L497","name":"Std.RBNode.Path.del","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Path.del","doc":"`path.del t c` does the second part of `RBNode.del`, which unwinds the stack\nand rebuilds the tree. The `c` argument is the color of the node before the deletion\n(we used `t₀.isBlack` for this in `RBNode.del` but the original tree is no longer\navailable in this formulation).\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L481-L484","name":"Std.RBNode.Path.insert","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Path.insert","doc":"`path.insert t v` inserts element `v` into the tree, assuming that `(t, path)` was the result of a\nprevious `zoom` operation (so either the root of `t` is equivalent to `v` or it is empty).\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L474-L475","name":"Std.RBNode.Path.insertNew","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Path.insertNew","doc":"`path.insertNew v` inserts element `v` into the tree, assuming that `path` is zoomed in\non a `nil` node such that inserting a new element at this position is valid.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L463-L468","name":"Std.RBNode.Path.ins","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Path.ins","doc":"This function does the second part of `RBNode.ins`,\nwhich unwinds the stack and rebuilds the tree.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L451-L457","name":"Std.RBNode.zoom","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.zoom","doc":"Like `find?`, but instead of just returning the element, it returns the entire subtree\nat the element and a path back to the root for reconstructing the tree.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L442-L445","name":"Std.RBNode.Path.fill","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Path.fill","doc":"Fills the `Path` with a subtree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L438-L439","name":"Std.RBNode.Path.right","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Path.right","doc":"A path that goes down the right subtree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L436-L437","name":"Std.RBNode.Path.left","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Path.left","doc":"A path that goes down the left subtree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L434-L435","name":"Std.RBNode.Path.root","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Path.root","doc":"The root of the tree, which is the end of the path of parents. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L433-L439","name":"Std.RBNode.Path","kind":"inductive","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Path","doc":"A `RBNode.Path α` is a \"cursor\" into an `RBNode` which represents the path\nfrom the root to a subtree. Note that the path goes from the target subtree\nup to the root, which is reversed from the normal way data is stored in the tree.\nSee [Zipper](https://en.wikipedia.org/wiki/Zipper_(data_structure)) for more information.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L425-L425","name":"Std.RBNode.toArray","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.toArray","doc":"Converts the tree into an array in increasing sorted order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L420-L422","name":"Std.RBNode.map","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.map","doc":"`O(n)`. Map a function on every value in the tree.\nThis requires `IsMonotone` on the function in order to preserve the order invariant.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L412-L414","name":"Std.RBNode.root?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.root?","doc":"Returns the root of the tree, if any. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L403-L409","name":"Std.RBNode.lowerBound?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.lowerBound?","doc":"`lowerBound? cut` retrieves the largest entry smaller than or equal to `cut`, if it exists. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L394-L400","name":"Std.RBNode.find?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.find?","doc":"Finds an element in the tree satisfying the `cut` function. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L391-L391","name":"Std.RBNode.erase","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.erase","doc":"The `erase cut t` function removes an element from the tree `t`.\nThe `cut` function is used to locate an element in the tree:\nit returns `.gt` if we go too high and `.lt` if we go too low;\nif it returns `.eq` we will remove the element.\n(The function `cmp k` for some key `k` is a valid cut function, but we can also use cuts that\nare not of this form as long as they are suitably monotonic.)\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L371-L381","name":"Std.RBNode.del","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.del","doc":"The core of the `erase` function. The tree returned from this function has a broken invariant,\nwhich is restored in `erase`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L351-L363","name":"Std.RBNode.append","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.append","doc":"Concatenate two trees with the same black-height. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L346-L348","name":"Std.RBNode.size","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.size","doc":"The number of nodes in the tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L337-L343","name":"Std.RBNode.balRight","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.balRight","doc":"Rebalancing a tree which has shrunk on the right. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L328-L334","name":"Std.RBNode.balLeft","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.balLeft","doc":"Rebalancing a tree which has shrunk on the left. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L323-L325","name":"Std.RBNode.setRed","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.setRed","doc":"Recolor the root of the tree to `red` if possible. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L315-L318","name":"Std.RBNode.insert","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.insert","doc":"`insert cmp t v` inserts element `v` into the tree, using the provided comparator\n`cmp` to put it in the right place and automatically rebalancing the tree as necessary.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L298-L309","name":"Std.RBNode.ins","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.ins","doc":"The core of the `insert` function. This adds an element `x` to a balanced red-black tree.\nImportantly, the result of calling `ins` is not a proper red-black tree,\nbecause it has a broken balance invariant.\n(See `Balanced.ins` for the balance invariant of `ins`.)\nThe `insert` function does the final fixup needed to restore the invariant.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L285-L287","name":"Std.RBNode.setBlack","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.setBlack","doc":"Change the color of the root to `black`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L280-L282","name":"Std.RBNode.isBlack","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.isBlack","doc":"Returns `black` if the node is black, otherwise `red`.\n(Nil nodes are treated as `red`, which is not the usual convention but useful for deletion.)\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L272-L274","name":"Std.RBNode.isRed","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.isRed","doc":"Returns `red` if the node is red, otherwise `black`. (Nil nodes are treated as `black`.) "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L266-L269","name":"Std.RBNode.balance2","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.balance2","doc":"The second half of Okasaki's `balance`, concerning red-red sequences in the right child. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L260-L263","name":"Std.RBNode.balance1","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.balance1","doc":"The first half of Okasaki's `balance`, concerning red-red sequences in the left child. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L250-L257","name":"Std.RBNode.isOrdered","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.isOrdered","doc":"`O(n)`. Verifies an ordering relation on the nodes of the tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L247-L247","name":"Std.RBNode.instDecidableCmpEq","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.instDecidableCmpEq","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L245-L245","name":"Std.RBNode.cmpEq_iff","kind":"theorem","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.cmpEq_iff","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L243-L243","name":"Std.RBNode.cmpEq","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.cmpEq","doc":"We say that `x ≈ y` under the comparator `cmp` if `cmp x y = .eq`. See also `cmpLT`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L240-L240","name":"Std.RBNode.instDecidableCmpLT","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.instDecidableCmpLT","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L238-L238","name":"Std.RBNode.cmpLT_iff","kind":"theorem","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.cmpLT_iff","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L236-L236","name":"Std.RBNode.cmpLT","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.cmpLT","doc":"We say that `x < y` under the comparator `cmp` if `cmp x y = .lt`.\n\n* In order to avoid assuming the comparator is always lawful, we use a\n  local `∀ [TransCmp cmp]` binder in the relation so that the ordering\n  properties of the tree only need to hold if the comparator is lawful.\n* The `Nonempty` wrapper is a no-op because this is already a proposition,\n  but it prevents the `[TransCmp cmp]` binder from being introduced when we don't want it.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L224-L225","name":"Std.RBNode.instBEqRBNode","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.instBEqRBNode","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L218-L222","name":"Std.RBNode.all₂","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.all₂","doc":"Asserts that `t₁` and `t₂` have the same number of elements in the same order,\nand `R` holds pairwise between them. The tree structure is ignored.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L211-L212","name":"Std.RBNode.Slow.instDecidableMem","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Slow.instDecidableMem","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L208-L209","name":"Std.RBNode.Slow.instDecidableMemP","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Slow.instDecidableMemP","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L205-L206","name":"Std.RBNode.Slow.instDecidableEMem","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Slow.instDecidableEMem","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L200-L200","name":"Std.RBNode.Mem","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Mem","doc":"True if `x` is equivalent to an element of `t`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L197-L197","name":"Std.RBNode.MemP","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.MemP","doc":"True if the specified `cut` matches at least one element of of `t`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L194-L194","name":"Std.RBNode.instMembershipRBNode","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.instMembershipRBNode","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L192-L192","name":"Std.RBNode.EMem","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.EMem","doc":"True if `x` is an element of `t` \"exactly\", i.e. up to equality, not the `cmp` relation. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L188-L189","name":"Std.RBNode.instDecidableAny","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.instDecidableAny","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L185-L186","name":"Std.RBNode.any_iff","kind":"theorem","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.any_iff","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L181-L183","name":"Std.RBNode.Any","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Any","doc":"Asserts that `p` holds on some element of the tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L177-L178","name":"Std.RBNode.instDecidableAll","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.instDecidableAll","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L174-L175","name":"Std.RBNode.all_iff","kind":"theorem","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.all_iff","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L170-L172","name":"Std.RBNode.All.imp","kind":"theorem","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.All.imp","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L166-L168","name":"Std.RBNode.All","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.All","doc":"Asserts that `p` holds on every element of the tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L161-L163","name":"Std.RBNode.any","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.any","doc":"Returns `true` iff any element of the tree satisfies `p`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L156-L158","name":"Std.RBNode.all","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.all","doc":"Returns `true` iff every element of the tree satisfies `p`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L153-L153","name":"Std.RBNode.instStreamStream","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.instStreamStream","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L152-L152","name":"Std.RBNode.instToStreamRBNodeStream","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.instToStreamRBNodeStream","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L148-L148","name":"Std.RBNode.Stream.toList","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Stream.toList","doc":"`O(n)`. Convert the stream to a list in ascending order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L143-L145","name":"Std.RBNode.Stream.foldr","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Stream.foldr","doc":"Fold a function on the values from right to left (in decreasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L138-L140","name":"Std.RBNode.Stream.foldl","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Stream.foldl","doc":"Fold a function on the values from left to right (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L133-L135","name":"Std.RBNode.Stream.next?","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Stream.next?","doc":"`O(1)` amortized, `O(log n)` worst case: Get the next element from the stream. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L126-L128","name":"Std.RBNode.toStream","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.toStream","doc":"`O(log n)`. Turn a node into a stream, by descending along the left spine. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L121-L123","name":"Std.RBNode.Stream.cons","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Stream.cons","doc":"We are ready to deliver element `v` with right child `r`,\nand where `tail` represents all the subtrees we have yet to destructure. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L119-L120","name":"Std.RBNode.Stream.nil","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Stream.nil","doc":"The stream is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L118-L123","name":"Std.RBNode.Stream","kind":"inductive","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.Stream","doc":"An auxiliary data structure (an iterator) over an `RBNode` which lazily\npulls elements from the left.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L111-L112","name":"Std.RBNode.instForInRBNode","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.instForInRBNode","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L107-L109","name":"Std.RBNode.forIn.visit","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.forIn.visit","doc":"Inner loop of `forIn`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L102-L109","name":"Std.RBNode.forIn","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.forIn","doc":"Implementation of `for x in t` loops over a `RBNode` (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L97-L99","name":"Std.RBNode.foldlM","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.foldlM","doc":"Fold a monadic function on the values from left to right (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L92-L94","name":"Std.RBNode.forM","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.forM","doc":"Run monadic function `f` on each element of the tree (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L89-L89","name":"Std.RBNode.toList","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.toList","doc":"`O(n)`. Convert the tree to a list in ascending order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L84-L86","name":"Std.RBNode.foldr","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.foldr","doc":"Fold a function on the values from right to left (in decreasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L79-L81","name":"Std.RBNode.foldl","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.foldl","doc":"Fold a function on the values from left to right (in increasing order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L74-L76","name":"Std.RBNode.fold","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.fold","doc":"Fold a function in tree order along the nodes. `v₀` is used at `nil` nodes and\n`f` is used to combine results at branching nodes.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L65-L68","name":"Std.RBNode.max","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.max","doc":"The maximum element of a tree is the right-most value. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L59-L62","name":"Std.RBNode.min","kind":"def","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.min","doc":"The minimum element of a tree is the left-most value. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L56-L56","name":"Std.RBNode.instEmptyCollectionRBNode","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.instEmptyCollectionRBNode","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L51-L51","name":"Std.instReprRBNode","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.instReprRBNode","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L47-L50","name":"Std.RBNode.node","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.node","doc":"A node consists of a value `v`, a subtree `l` of smaller items,\nand a subtree `r` of larger items. The color `c` is either `red` or `black`\nand participates in the red-black balance invariant (see `Balanced`). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L45-L46","name":"Std.RBNode.nil","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode.nil","doc":"An empty tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L44-L51","name":"Std.RBNode","kind":"inductive","docLink":"./Std/Data/RBMap/Basic.html#Std.RBNode","doc":"A red-black tree. (This is an internal implementation detail of the `RBSet` type,\nwhich includes the invariants of the tree.) This is a binary search tree augmented with\na \"color\" field which is either red or black for each node and used to implement\nthe re-balancing operations.\nSee: [Red–black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L35-L35","name":"Std.instReprRBColor","kind":"instance","docLink":"./Std/Data/RBMap/Basic.html#Std.instReprRBColor","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L33-L34","name":"Std.RBColor.black","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBColor.black","doc":"Every path from the root to a leaf must pass through the same number of black nodes. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L31-L32","name":"Std.RBColor.red","kind":"ctor","docLink":"./Std/Data/RBMap/Basic.html#Std.RBColor.red","doc":"A red node is required to have black children. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/RBMap/Basic.lean#L30-L35","name":"Std.RBColor","kind":"inductive","docLink":"./Std/Data/RBMap/Basic.html#Std.RBColor","doc":"In a red-black tree, every node has a color which is either \"red\" or \"black\"\n(this particular choice of colors is conventional). A nil node is considered black.\n"}]}