{"name":"Std.Util.TermUnsafe","instances":[],"imports":["Init","Lean.Elab.ElabRules","Lean.Meta.Closure","Lean.Compiler.ImplementedByAttr"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Util/TermUnsafe.lean#L30-L61","name":"Std.TermUnsafe.termUnsafe_","kind":"def","docLink":"./Std/Util/TermUnsafe.html#Std.TermUnsafe.termUnsafe_","doc":"`unsafe t : α` is an expression constructor which allows using unsafe declarations inside the\nbody of `t : α`, by creating an auxiliary definition containing `t` and using `implementedBy` to\nwrap it in a safe interface. It is required that `α` is nonempty for this to be sound,\nbut even beyond that, an `unsafe` block should be carefully inspected for memory safety because\nthe compiler is unable to guarantee the safety of the operation.\n\nFor example, the `evalExpr` function is unsafe, because the compiler cannot guarantee that when\nyou call ```evalExpr Foo ``Foo e``` that the type `Foo` corresponds to the name `Foo`, but in a\nparticular use case, we can ensure this, so `unsafe (evalExpr Foo ``Foo e)` is a correct usage.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Util/TermUnsafe.lean#L25-L28","name":"Std.TermUnsafe.mkAuxName","kind":"def","docLink":"./Std/Util/TermUnsafe.html#Std.TermUnsafe.mkAuxName","doc":"Construct an auxiliary name based on the current declaration name and the given `hint` base. "}]}