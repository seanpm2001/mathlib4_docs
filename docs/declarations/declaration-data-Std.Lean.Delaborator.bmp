{"name":"Std.Lean.Delaborator","instances":[],"imports":["Init","Lean.PrettyPrinter"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Lean/Delaborator.lean#L44-L55","name":"Lean.ppConst","kind":"def","docLink":"./Std/Lean/Delaborator.html#Lean.ppConst","doc":"Pretty print a const expression using `delabConst` and generate terminfo.\nThis function avoids inserting `@` if the constant is for a function whose first\nargument is implicit, which is what the default `toMessageData` for `Expr` does.\nPanics if `e` is not a constant. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Lean/Delaborator.lean#L30-L36","name":"Lean.PrettyPrinter.Delaborator.withOverApp.loop","kind":"def","docLink":"./Std/Lean/Delaborator.html#Lean.PrettyPrinter.Delaborator.withOverApp.loop","doc":"Inner loop of `withOverApp`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Lean/Delaborator.lean#L24-L38","name":"Lean.PrettyPrinter.Delaborator.withOverApp","kind":"def","docLink":"./Std/Lean/Delaborator.html#Lean.PrettyPrinter.Delaborator.withOverApp","doc":"This is similar to `withAppFnArgs` but it handles construction of an \"over-application\".\nFor example, suppose we want to implement a delaborator for applications of `f : Foo A → A`\nlike `f x` as `F[x]`, but because `A` is a type variable we might encounter a term of the form\n`@f (A → B) x y` which has an additional argument `y`.\n\nMost of the built in delaborators will deliberately fail on such an example, resulting in\ndelaborated syntax `f x y`, but this combinator can be used if we want to display `F[x] y`\ninstead.\n\n* `arity`: the expected number of arguments to `f`.\n  The combinator will fail if fewer than this number of arguments are passed\n* `x`: constructs data corresponding to the main application (`f x` in the example)\n"}]}