{"name":"Std.Tactic.PrintDependents","instances":[],"imports":["Init","Lean.Elab.Command","Lean.Util.FoldConsts","Std.Lean.Delaborator"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/PrintDependents.lean#L64-L118","name":"Std.Tactic.«command#printDependents___»","kind":"def","docLink":"./Std/Tactic/PrintDependents.html#Std.Tactic.«command#printDependents___»","doc":"The command `#print dependents X Y` prints a list of all the declarations in the file that\ntransitively depend on `X` or `Y`. After each declaration, it shows the list of all declarations\nreferred to directly in the body which also depend on `X` or `Y`.\n\nFor example, `#print axioms bar'` below shows that `bar'` depends on `Classical.choice`, but not\nwhy. `#print dependents Classical.choice` says that `bar'` depends on `Classical.choice` because\nit uses `foo` and `foo` uses `Classical.em`. `bar` is not listed because it is proved without using\n`Classical.choice`.\n```\nimport Std.Tactic.PrintDependents\n\ntheorem foo : x = y ∨ x ≠ y := Classical.em _\ntheorem bar : 1 = 1 ∨ 1 ≠ 1 := by simp\ntheorem bar' : 1 = 1 ∨ 1 ≠ 1 := foo\n\n#print axioms bar'\n-- 'bar'' depends on axioms: [Classical.choice, Quot.sound, propext]\n\n#print dependents Classical.choice\n-- foo: Classical.em\n-- bar': foo\n```\n\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/PrintDependents.lean#L43-L60","name":"Std.Tactic.CollectDependents.collect","kind":"opaque","docLink":"./Std/Tactic/PrintDependents.html#Std.Tactic.CollectDependents.collect","doc":"Collect the results for a given constant. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/PrintDependents.lean#L39-L40","name":"Std.Tactic.CollectDependents.mkState","kind":"def","docLink":"./Std/Tactic/PrintDependents.html#Std.Tactic.CollectDependents.mkState","doc":"Constructs the initial state, marking the constants in `cs`. The result of `collect` will say\nwhether a given declaration depends transitively on one of these constants.\n\nIf `otherAxiom` is true, any axiom not specified in `cs` will also be tracked.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/PrintDependents.lean#L31-L31","name":"Std.Tactic.CollectDependents.M","kind":"def","docLink":"./Std/Tactic/PrintDependents.html#Std.Tactic.CollectDependents.M","doc":"The monad used by `CollectDependents`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/PrintDependents.lean#L28-L28","name":"Std.Tactic.CollectDependents.State.result","kind":"def","docLink":"./Std/Tactic/PrintDependents.html#Std.Tactic.CollectDependents.State.result","doc":"The cached results on visited constants. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/PrintDependents.lean#L26-L26","name":"Std.Tactic.CollectDependents.State.otherAxiom","kind":"def","docLink":"./Std/Tactic/PrintDependents.html#Std.Tactic.CollectDependents.State.otherAxiom","doc":"If true, an axiom not in the initial list will be considered as marked. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/PrintDependents.lean#L24-L28","name":"Std.Tactic.CollectDependents.State","kind":"structure","docLink":"./Std/Tactic/PrintDependents.html#Std.Tactic.CollectDependents.State","doc":"Collects the result of a `CollectDependents` query. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/PrintDependents.lean#L1-L1","name":"Std.Tactic.CollectDependents.State.mk","kind":"ctor","docLink":"./Std/Tactic/PrintDependents.html#Std.Tactic.CollectDependents.State.mk","doc":""}]}