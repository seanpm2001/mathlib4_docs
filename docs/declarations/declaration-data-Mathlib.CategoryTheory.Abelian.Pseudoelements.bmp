{"name":"Mathlib.CategoryTheory.Abelian.Pseudoelements","instances":[{"typeNames":["CategoryTheory.Abelian.Pseudoelement"],"name":"CategoryTheory.Abelian.Pseudoelement.hasZero","className":"Zero"},{"typeNames":["CategoryTheory.Abelian.Pseudoelement"],"name":"CategoryTheory.Abelian.Pseudoelement.instInhabitedPseudoelement","className":"Inhabited"}],"imports":["Init","Mathlib.CategoryTheory.Abelian.Exact","Mathlib.CategoryTheory.Over","Mathlib.Algebra.Category.ModuleCat.EpiMono"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L482-L495","name":"CategoryTheory.Abelian.Pseudoelement.ModuleCat.eq_range_of_pseudoequal","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.ModuleCat.eq_range_of_pseudoequal","doc":"In the category `Module R`, if `x` and `y` are pseudoequal, then the range of the associated\nmorphisms is the same. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L466-L475","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_pullback","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_pullback","doc":"If `f : P ⟶ R` and `g : Q ⟶ R` are morphisms and `p : P` and `q : Q` are pseudoelements such\nthat `f p = g q`, then there is some `s : pullback f g` such that `fst s = p` and `snd s = q`.\n\nRemark: Borceux claims that `s` is unique, but this is false. See\n`counterexamples/pseudoelement` for details. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L438-L456","name":"CategoryTheory.Abelian.Pseudoelement.sub_of_eq_image","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.sub_of_eq_image","doc":"If two pseudoelements `x` and `y` have the same image under some morphism `f`, then we can form\ntheir \"difference\" `z`. This pseudoelement has the properties that `f z = 0` and for all\nmorphisms `g`, if `g y = 0` then `g z = g x`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L401-L430","name":"CategoryTheory.Abelian.Pseudoelement.exact_of_pseudo_exact","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.exact_of_pseudo_exact","doc":"If two morphisms are exact on pseudoelements, they are exact. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L394-L395","name":"CategoryTheory.Abelian.Pseudoelement.apply_eq_zero_of_comp_eq_zero","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.apply_eq_zero_of_comp_eq_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L361-L389","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_exact_of_exact","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_exact_of_exact","doc":"Two morphisms in an exact sequence are exact on pseudoelements. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L344-L355","name":"CategoryTheory.Abelian.Pseudoelement.epi_of_pseudo_surjective","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.epi_of_pseudo_surjective","doc":"A morphism that is surjective on pseudoelements is an epimorphism. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L332-L338","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_surjective_of_epi","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_surjective_of_epi","doc":"An epimorphism is surjective on pseudoelements. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L323-L326","name":"CategoryTheory.Abelian.Pseudoelement.mono_of_zero_of_map_zero","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.mono_of_zero_of_map_zero","doc":"A morphism that only maps the zero pseudoelement to zero is a monomorphism. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L316-L319","name":"CategoryTheory.Abelian.Pseudoelement.zero_of_map_zero","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_of_map_zero","doc":"A morphism that is injective on pseudoelements only maps the zero element to zero. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L304-L312","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono","doc":"A monomorphism is injective on pseudoelements. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L299-L300","name":"CategoryTheory.Abelian.Pseudoelement.eq_zero_iff","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.eq_zero_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L289-L290","name":"CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext'","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L284-L286","name":"CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext","doc":"An extensionality lemma for being the zero arrow. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L277-L280","name":"CategoryTheory.Abelian.Pseudoelement.zero_apply","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_apply","doc":"The zero morphism maps every pseudoelement to 0. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L270-L272","name":"CategoryTheory.Abelian.Pseudoelement.apply_zero","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.apply_zero","doc":"Morphisms map the zero pseudoelement to the zero pseudoelement. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L259-L261","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_iff","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_iff","doc":"The pseudoelement induced by an arrow is zero precisely when that arrow is zero. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L254-L255","name":"CategoryTheory.Abelian.Pseudoelement.zero_eq_zero","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_eq_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L250-L250","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_def","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_def","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L247-L248","name":"CategoryTheory.Abelian.Pseudoelement.instInhabitedPseudoelement","kind":"instance","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.instInhabitedPseudoelement","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L243-L244","name":"CategoryTheory.Abelian.Pseudoelement.hasZero","kind":"instance","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.hasZero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L235-L236","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero","kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero","doc":"The zero pseudoelement is the class of a zero morphism. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L229-L231","name":"CategoryTheory.Abelian.Pseudoelement.zero_eq_zero'","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_eq_zero'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L221-L224","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_aux","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_aux","doc":"The arrows pseudo-equal to a zero morphism are precisely the zero morphisms. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L203-L204","name":"CategoryTheory.Abelian.Pseudoelement.comp_comp","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.comp_comp","doc":"Composition of functions on pseudoelements is composition of morphisms. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L195-L199","name":"CategoryTheory.Abelian.Pseudoelement.comp_apply","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.comp_apply","doc":"Applying a pseudoelement to a composition of morphisms is the same as composing\nwith each morphism. Sadly, this is not a definitional equality, but at least it is\ntrue. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L189-L189","name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply_mk'","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply_mk'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L181-L182","name":"CategoryTheory.Abelian.Pseudoelement.homToFun","kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.homToFun","doc":"A coercion from morphisms to functions on pseudoelements. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L176-L177","name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply","kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply","doc":"A morphism `f` induces a function `pseudoApply f` on pseudoelements. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L170-L172","name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply_aux","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply_aux","doc":"If two elements are pseudo-equal, then their composition with a morphism is, too. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L166-L166","name":"CategoryTheory.Abelian.Pseudoelement.over_coe_def","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.over_coe_def","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L160-L161","name":"CategoryTheory.Abelian.Pseudoelement.overToSort","kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.overToSort","doc":"A coercion from an arrow with codomain `P` to its associated pseudoelement. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L151-L152","name":"CategoryTheory.Abelian.Pseudoelement.objectToSort","kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.objectToSort","doc":"A coercion from an object of an abelian category to its pseudoelements. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L144-L145","name":"CategoryTheory.Abelian.Pseudoelement","kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement","doc":"A `Pseudoelement` of `P` is just an equivalence class of arrows ending in `P` by being\npseudo-equal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L136-L137","name":"CategoryTheory.Abelian.Pseudoelement.setoid","kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.setoid","doc":"The arrows with codomain `P` equipped with the equivalence relation of being pseudo-equal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L126-L130","name":"CategoryTheory.Abelian.pseudoEqual_trans","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_trans","doc":"Pseudoequality is transitive: Just take the pullback. The pullback morphisms will\nbe epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L116-L117","name":"CategoryTheory.Abelian.pseudoEqual_symm","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L112-L113","name":"CategoryTheory.Abelian.pseudoEqual_refl","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_refl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L108-L109","name":"CategoryTheory.Abelian.PseudoEqual","kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual","doc":"Two arrows `f : X ⟶ P` and `g : Y ⟶ P` are called pseudo-equal if there is some object\n`R` and epimorphisms `p : R ⟶ X` and `q : R ⟶ Y` such that `p ≫ f = q ≫ g`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L103-L103","name":"CategoryTheory.Abelian.app_hom","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app_hom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L98-L99","name":"CategoryTheory.Abelian.app","kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app","doc":"This is just composition of morphisms in `C`. Another way to express this would be\n`(Over.map f).obj a`, but our definition has nicer definitional properties. "}]}