{"name":"Mathlib.Data.Fin.Fin2","instances":[{"typeNames":["OfNat.ofNat","Nat","instOfNatNat","Nat.succ"],"name":"Fin2.IsLT.zero","className":"Fin2.IsLT"},{"typeNames":["Nat.succ","Nat.succ"],"name":"Fin2.IsLT.succ","className":"Fin2.IsLT"},{"typeNames":["Fin2","OfNat.ofNat","Nat","instOfNatNat"],"name":"Fin2.instInhabitedFin2OfNatNatInstOfNatNat","className":"Inhabited"}],"imports":["Init","Std.Tactic.NoMatch","Mathlib.Init.Data.Nat.Notation","Mathlib.Mathport.Rename"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L134-L135","name":"Fin2.instInhabitedFin2OfNatNatInstOfNatNat","kind":"instance","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.instInhabitedFin2OfNatNatInstOfNatNat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L126-L129","name":"Fin2.ofNat'","kind":"def","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.ofNat'","doc":"Use type class inference to infer the boundedness proof, so that we can directly convert a\n`Nat` into a `Fin2 n`. This supports notation like `&1 : Fin 3`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L121-L122","name":"Fin2.IsLT.succ","kind":"instance","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.IsLT.succ","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L118-L119","name":"Fin2.IsLT.zero","kind":"instance","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.IsLT.zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L115-L115","name":"Fin2.IsLT.h","kind":"def","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.IsLT.h","doc":"The unique field of `Fin2.IsLT`, a proof that `m < n`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L113-L113","name":"Fin2.IsLT.mk","kind":"ctor","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.IsLT.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L113-L115","name":"Fin2.IsLT","kind":"class","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.IsLT","doc":"This is a simple type class inference prover for proof obligations\nof the form `m < n` where `m n : ℕ`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L105-L108","name":"Fin2.remapLeft","kind":"def","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.remapLeft","doc":"`remapLeft f k : Fin2 (m + k) → Fin2 (n + k)` applies the function\n`f : Fin2 m → Fin2 n` to inputs less than `m`, and leaves the right part\non the right (that is, `remapLeft f k (m + i) = n + i`). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L92-L99","name":"Fin2.insertPerm","kind":"def","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.insertPerm","doc":"`insertPerm a` is a permutation of `Fin2 n` with the following properties:\n* `insertPerm a i = i+1` if `i < a`\n* `insertPerm a a = 0`\n* `insertPerm a i = i` if `i > a` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L83-L85","name":"Fin2.left","kind":"def","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.left","doc":"`left k` is the embedding `Fin2 n → Fin2 (k + n)` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L77-L79","name":"Fin2.add","kind":"def","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.add","doc":"`i + k : Fin2 (n + k)` when `i : Fin2 n` and `k : ℕ` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L70-L73","name":"Fin2.optOfNat","kind":"def","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.optOfNat","doc":"Converts a natural into a `Fin2` if it is in range "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L64-L66","name":"Fin2.toNat","kind":"def","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.toNat","doc":"Converts a `Fin2` into a natural. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L60-L60","name":"Fin2.elim0","kind":"def","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.elim0","doc":"Ex falso. The dependent eliminator for the empty `Fin2 0` type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L53-L56","name":"Fin2.cases'","kind":"def","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.cases'","doc":"Define a dependent function on `Fin2 (succ n)` by giving its value at\nzero (`H1`) and by giving a dependent function on the rest (`H2`). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L44-L45","name":"Fin2.fs","kind":"ctor","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.fs","doc":"`n` as a member of `Fin (succ n)` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L42-L43","name":"Fin2.fz","kind":"ctor","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2.fz","doc":"`0` as a member of `Fin (succ n)` (`Fin 0` is empty) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Fin/Fin2.lean#L41-L45","name":"Fin2","kind":"inductive","docLink":"./Mathlib/Data/Fin/Fin2.html#Fin2","doc":"An alternate definition of `Fin n` defined as an inductive type instead of a subtype of `ℕ`. "}]}