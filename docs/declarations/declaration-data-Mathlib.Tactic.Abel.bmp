{"name":"Mathlib.Tactic.Abel","instances":[{"typeNames":["Mathlib.Tactic.Abel.NormalExpr"],"name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.Abel.NormalExpr","Lean.Expr"],"name":"Mathlib.Tactic.Abel.instCoeNormalExprExpr","className":"Coe"}],"imports":["Init","Mathlib.Tactic.NormNum","Mathlib.Util.AtomM","Mathlib.Data.Int.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L556-L557","name":"Mathlib.Tactic.Abel.convAbel!","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!","doc":"The tactic `abel` evaluates expressions in abelian groups.\nThis is the conv tactic version, which rewrites a target which is an abel equality to `True`.\n\nSee also the `abel` tactic.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L554-L555","name":"Mathlib.Tactic.Abel.abelConv","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv","doc":"The tactic `abel` evaluates expressions in abelian groups.\nThis is the conv tactic version, which rewrites a target which is an abel equality to `True`.\n\nSee also the `abel` tactic.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L545-L546","name":"Mathlib.Tactic.Abel.tacticAbel!","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!","doc":"Tactic for evaluating expressions in abelian groups.\n\n* `abel!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `abel1` fails if the target is not an equality.\n\nFor example:\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L543-L544","name":"Mathlib.Tactic.Abel.abel","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel","doc":"Tactic for evaluating expressions in abelian groups.\n\n* `abel!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `abel1` fails if the target is not an equality.\n\nFor example:\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L529-L529","name":"Mathlib.Tactic.Abel.convAbel_nf!_","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L522-L527","name":"Mathlib.Tactic.Abel.elabAbelNFConv","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv","doc":"Elaborator for the `abel_nf` tactic. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L519-L519","name":"Mathlib.Tactic.Abel.abelNFConv","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L516-L517","name":"Mathlib.Tactic.Abel.tacticAbel_nf!__","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L498-L514","name":"Mathlib.Tactic.Abel.abelNF","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L495-L496","name":"Mathlib.Tactic.Abel.abel!_term","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel!_term","doc":"Unsupported legacy syntax from mathlib3, which allowed passing additional terms to `abel!`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L493-L494","name":"Mathlib.Tactic.Abel.abel_term","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel_term","doc":"Unsupported legacy syntax from mathlib3, which allowed passing additional terms to `abel`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L484-L491","name":"Mathlib.Tactic.Abel.abelNFLocalDecl","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFLocalDecl","doc":"Use `abel_nf` to rewrite hypothesis `h`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L473-L481","name":"Mathlib.Tactic.Abel.abelNFTarget","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFTarget","doc":"Use `abel_nf` to rewrite the main goal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L468-L468","name":"Mathlib.Tactic.Abel.abelNFCore.evalAtom","kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.evalAtom","doc":"The `evalAtom` implementation passed to `eval` calls `go` if `cfg.recursive` is true,\nand does nothing otherwise. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L452-L465","name":"Mathlib.Tactic.Abel.abelNFCore.go","kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go","doc":"The recursive case of `abelNF`.\n* `root`: true when the function is called directly from `abelNFCore`\n  and false when called by `evalAtom` in recursive mode.\n* `parent`: The input expression to simplify. In `pre` we make use of both `parent` and `e`\n  to determine if we are at the top level in order to prevent a loop\n  `go -> eval -> evalAtom -> go` which makes no progress.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L432-L469","name":"Mathlib.Tactic.Abel.abelNFCore","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore","doc":"The core of `abel_nf`, which rewrites the expression `e` into `abel` normal form.\n\n* `s`: a reference to the mutable state of `abel`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `e`: the expression to rewrite\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L421-L422","name":"Mathlib.Tactic.Abel.elabAbelNFConfig","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig","doc":"Function elaborating `AbelNF.Config`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L419-L419","name":"Mathlib.Tactic.Abel.AbelNF.Config.mode","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mode","doc":"The normalization style. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L417-L417","name":"Mathlib.Tactic.Abel.AbelNF.Config.recursive","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive","doc":"if true, atoms inside ring expressions will be reduced recursively "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L415-L415","name":"Mathlib.Tactic.Abel.AbelNF.Config.red","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red","doc":"the reducibility setting to use when comparing atoms for defeq "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L413-L419","name":"Mathlib.Tactic.Abel.AbelNF.Config","kind":"structure","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config","doc":"Configuration for `abel_nf`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L409-L410","name":"Mathlib.Tactic.Abel.AbelMode.raw","kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.raw","doc":"Raw form: the representation `abel` uses internally. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L407-L408","name":"Mathlib.Tactic.Abel.AbelMode.term","kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.term","doc":"The default form "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L406-L410","name":"Mathlib.Tactic.Abel.AbelMode","kind":"inductive","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode","doc":"The normalization style for `abel_nf`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L401-L403","name":"Mathlib.Tactic.Abel.NormalExpr.isAtom","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom","doc":"True if this represents an atomic expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L398-L398","name":"Mathlib.Tactic.Abel.termg_eq","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L396-L396","name":"Mathlib.Tactic.Abel.term_eq","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L394-L394","name":"Mathlib.Tactic.Abel.abel1!","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!","doc":"Tactic for solving equations in the language of\n*additive*, commutative monoids and groups.\nThis version of `abel` fails if the target is not an equality\nthat is provable by the axioms of commutative monoids/groups.\n\n`abel1!` will use a more aggressive reducibility setting to identify atoms.\nThis can prove goals that `abel` cannot, but is more expensive.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L364-L372","name":"Mathlib.Tactic.Abel.abel1","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1","doc":"Tactic for solving equations in the language of\n*additive*, commutative monoids and groups.\nThis version of `abel` fails if the target is not an equality\nthat is provable by the axioms of commutative monoids/groups.\n\n`abel1!` will use a more aggressive reducibility setting to identify atoms.\nThis can prove goals that `abel` cannot, but is more expensive.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L319-L362","name":"Mathlib.Tactic.Abel.eval","kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval","doc":"Evaluate an expression into its `abel` normal form, by recursing into subexpressions. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L297-L316","name":"Mathlib.Tactic.Abel.evalSMul'","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'","doc":"Normalize a term `orig` of the form `smul e₁ e₂` or `smulg e₁ e₂`.\nNormalized terms use `smul` for monoids and `smulg` for groups,\nso there are actually four cases to handle:\n* Using `smul` in a monoid just simplifies the pieces using `subst_into_smul`\n* Using `smulg` in a group just simplifies the pieces using `subst_into_smulg`\n* Using `smul a b` in a group requires converting `a` from a nat to an int and\n  then simplifying `smulg ↑a b` using `subst_into_smul_upcast`\n* Using `smulg` in a monoid is impossible (or at least out of scope),\n  because you need a group argument to write a `smulg` term "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L284-L286","name":"Mathlib.Tactic.Abel.subst_into_negg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L280-L282","name":"Mathlib.Tactic.Abel.subst_into_addg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L276-L278","name":"Mathlib.Tactic.Abel.subst_into_add","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L271-L274","name":"Mathlib.Tactic.Abel.subst_into_smul_upcast","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L267-L269","name":"Mathlib.Tactic.Abel.subst_into_smulg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L263-L265","name":"Mathlib.Tactic.Abel.subst_into_smul","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L260-L261","name":"Mathlib.Tactic.Abel.unfold_zsmul","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L257-L258","name":"Mathlib.Tactic.Abel.unfold_smulg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L254-L255","name":"Mathlib.Tactic.Abel.unfold_smul","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L251-L252","name":"Mathlib.Tactic.Abel.unfold_sub","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L243-L249","name":"Mathlib.Tactic.Abel.evalAtom","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom","doc":"Interpret an expression as an atom for `abel`'s normal form. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L239-L240","name":"Mathlib.Tactic.Abel.term_atom_pfg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L237-L238","name":"Mathlib.Tactic.Abel.term_atom_pf","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L236-L236","name":"Mathlib.Tactic.Abel.term_atomg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L235-L235","name":"Mathlib.Tactic.Abel.term_atom","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L227-L233","name":"Mathlib.Tactic.Abel.evalSMul","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul","doc":"Auxiliary function for `evalSMul'`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L219-L222","name":"Mathlib.Tactic.Abel.term_smulg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L214-L217","name":"Mathlib.Tactic.Abel.term_smul","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L211-L212","name":"Mathlib.Tactic.Abel.zero_smulg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L208-L209","name":"Mathlib.Tactic.Abel.zero_smul","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L206-L206","name":"Mathlib.Tactic.Abel.smulg","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg","doc":"A synonym for `•`, used internally in `abel`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L204-L204","name":"Mathlib.Tactic.Abel.smul","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul","doc":"A synonym for `•`, used internally in `abel`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L193-L201","name":"Mathlib.Tactic.Abel.evalNeg","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg","doc":"Interpret a negated expression in `abel`'s normal form.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L186-L188","name":"Mathlib.Tactic.Abel.term_neg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L161-L184","name":"Mathlib.Tactic.Abel.evalAdd","kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd","doc":"Interpret the sum of two expressions in `abel`'s normal form.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L155-L156","name":"Mathlib.Tactic.Abel.zero_termg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L152-L153","name":"Mathlib.Tactic.Abel.zero_term","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L146-L150","name":"Mathlib.Tactic.Abel.term_add_termg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L142-L144","name":"Mathlib.Tactic.Abel.term_add_term","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L138-L140","name":"Mathlib.Tactic.Abel.term_add_constg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L134-L136","name":"Mathlib.Tactic.Abel.term_add_const","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L130-L132","name":"Mathlib.Tactic.Abel.const_add_termg","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L126-L128","name":"Mathlib.Tactic.Abel.const_add_term","kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L122-L122","name":"Mathlib.Tactic.Abel.NormalExpr.zero'","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'","doc":"Construct the normal form representing zero. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L118-L119","name":"Mathlib.Tactic.Abel.NormalExpr.term'","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'","doc":"Construct the normal form representing a single term. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L115-L115","name":"Mathlib.Tactic.Abel.instCoeNormalExprExpr","kind":"instance","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L111-L113","name":"Mathlib.Tactic.Abel.NormalExpr.e","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e","doc":"Extract the expression from a normal form. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L108-L108","name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr","kind":"instance","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L107-L107","name":"Mathlib.Tactic.Abel.NormalExpr.nterm","kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L106-L106","name":"Mathlib.Tactic.Abel.NormalExpr.zero","kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L105-L108","name":"Mathlib.Tactic.Abel.NormalExpr","kind":"inductive","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr","doc":"A normal form for `abel`.\nExpressions are represented as a list of terms of the form `e = n • x`,\nwhere `n : ℤ` and `x` is an arbitrary element of the additive commutative monoid or group.\nWe explicitly track the `Expr` forms of `e` and `n`, even though they could be reconstructed,\nfor efficiency. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L97-L98","name":"Mathlib.Tactic.Abel.intToExpr","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr","doc":"Interpret an integer as a coefficient to a term. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L94-L94","name":"Mathlib.Tactic.Abel.mkTerm","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm","doc":"Evaluate a term with coefficient `n`, atom `x` and successor terms `a`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L91-L91","name":"Mathlib.Tactic.Abel.termg","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L89-L89","name":"Mathlib.Tactic.Abel.term","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative monoid. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L84-L86","name":"Mathlib.Tactic.Abel.iapp","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp","doc":"Apply the function `n : ∀ {α} [AddComm{Monoid,Group} α]` to the given list of arguments.\n\nWill use the `AddComm{Monoid,Group}` instance that has been cached in the context.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L76-L78","name":"Mathlib.Tactic.Abel.addG","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG","doc":"Add the letter \"g\" to the end of the name, e.g. turning `term` into `termg`.\n\nThis is used to choose between declarations taking `AddCommMonoid` and those\ntaking `AddCommGroup` instances.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L68-L69","name":"Mathlib.Tactic.Abel.Context.mkApp","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp","doc":"Apply the function `n : ∀ {α} [inst α], _` to the implicit parameters in the\ncontext, and the given list of arguments.\n\nCompared to `context.app`, this takes the name of the typeclass, rather than an\ninferred typeclass instance.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L59-L60","name":"Mathlib.Tactic.Abel.Context.app","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app","doc":"Apply the function `n : ∀ {α} [inst : AddWhatever α], _` to the\nimplicit parameters in the context, and the given list of arguments. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L55-L55","name":"Mathlib.Tactic.Abel.M","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M","doc":"The monad for `Abel` contains, in addition to the `AtomM` state,\nsome information about the current type we are working over, so that we can consistently\nuse group lemmas or monoid lemmas as appropriate. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L41-L50","name":"Mathlib.Tactic.Abel.mkContext","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext","doc":"Populate a `context` object for evaluating `e`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L38-L38","name":"Mathlib.Tactic.Abel.Context.inst","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.inst","doc":"The `AddCommGroup α` or `AddCommMonoid α` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L36-L36","name":"Mathlib.Tactic.Abel.Context.isGroup","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup","doc":"Specify whether we are in an additive commutative group or an additive commutative monoid. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L34-L34","name":"Mathlib.Tactic.Abel.Context.α0","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α0","doc":"The expression representing `0 : α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L32-L32","name":"Mathlib.Tactic.Abel.Context.univ","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ","doc":"The universe level for `α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L30-L30","name":"Mathlib.Tactic.Abel.Context.α","kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α","doc":"The type of the ambient additive commutative group or monoid. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L28-L38","name":"Mathlib.Tactic.Abel.Context","kind":"structure","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context","doc":"The `Context` for a call to `abel`.\n\nStores a few options for this call, and caches some common subexpressions\nsuch as typeclass instances and `0 : α`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L1-L1","name":"Mathlib.Tactic.Abel.AbelNF.Config.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Abel.lean#L1-L1","name":"Mathlib.Tactic.Abel.Context.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mk","doc":""}]}