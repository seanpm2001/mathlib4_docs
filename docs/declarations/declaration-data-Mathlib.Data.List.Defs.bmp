{"name":"Mathlib.Data.List.Defs","instances":[{"typeNames":["List"],"name":"List.instSDiffList","className":"SDiff"},{"typeNames":["List","List","List","Prod"],"name":"List.instSProd","className":"SProd"},{"typeNames":["List.Chain"],"name":"List.decidableChain","className":"Decidable"},{"typeNames":["List.Chain'"],"name":"List.decidableChain'","className":"Decidable"}],"imports":["Init","Mathlib.Algebra.Group.Defs","Mathlib.Control.Functor","Mathlib.Data.Nat.Basic","Mathlib.Logic.Basic","Mathlib.Data.SProd","Mathlib.Util.CompileInductive","Std.Tactic.Lint.Basic","Std.Data.RBMap.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L582-L586","name":"List.replaceIf","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.replaceIf","doc":"Given a starting list `old`, a list of booleans and a replacement list `new`,\nread the items in `old` in succession and either replace them with the next element of `new` or\nnot, according as to whether the corresponding boolean is `true` or `false`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L574-L576","name":"List.zipWith5","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.zipWith5","doc":"Quinary version of `list.zipWith`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L568-L570","name":"List.zipWith4","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.zipWith4","doc":"Quaternary version of `list.zipWith`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L562-L564","name":"List.zipWith3","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.zipWith3","doc":"Ternary version of `List.zipWith`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L547-L548","name":"List.mapAsyncChunked","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.mapAsyncChunked","doc":"Asynchronous version of `List.map`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L528-L529","name":"List.map₂Right","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.map₂Right","doc":"Right-biased version of `List.map₂`. `map₂Right f as bs` applies `f` to each\npair `aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `as` is shorter than `bs`, `f` is applied to\n`none` for the remaining `bᵢ`.\n\n```\nmap₂Right Prod.mk [1, 2] ['a'] = [(some 1, 'a')]\n\nmap₂Right Prod.mk [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]\n\nmap₂Right f as bs = (map₂Right' f as bs).fst\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L510-L513","name":"List.map₂Left","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.map₂Left","doc":"Left-biased version of `List.map₂`. `map₂Left f as bs` applies `f` to each pair\n`aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `bs` is shorter than `as`, `f` is applied to `none`\nfor the remaining `aᵢ`.\n\n```\nmap₂Left Prod.mk [1, 2] ['a'] = [(1, some 'a'), (2, none)]\n\nmap₂Left Prod.mk [1] ['a', 'b'] = [(1, some 'a')]\n\nmap₂Left f as bs = (map₂Left' f as bs).fst\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L492-L493","name":"List.map₂Right'","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.map₂Right'","doc":"Right-biased version of `List.map₂`. `map₂Right' f as bs` applies `f` to each\npair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, `f` is\napplied to `none` for the remaining `bᵢ`. Returns the results of the `f`\napplications and the remaining `as`.\n\n```\nmap₂Right' prod.mk [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])\n\nmap₂Right' prod.mk [1, 2] ['a'] = ([(some 1, 'a')], [2])\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L473-L478","name":"List.map₂Left'","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.map₂Left'","doc":"Left-biased version of `List.map₂`. `map₂Left' f as bs` applies `f` to each\npair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, `f` is\napplied to `none` for the remaining `aᵢ`. Returns the results of the `f`\napplications and the remaining `bs`.\n\n```\nmap₂Left' prod.mk [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])\n\nmap₂Left' prod.mk [1] ['a', 'b'] = ([(1, some 'a')], ['b'])\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L452-L455","name":"List.traverse","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.traverse","doc":"Map each element of a `List` to an action, evaluate these actions in order,\nand collect the results.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L438-L446","name":"List.mapDiagM'","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.mapDiagM'","doc":"`mapDiagM' f l` calls `f` on all elements in the upper triangular part of `l × l`.\nThat is, for each `e ∈ l`, it will run `f e e` and then `f e e'`\nfor each `e'` that appears after `e` in `l`.\n\nExample: suppose `l = [1, 2, 3]`. `mapDiagM' f l` will evaluate, in this order,\n`f 1 1`, `f 1 2`, `f 1 3`, `f 2 2`, `f 2 3`, `f 3 3`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L422-L423","name":"List.choose","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.choose","doc":"Given a decidable predicate `p` and a proof of existence of `a ∈ l` such that `p a`,\nchoose the first element with this property. This version returns `a : α`, and properties\nare given by `choose_mem` and `choose_property`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L408-L416","name":"List.chooseX","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.chooseX","doc":"Given a decidable predicate `p` and a proof of existence of `a ∈ l` such that `p a`,\nchoose the first element with this property. This version returns both `a` and proofs\nof `a ∈ l` and `p a`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L386-L388","name":"List.destutter","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.destutter","doc":"Greedily create a sublist of `l` such that, for every two adjacent elements `a, b ∈ l`,\n`R a b` holds. Mostly used with ≠; for example, `destutter (≠) [1, 2, 2, 1, 1] = [1, 2, 1]`,\n`destutter (≠) [1, 2, 3, 3] = [1, 2, 3]`, `destutter (<) [1, 2, 5, 2, 3, 4, 9] = [1, 2, 5, 9]`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L377-L379","name":"List.destutter'","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.destutter'","doc":"Greedily create a sublist of `a :: l` such that, for every two adjacent elements `a, b`,\n`R a b` holds. Mostly used with ≠; for example, `destutter' (≠) 1 [2, 2, 1, 1] = [1, 2, 1]`,\n`destutter' (≠) 1, [2, 3, 3] = [1, 2, 3]`, `destutter' (<) 1 [2, 5, 2, 3, 4, 9] = [1, 2, 5, 9]`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L370-L371","name":"List.dedup","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.dedup","doc":"`dedup l` removes duplicates from `l` (taking only the last occurrence).\nDefined as `pwFilter (≠)`.\n\n   dedup [1, 0, 2, 2, 1] = [0, 2, 1] "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L357-L358","name":"List.decidableChain'","kind":"instance","docLink":"./Mathlib/Data/List/Defs.html#List.decidableChain'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L350-L354","name":"List.decidableChain","kind":"instance","docLink":"./Mathlib/Data/List/Defs.html#List.decidableChain","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L333-L334","name":"List.instSProd","kind":"instance","docLink":"./Mathlib/Data/List/Defs.html#List.instSProd","doc":"Notation for calculating the product of a `List`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L318-L324","name":"List.extractp","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.extractp","doc":"`extractp p l` returns a pair of an element `a` of `l` satisfying the predicate\n`p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L307-L309","name":"List.permutations'","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.permutations'","doc":"List of all permutations of `l`. This version of `permutations` is less efficient but has\nsimpler definitional equations. The permutations are in a different order,\nbut are equal up to permutation, as shown by `list.permutations_perm_permutations'`.\n\n     permutations [1, 2, 3] =\n       [[1, 2, 3], [2, 1, 3], [2, 3, 1],\n        [1, 3, 2], [3, 1, 2], [3, 2, 1]] "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L294-L296","name":"List.permutations'Aux","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.permutations'Aux","doc":"`permutations'Aux t ts` inserts `t` into every position in `ts`, including the last.\nThis function is intended for use in specifications, so it is simpler than `permutationsAux2`,\nwhich plays roughly the same role in `permutations`.\n\nNote that `(permutationsAux2 t [] [] ts id).2` is similar to this function, but skips the last\nposition:\n\n    permutations'Aux 10 [1, 2, 3] =\n      [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3], [1, 2, 3, 10]]\n    (permutationsAux2 10 [] [] [1, 2, 3] id).2 =\n      [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3]] "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L278-L279","name":"List.permutations","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.permutations","doc":"List of all permutations of `l`.\n\npermutations [1, 2, 3] =\n[[1, 2, 3], [2, 1, 3], [3, 2, 1],\n [2, 3, 1], [3, 1, 2], [1, 3, 2]] "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L268-L270","name":"List.permutationsAux","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.permutationsAux","doc":"An auxiliary function for defining `permutations`. `permutationsAux ts is` is the set of all\npermutations of `is ++ ts` that do not fix `ts`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L257-L263","name":"List.permutationsAux.rec","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.permutationsAux.rec","doc":"A recursor for pairs of lists. To have `C l₁ l₂` for all `l₁`, `l₂`, it suffices to have it for\n`l₂ = []` and to be able to pour the elements of `l₁` into `l₂`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L246-L250","name":"List.permutationsAux2","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.permutationsAux2","doc":"An auxiliary function for defining `permutations`. `permutationsAux2 t ts r ys f` is equal to\n`(ys ++ ts, (insert_left ys t ts).map f ++ r)`, where `insert_left ys t ts` (not explicitly\ndefined) is the list of lists of the form `insert_nth n t (ys ++ ts)` for `0 ≤ n < length ys`.\n\n    permutations_aux2 10 [4, 5, 6] [] [1, 2, 3] id =\n      ([1, 2, 3, 4, 5, 6],\n       [[10, 1, 2, 3, 4, 5, 6],\n        [1, 10, 2, 3, 4, 5, 6],\n        [1, 2, 10, 3, 4, 5, 6]]) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L226-L229","name":"List.All₂","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.All₂","doc":"`l.all₂ p` is equivalent to `∀ a ∈ l, p a`, but unfolds directly to a conjunction, i.e.\n`List.All₂ p [0, 1, 2] = p 0 ∧ p 1 ∧ p 2`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L205-L206","name":"List.mapIdxM'","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.mapIdxM'","doc":"A variant of `mapIdxM` specialised to applicative actions which\nreturn `Unit`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L198-L200","name":"List.mapIdxMAux'","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.mapIdxMAux'","doc":"Auxiliary definition for `mapIdxM'`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L174-L179","name":"List.foldrIdxM","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.foldrIdxM","doc":"Monadic variant of `foldrIdx`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L165-L170","name":"List.foldlIdxM","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.foldlIdxM","doc":"Monadic variant of `foldlIdx`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L148-L149","name":"List.andM","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.andM","doc":"`andM xs` runs the actions in `xs`, returning true if all of them return\ntrue. `andM` short-circuits, so if an action returns false, later actions are\nnot run. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L141-L142","name":"List.orM","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.orM","doc":"`orM xs` runs the actions in `xs`, returning true if any of them returns\ntrue. `orM` short-circuits, so if an action returns true, later actions are\nnot run. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L120-L127","name":"List.findM?'","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.findM?'","doc":"`findM? p l` returns the first element `a` of `l` for which `p a` returns\ntrue. `findM?` short-circuits, so `p` is not necessarily run on every `a` in\n`l`. This is a monadic version of `List.find`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L113-L114","name":"List.findM","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.findM","doc":"`findM tac l` returns the first element of `l` on which `tac` succeeds, and\nfails otherwise. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L102-L105","name":"List.alternatingProd","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.alternatingProd","doc":"The alternating product of a list. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L95-L98","name":"List.alternatingSum","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.alternatingSum","doc":"The alternating sum of a list. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L90-L91","name":"List.sum","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.sum","doc":"Sum of a list.\n\n`List.sum [a, b, c] = ((0 + a) + b) + c` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L81-L82","name":"List.prod","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.prod","doc":"Product of a list.\n\n`List.prod [a, b, c] = ((1 * a) * b) * c` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L65-L66","name":"List.takeI","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.takeI","doc":"\"Inhabited\" `take` function: Take `n` elements from a list `l`. If `l` has less than `n`\nelements, append `n - length l` elements `default`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L59-L60","name":"List.getI","kind":"def","docLink":"./Mathlib/Data/List/Defs.html#List.getI","doc":"\"Inhabited\" `get` function: returns `default` instead of `none` in the case\nthat the index is out of bounds. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/List/Defs.lean#L41-L42","name":"List.instSDiffList","kind":"instance","docLink":"./Mathlib/Data/List/Defs.html#List.instSDiffList","doc":""}]}