{"name":"Mathlib.Data.Ordmap.Ordnode","instances":[{"typeNames":["Ordnode"],"name":"Ordnode.instEmptyCollectionOrdnode","className":"EmptyCollection"},{"typeNames":["Ordnode"],"name":"Ordnode.instInhabitedOrdnode","className":"Inhabited"},{"typeNames":["Ordnode"],"name":"Ordnode.instSingletonOrdnode","className":"Singleton"},{"typeNames":["Ordnode"],"name":"Ordnode.instReprOrdnode","className":"Repr"},{"typeNames":["Ordnode.All"],"name":"Ordnode.All.decidable","className":"Decidable"},{"typeNames":["Ordnode.Any"],"name":"Ordnode.Any.decidable","className":"Decidable"},{"typeNames":["Ordnode.Emem"],"name":"Ordnode.Emem.decidable","className":"Decidable"},{"typeNames":["Ordnode.Amem"],"name":"Ordnode.Amem.decidable","className":"Decidable"},{"typeNames":["Ordnode"],"name":"Ordnode.instToStringOrdnode","className":"ToString"},{"typeNames":["Ordnode"],"name":"Ordnode.instToFormatOrdnode","className":"Std.ToFormat"},{"typeNames":["Ordnode.Equiv"],"name":"Ordnode.instDecidableRelOrdnodeEquiv","className":"Decidable"},{"typeNames":["Ordnode"],"name":"Ordnode.instMembershipOrdnode","className":"Membership"},{"typeNames":["Membership.mem","Ordnode","Ordnode.instMembershipOrdnode"],"name":"Ordnode.mem.decidable","className":"Decidable"},{"typeNames":["Ordnode"],"name":"Ordnode.instInsertOrdnode","className":"Insert"}],"imports":["Init","Mathlib.Order.Compare","Mathlib.Data.List.Defs","Mathlib.Data.Nat.PSub","Mathlib.Init.Data.Nat.Bitwise"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1356-L1357","name":"Ordnode.image","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image","doc":"O(n * log n). Map a function on a set. Unlike `map` this has no requirements on\n`f`, and the resulting set may be smaller than the input if `f` is noninjective.\nEquivalent elements are selected with a preference for smaller source elements.\n\n    image (fun x ↦ x + 2) {1, 2, 4} = {3, 4, 6}\n    image (λ x : ℕ, x - 2) {1, 2, 4} = {0, 2} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1345-L1347","name":"Ordnode.ofList'","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'","doc":"O(n * log n). Adaptively chooses between the linear and log-linear algorithm depending\non whether the input list is already sorted.\n\n  ofList' [1, 2, 3] = {1, 2, 3}\n  ofList' [2, 1, 1, 3] = {1, 2, 3} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1336-L1337","name":"Ordnode.ofList","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList","doc":"O(n * log n). Build a set from a list, preferring elements that appear earlier in the list\nin the case of equivalent elements.\n\n    ofList [1, 2, 3] = {1, 2, 3}\n    ofList [2, 1, 1, 3] = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    ofList [(1, 1), (0, 1), (1, 2)] = {(0, 1), (1, 1)} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1317-L1324","name":"Ordnode.inter","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter","doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. Intersection of two sets, preferring members of\n`t₁` over those of `t₂` when equivalent elements are encountered.\n\n    inter {1, 2} {2, 3} = {2}\n    inter {1, 3} {2} = ∅ "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1302-L1309","name":"Ordnode.diff","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff","doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. Difference of two sets.\n\ndiff {1, 2} {2, 3} = {1}\ndiff {1, 2, 3} {2} = {1, 3} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1286-L1295","name":"Ordnode.union","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union","doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. The union of two sets, preferring members of\n`t₁` over those of `t₂` when equivalent elements are encountered.\n\n  union {1, 2} {2, 3} = {1, 2, 3}\n  union {1, 3} {2} = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n  union {(1, 1)} {(0, 1), (1, 2)} = {(0, 1), (1, 1)} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1269-L1274","name":"Ordnode.disjoint","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint","doc":"O(m + n). Is every element of `t₁` not equivalent to any element of `t₂`?\n\ndisjoint {1, 3} {2, 4} = tt\ndisjoint {1, 2} {2, 4} = ff "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1261-L1262","name":"Ordnode.isSubset","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset","doc":"O(m + n). Is every element of `t₁` equivalent to some element of `t₂`?\n\nis_subset {1, 4} {1, 2, 4} = tt\nis_subset {1, 3} {1, 2, 4} = ff "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1249-L1254","name":"Ordnode.isSubsetAux","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux","doc":"Auxiliary definition for `isSubset`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1244-L1245","name":"Ordnode.findIndex","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex","doc":"O(log n). Get the index, counting from the left,\nof an element equivalent to `x` if it exists.\n\n    findIndex 2 {1, 2, 4} = some 1\n    findIndex 4 {1, 2, 4} = some 2\n    findIndex 5 {1, 2, 4} = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1229-L1235","name":"Ordnode.findIndexAux","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux","doc":"Auxiliary definition for `findIndex`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1219-L1225","name":"Ordnode.findGe","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe","doc":"O(log n). Get the smallest element in the tree that is `≥ x`.\n\nfindGe 2 {1, 2, 4} = some 2\nfindGe 3 {1, 2, 4} = some 4\nfindGe 5 {1, 2, 4} = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1204-L1210","name":"Ordnode.findGeAux","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux","doc":"Auxiliary definition for `findGe`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1194-L1200","name":"Ordnode.findLe","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe","doc":"O(log n). Get the largest element in the tree that is `≤ x`.\n\nfindLe 2 {1, 2, 4} = some 2\nfindLe 3 {1, 2, 4} = some 2\nfindLe 0 {1, 2, 4} = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1180-L1186","name":"Ordnode.findLeAux","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux","doc":"Auxiliary definition for `findLe`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1174-L1176","name":"Ordnode.findGt","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt","doc":"O(log n). Get the smallest element in the tree that is `> x`.\n\nfindGt 2 {1, 2, 4} = some 4\nfindGt 3 {1, 2, 4} = some 4\nfindGt 4 {1, 2, 4} = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1164-L1166","name":"Ordnode.findGtAux","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux","doc":"Auxiliary definition for `findGt`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1158-L1160","name":"Ordnode.findLt","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt","doc":"O(log n). Get the largest element in the tree that is `< x`.\n\nfindLt 2 {1, 2, 4} = some 1\nfindLt 3 {1, 2, 4} = some 2\nfindLt 0 {1, 2, 4} = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1148-L1150","name":"Ordnode.findLtAux","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux","doc":"Auxiliary definition for `findLt`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1138-L1144","name":"Ordnode.erase","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase","doc":"O(log n). Remove an element from the set equivalent to `x`. Does nothing if there\nis no such element.\n\n    erase 1 {1, 2, 3} = {2, 3}\n    erase 4 {1, 2, 3} = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    erase (1, 1) {(0, 1), (1, 2)} = {(0, 1)}\n    erase (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1115-L1125","name":"Ordnode.split3","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3","doc":"O(log n). Split the tree into those smaller than `x` and those greater than it,\nplus an element equivalent to `x`, if it exists.\n\n    split3 2 {1, 2, 4} = ({1}, some 2, {4})\n    split3 3 {1, 2, 4} = ({1, 2}, none, {4})\n    split3 4 {1, 2, 4} = ({1, 2}, some 4, ∅)\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    split3 (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, some (1, 2), ∅)\n    split3 (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, none, ∅) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1091-L1101","name":"Ordnode.split","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split","doc":"O(log n). Split the tree into those smaller than `x` and those greater than it.\nIf an element equivalent to `x` is in the set, it is discarded.\n\n    split 2 {1, 2, 4} = ({1}, {4})\n    split 3 {1, 2, 4} = ({1, 2}, {4})\n    split 4 {1, 2, 4} = ({1, 2}, ∅)\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    split (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, ∅)\n    split (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, ∅) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1071-L1077","name":"Ordnode.insert'","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'","doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, the set is returned as is.\n\n    insert' 1 {1, 2, 3} = {1, 2, 3}\n    insert' 4 {1, 2, 3} = {1, 2, 3, 4}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insert' (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)}\n    insert' (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1058-L1059","name":"Ordnode.instInsertOrdnode","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsertOrdnode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1049-L1055","name":"Ordnode.insert","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert","doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, this replaces it.\n\n    insert 1 {1, 2, 3} = {1, 2, 3}\n    insert 4 {1, 2, 3} = {1, 2, 3, 4}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insert (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 1)}\n    insert (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1027-L1036","name":"Ordnode.alter","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter","doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    alter f 0 {1, 2, 3} = {1, 2, 3}     if f none = none\n                        = {a, 1, 2, 3}  if f none = some a\n    alter f 1 {1, 2, 3} = {2, 3}     if f 1 = none\n                        = {a, 2, 3}  if f 1 = some a "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L1007-L1016","name":"Ordnode.updateWith","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith","doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    updateWith f 0 {1, 2, 3} = {1, 2, 3}\n    updateWith f 1 {1, 2, 3} = {2, 3}     if f 1 = none\n                              = {a, 2, 3}  if f 1 = some a "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L991-L997","name":"Ordnode.adjustWith","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith","doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    adjustWith f 0 {1, 2, 3} = {1, 2, 3}\n    adjustWith f 1 {1, 2, 3} = {f 1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    adjustWith f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}\n    adjustWith f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L971-L977","name":"Ordnode.insertWith","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith","doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, the function `f` is used to generate\nthe element to insert (being passed the current value in the set).\n\n    insertWith f 0 {1, 2, 3} = {0, 1, 2, 3}\n    insertWith f 1 {1, 2, 3} = {f 1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insertWith f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}\n    insertWith f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L956-L957","name":"Ordnode.mem.decidable","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L953-L954","name":"Ordnode.instMembershipOrdnode","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembershipOrdnode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L944-L950","name":"Ordnode.find","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find","doc":"O(log n). Retrieve an element in the set that is equivalent to `x` in the order,\nif it exists.\n\n    find 1 {1, 2, 3} = some 1\n    find 4 {1, 2, 3} = none\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    find (1, 1) {(0, 1), (1, 2)} = some (1, 2)\n    find (3, 1) {(0, 1), (1, 2)} = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L925-L931","name":"Ordnode.mem","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem","doc":"O(log n). Does the set (approximately) contain the element `x`? That is,\nis there an element that is equivalent to `x` in the order?\n\n    1 ∈ {1, 2, 3} = true\n    4 ∈ {1, 2, 3} = false\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    (1, 1) ∈ {(0, 1), (1, 2)} = true\n    (3, 1) ∈ {(0, 1), (1, 2)} = false "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L906-L908","name":"Ordnode.ofAscList","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList","doc":"O(n). Build a set from a list which is already sorted. Performs no comparisons.\n\nofAscList [1, 2, 3] = {1, 2, 3}\nofAscList [3, 2, 1] = precondition violation "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L892-L899","name":"Ordnode.ofAscListAux₂","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂","doc":"Auxiliary definition for `ofAscList`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L877-L888","name":"Ordnode.ofAscListAux₁","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁","doc":"Auxiliary definition for `ofAscList`.\n\n**Note:** This function is defined by well founded recursion, so it will probably not compute\nin the kernel, meaning that you probably can't prove things like\n`ofAscList [1, 2, 3] = {1, 2, 3}` by `rfl`.\nThis implementation is optimized for VM evaluation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L860-L868","name":"Ordnode.span","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span","doc":"O(log n). Split the set into those satisfying and not satisfying the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    span (fun x ↦ x < 4) {1, 2, 3, 4, 5} = ({1, 2, 3}, {4, 5})\n    span (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L850-L852","name":"Ordnode.dropWhile","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile","doc":"O(log n). Remove an initial segment of the set that satisfies the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    dropWhile (fun x ↦ x < 4) {1, 2, 3, 4, 5} = {4, 5}\n    dropWhile (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L840-L842","name":"Ordnode.takeWhile","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile","doc":"O(log n). Get an initial segment of the set that satisfies the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    takeWhile (fun x ↦ x < 4) {1, 2, 3, 4, 5} = {1, 2, 3}\n    takeWhile (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L831-L832","name":"Ordnode.splitAt","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt","doc":"O(log n). Split a set at the `i`th element, getting the first `i` and everything else.\n\nsplitAt 2 {a, b, c, d} = ({a, b}, {c, d})\nsplitAt 5 {a, b, c, d} = ({a, b, c, d}, ∅) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L812-L824","name":"Ordnode.splitAtAux","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux","doc":"Auxiliary definition for `splitAt`. (Can also be used in lieu of `splitAt` if you know the\nindex is within the range of the data structure.)\n\n    splitAtAux {a, b, c, d} 2 = ({a, b}, {c, d})\n    splitAtAux {a, b, c, d} 5 = ({a, b, c, d}, ∅) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L803-L804","name":"Ordnode.drop","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop","doc":"O(log n). Remove the first `i` elements of the set, counted from the left.\n\ndrop 2 {a, b, c, d} = {c, d}\ndrop 5 {a, b, c, d} = ∅ "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L788-L796","name":"Ordnode.dropAux","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux","doc":"Auxiliary definition for `drop`. (Can also be used in lieu of `drop` if you know the\nindex is within the range of the data structure.)\n\n    drop_aux {a, b, c, d} 2 = {c, d}\n    drop_aux {a, b, c, d} 5 = ∅ "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L779-L780","name":"Ordnode.take","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take","doc":"O(log n). Get the first `i` elements of the set, counted from the left.\n\ntake 2 {a, b, c, d} = {a, b}\ntake 5 {a, b, c, d} = {a, b, c, d} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L764-L772","name":"Ordnode.takeAux","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux","doc":"Auxiliary definition for `take`. (Can also be used in lieu of `take` if you know the\nindex is within the range of the data structure.)\n\n    takeAux {a, b, c, d} 2 = {a, b}\n    takeAux {a, b, c, d} 5 = {a, b, c, d} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L750-L756","name":"Ordnode.removeNth","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth","doc":"O(log n). Remove the `i`th element of the set, by its index from left to right.\n\nremove_nth {a, b, c, d} 2 = {a, b, d}\nremove_nth {a, b, c, d} 5 = {a, b, c, d} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L737-L743","name":"Ordnode.nth","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth","doc":"O(log n). Get the `i`th element of the set, by its index from left to right.\n\nnth {a, b, c, d} 2 = some c\nnth {a, b, c, d} 5 = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L729-L730","name":"Ordnode.attach'","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'","doc":"O(n). \"Attach\" the information that every element of `t` satisfies property\nP to these elements inside the set, producing a set in the subtype.\n\n    attach' (fun x ↦ x < 4) {1, 2} H = ({1, 2} : Ordnode {x // x<4}) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L720-L722","name":"Ordnode.pmap","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap","doc":"O(n). Map a partial function across a set. The result depends on a proof\nthat the function is defined on all members of the set.\n\n    pmap (fin.mk : ∀ n, n < 4 → fin 4) {1, 2} H = {(1 : fin 4), (2 : fin 4)} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L704-L705","name":"Ordnode.copair","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair","doc":"O(m + n). Build a set on the disjoint union by combining sets on the factors.\n`Or.inl a ∈ s.copair t` iff `a ∈ s`, and `Or.inr b ∈ s.copair t` iff `b ∈ t`.\n\n    copair {1, 2} {2, 3} = {inl 1, inl 2, inr 2, inr 3} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L696-L697","name":"Ordnode.prod","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod","doc":"O(m * n). The cartesian product of two sets: `(a, b) ∈ s.prod t` iff `a ∈ s` and `b ∈ t`.\n\nprod {1, 2} {2, 3} = {(1, 2), (1, 3), (2, 2), (2, 3)} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L689-L690","name":"Ordnode.powerset","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.powerset","doc":"O(2^n). Constructs the powerset of a given set, that is, the set of all subsets.\n\npowerset {1, 2, 3} = {∅, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L684-L684","name":"Ordnode.instDecidableRelOrdnodeEquiv","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelOrdnodeEquiv","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L680-L681","name":"Ordnode.Equiv","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv","doc":"O(n). True if the trees have the same elements, ignoring structural differences.\n\nEquiv {1, 2, 4} {2, 1, 1, 4} = true\nEquiv {1, 2, 4} {1, 2, 3} = false "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L673-L674","name":"Ordnode.instToFormatOrdnode","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormatOrdnode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L669-L670","name":"Ordnode.instToStringOrdnode","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToStringOrdnode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L665-L666","name":"Ordnode.toRevList","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList","doc":"O(n). Build a list of elements in descending order from the tree.\n\ntoRevList {1, 2, 4} = [4, 2, 1]\ntoRevList {2, 1, 1, 4} = [4, 2, 1] "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L657-L658","name":"Ordnode.toList","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList","doc":"O(n). Build a list of elements in ascending order from the tree.\n\ntoList {1, 2, 4} = [1, 2, 4]\ntoList {2, 1, 1, 4} = [1, 2, 4] "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L648-L650","name":"Ordnode.foldr","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr","doc":"O(n). Fold a function from right to left (in decreasing order) across the tree.\n\nfoldr f {1, 2, 4} z = f 1 (f 2 (f 4 z)) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L634-L636","name":"Ordnode.foldl","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl","doc":"O(n). Fold a function from left to right (in increasing order) across the tree.\n\nfoldl f z {1, 2, 4} = f (f (f z 1) 2) 4 "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L620-L622","name":"Ordnode.fold","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold","doc":"O(n). Fold a function across the structure of a tree.\n\n     fold z f {1, 2, 4} = f (f z 1 z) 2 (f z 4 z)\n\nThe exact structure of function applications depends on the tree and so\nis unspecified. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L603-L605","name":"Ordnode.map","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map","doc":"O(n). Map a function across a tree, without changing the structure. Only valid when\nthe function is strictly monotone, i.e. `x < y → f x < f y`.\n\n     partition (fun x ↦ x + 2) {1, 2, 4} = {2, 3, 6}\n     partition (λ x : ℕ, x - 2) {1, 2, 4} = precondition violation "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L584-L589","name":"Ordnode.partition","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition","doc":"O(n). Split the elements of a tree into those satisfying, and not satisfying, a predicate.\n\npartition (fun x ↦ x < 3) {1, 2, 4} = ({1, 2}, {3}) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L574-L578","name":"Ordnode.filter","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter","doc":"O(n). Filter the elements of a tree satisfying a predicate.\n\nfilter (fun x ↦ x < 3) {1, 2, 4} = {1, 2}\nfilter (fun x ↦ x > 5) {1, 2, 4} = ∅ "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L551-L567","name":"Ordnode.link","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link","doc":"O(log(m+n)). Build a tree from an element between two trees, without any\nassumption on the relative sizes.\n\n    link {1, 2} 4 {5, 6} = {1, 2, 4, 5, 6}\n    link {1, 3} 2 {5} = precondition violation "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L541-L543","name":"Ordnode.insertMin","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin","doc":"O(log n). Insert an element below all the others, without any comparisons.\n(Assumes that the element is in fact below all the others).\n\n    insertMin {1, 2} 0 = {0, 1, 2}\n    insertMin {1, 2} 4 = precondition violation "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L531-L533","name":"Ordnode.insertMax","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax","doc":"O(log n). Insert an element above all the others, without any comparisons.\n(Assumes that the element is in fact above all the others).\n\n    insertMax {1, 2} 4 = {1, 2, 4}\n    insertMax {1, 2} 0 = precondition violation "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L515-L523","name":"Ordnode.merge","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge","doc":"O(log(m + n)). Concatenate two trees that are ordered with respect to each other.\n\nmerge {1, 2} {3, 4} = {1, 2, 3, 4}\nmerge {3, 4} {1, 2} = precondition violation "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L499-L508","name":"Ordnode.glue","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue","doc":"**Internal use only**\n\nO(log(m + n)). Concatenate two trees that are balanced and ordered with respect to each other. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L491-L493","name":"Ordnode.splitMax","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax","doc":"O(log n). Extract and remove the maximum element from the tree, if it exists.\n\nsplit_max {1, 2, 3} = some ({1, 2}, 3)\nsplit_max ∅ = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L480-L484","name":"Ordnode.splitMax'","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'","doc":"**Internal use only**, because it requires a balancing constraint on the inputs.\n\nO(log n). Extract and remove the maximum element from a nonempty tree. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L472-L474","name":"Ordnode.splitMin","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin","doc":"O(log n). Extract and remove the minimum element from the tree, if it exists.\n\nsplit_min {1, 2, 3} = some (1, {2, 3})\nsplit_min ∅ = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L461-L465","name":"Ordnode.splitMin'","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'","doc":"**Internal use only**, because it requires a balancing constraint on the inputs.\n\nO(log n). Extract and remove the minimum element from a nonempty tree. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L452-L455","name":"Ordnode.eraseMax","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax","doc":"O(log n). Remove the maximum element from the tree, or do nothing if it is already empty.\n\neraseMax {1, 2, 3} = {1, 2}\neraseMax ∅ = ∅ "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L442-L445","name":"Ordnode.eraseMin","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin","doc":"O(log n). Remove the minimum element from the tree, or do nothing if it is already empty.\n\neraseMin {1, 2, 3} = {2, 3}\neraseMin ∅ = ∅ "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L433-L435","name":"Ordnode.findMax","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax","doc":"O(log n). Return the maximum element of the tree, if it exists.\n\nfindMax {1, 2, 3} = some 3\nfindMax ∅ = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L424-L426","name":"Ordnode.findMax'","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'","doc":"O(log n). Return the maximum element of the tree, or the provided default value.\n\nfindMax' 37 {1, 2, 3} = 3\nfindMax' 37 ∅ = 37 "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L415-L417","name":"Ordnode.findMin","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin","doc":"O(log n). Return the minimum element of the tree, if it exists.\n\nfindMin {1, 2, 3} = some 1\nfindMin ∅ = none "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L406-L408","name":"Ordnode.findMin'","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'","doc":"O(log n). Return the minimum element of the tree, or the provided default value.\n\nfindMin' 37 {1, 2, 3} = 1\nfindMin' 37 ∅ = 37 "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L397-L399","name":"Ordnode.Amem.decidable","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L393-L394","name":"Ordnode.Amem","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem","doc":"O(n). Approximate membership in the set, that is, whether some element in the\nset is equivalent to this one in the preorder. This is useful primarily for stating\ncorrectness properties; use `∈` for a version that actually uses the BST property\nof the tree.\n\n    Amem 2 {1, 2, 3} = true\n    Amem 4 {1, 2, 3} = false\n\nTo see the difference with `Emem`, we need a preorder that is not a partial order.\nFor example, suppose we compare pairs of numbers using only their first coordinate. Then:\n-- Porting note: Verify below example\n    emem (0, 1) {(0, 0), (1, 2)} = false\n    amem (0, 1) {(0, 0), (1, 2)} = true\n    (0, 1) ∈ {(0, 0), (1, 2)} = true\n\nThe `∈` relation is equivalent to `Amem` as long as the `Ordnode` is well formed,\nand should always be used instead of `Amem`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L372-L373","name":"Ordnode.Emem.decidable","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L368-L369","name":"Ordnode.Emem","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem","doc":"O(n). Exact membership in the set. This is useful primarily for stating\ncorrectness properties; use `∈` for a version that actually uses the BST property\nof the tree.\n\n    Emem 2 {1, 2, 3} = true\n    Emem 4 {1, 2, 3} = false "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L354-L359","name":"Ordnode.Any.decidable","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L349-L351","name":"Ordnode.Any","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any","doc":"O(n). Does any element of the map satisfy property `P`?\n\nAny (fun x ↦ x < 2) {1, 2, 3} = True\nAny (fun x ↦ x < 2) {2, 3, 5} = False "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L337-L342","name":"Ordnode.All.decidable","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L332-L334","name":"Ordnode.All","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All","doc":"O(n). Does every element of the map satisfy property `P`?\n\nAll (fun x ↦ x < 5) {1, 2, 3} = True\nAll (fun x ↦ x < 5) {1, 2, 3, 5} = False "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L274-L325","name":"Ordnode.balance","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balance","doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had one side change\nby at most 1. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L237-L267","name":"Ordnode.balanceR","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR","doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had its right\nside grow by 1, or its left side shrink by 1. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L200-L230","name":"Ordnode.balanceL","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL","doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had its left\nside grow by 1, or its right side shrink by 1. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L192-L193","name":"Ordnode.instReprOrdnode","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instReprOrdnode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L182-L189","name":"Ordnode.repr","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr","doc":"Basic pretty printing for `Ordnode α` that shows the structure of the tree.\n\nrepr {3, 1, 2, 4} = ((∅ 1 ∅) 2 ((∅ 3 ∅) 4 ∅)) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L175-L176","name":"Ordnode.node'","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'","doc":"**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L166-L168","name":"Ordnode.dual","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual","doc":"**Internal use only**, because it violates the BST property on the original order.\n\nO(n). The dual of a tree is a tree with its left and right sides reversed throughout.\nThe dual of a valid BST is valid under the dual order. This is convenient for exploiting\nsymmetries in the algorithms. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L155-L157","name":"Ordnode.empty","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty","doc":"O(1). Is the set empty?\n\nempty ∅ = tt\nempty {1, 2, 3} = ff "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L144-L145","name":"Ordnode.size_node","kind":"theorem","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_node","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L142-L143","name":"Ordnode.size_nil","kind":"theorem","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_nil","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L137-L139","name":"Ordnode.size","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size","doc":"O(1). Get the size of the set.\n\nsize {2, 1, 1, 4} = 3  "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L130-L131","name":"Ordnode.instSingletonOrdnode","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingletonOrdnode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L123-L124","name":"Ordnode.singleton","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton","doc":"O(1). Construct a singleton set containing value `a`.\n\nsingleton 3 = {3} "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L115-L116","name":"Ordnode.ratio","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio","doc":"**Internal use only**\n\nThe ratio between an outer and inner sibling of the\nheavier subtree in an unbalanced setting. It determines\nwhether a double or single rotation should be performed\nto restore balance. It is corresponds with the inverse\nof `α` in Adam's article. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L103-L104","name":"Ordnode.delta","kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta","doc":"**Internal use only**\n\nThe maximal relative difference between the sizes of\ntwo trees, it corresponds with the `w` in Adams' paper.\n\nAccording to the Haskell comment, only `(delta, ratio)` settings\nof `(3, 2)` and `(4, 2)` will work, and the proofs in\n`Ordset.lean` assume `delta := 3` and `ratio := 2`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L91-L92","name":"Ordnode.instInhabitedOrdnode","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabitedOrdnode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L88-L89","name":"Ordnode.instEmptyCollectionOrdnode","kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollectionOrdnode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L78-L78","name":"Ordnode.node","kind":"ctor","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L77-L77","name":"Ordnode.nil","kind":"ctor","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/Ordmap/Ordnode.lean#L76-L78","name":"Ordnode","kind":"inductive","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode","doc":"An `Ordnode α` is a finite set of values, represented as a tree.\nThe operations on this type maintain that the tree is balanced\nand correctly stores subtree sizes at each level. "}]}