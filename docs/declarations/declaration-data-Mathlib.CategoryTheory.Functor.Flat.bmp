{"name":"Mathlib.CategoryTheory.Functor.Flat","instances":[{"typeNames":["CategoryTheory.Functor.id"],"name":"CategoryTheory.RepresentablyFlat.id","className":"CategoryTheory.RepresentablyFlat"},{"typeNames":["CategoryTheory.Functor.comp"],"name":"CategoryTheory.RepresentablyFlat.comp","className":"CategoryTheory.RepresentablyFlat"},{"typeNames":["CategoryTheory.Functor","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.category","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.category","Opposite","CategoryTheory.Category.opposite","CategoryTheory.lan","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.op","CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize","CategoryTheory.CostructuredArrow","CategoryTheory.instCategoryCostructuredArrow"],"name":"CategoryTheory.lanPreservesFiniteLimitsOfFlat","className":"CategoryTheory.Limits.PreservesFiniteLimits"},{"typeNames":["CategoryTheory.Functor","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.category","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.category","Opposite","CategoryTheory.Category.opposite","CategoryTheory.lan","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.op","CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize","CategoryTheory.CostructuredArrow","CategoryTheory.instCategoryCostructuredArrow"],"name":"CategoryTheory.lan_flat_of_flat","className":"CategoryTheory.RepresentablyFlat"},{"typeNames":["CategoryTheory.Functor","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.category","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.category","Opposite","CategoryTheory.Category.opposite","CategoryTheory.lan","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.op","CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize","CategoryTheory.CostructuredArrow","CategoryTheory.instCategoryCostructuredArrow"],"name":"CategoryTheory.lanPreservesFiniteLimitsOfPreservesFiniteLimits","className":"CategoryTheory.Limits.PreservesFiniteLimits"}],"imports":["Init","Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","Mathlib.CategoryTheory.Limits.Bicones","Mathlib.CategoryTheory.Limits.Comma","Mathlib.CategoryTheory.Limits.Preserves.Finite","Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L438-L459","name":"CategoryTheory.preservesFiniteLimitsIffLanPreservesFiniteLimits","kind":"def","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.preservesFiniteLimitsIffLanPreservesFiniteLimits","doc":"If `C` is finitely complete, then `F : C ⥤ D` preserves finite limits iff\n`Lan F.op : (Cᵒᵖ ⥤ Type*) ⥤ (Dᵒᵖ ⥤ Type*)` preserves finite limits.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L423-L431","name":"CategoryTheory.flat_iff_lan_flat","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.flat_iff_lan_flat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L416-L419","name":"CategoryTheory.lanPreservesFiniteLimitsOfPreservesFiniteLimits","kind":"instance","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.lanPreservesFiniteLimitsOfPreservesFiniteLimits","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L408-L410","name":"CategoryTheory.lan_flat_of_flat","kind":"instance","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.lan_flat_of_flat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L396-L404","name":"CategoryTheory.lanPreservesFiniteLimitsOfFlat","kind":"instance","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.lanPreservesFiniteLimitsOfFlat","doc":"If `F : C ⥤ D` is a representably flat functor between small categories, then the functor\n`Lan F.op` that takes presheaves over `C` to presheaves over `D` preserves finite limits.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L359-L383","name":"CategoryTheory.lanEvaluationIsoColim","kind":"def","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.lanEvaluationIsoColim","doc":"(Implementation)\nThe evaluation of `Lan F` at `X` is the colimit over the costructured arrows over `X`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L334-L345","name":"CategoryTheory.preservesFiniteLimitsIffFlat","kind":"def","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.preservesFiniteLimitsIffFlat","doc":"If `C` is finitely cocomplete, then `F : C ⥤ D` is representably flat iff it preserves\nfinite limits.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L316-L328","name":"CategoryTheory.preservesFiniteLimitsOfFlat","kind":"def","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.preservesFiniteLimitsOfFlat","doc":"Representably flat functors preserve finite limits. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L231-L309","name":"CategoryTheory.PreservesFiniteLimitsOfFlat.uniq","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.PreservesFiniteLimitsOfFlat.uniq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L225-L226","name":"CategoryTheory.PreservesFiniteLimitsOfFlat.fac","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.PreservesFiniteLimitsOfFlat.fac","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L215-L222","name":"CategoryTheory.PreservesFiniteLimitsOfFlat.lift","kind":"def","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.PreservesFiniteLimitsOfFlat.lift","doc":"(Implementation).\nGiven a limit cone `c : cone K` and a cone `s : cone (K ⋙ F)` with `F` representably flat,\n`s` can factor through `F.map_cone c`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L189-L198","name":"CategoryTheory.flat_of_preservesFiniteLimits","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.flat_of_preservesFiniteLimits","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L183-L186","name":"CategoryTheory.cofiltered_of_hasFiniteLimits","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.cofiltered_of_hasFiniteLimits","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L130-L172","name":"CategoryTheory.RepresentablyFlat.comp","kind":"instance","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat.comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L111-L127","name":"CategoryTheory.RepresentablyFlat.id","kind":"instance","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat.id","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L104-L104","name":"CategoryTheory.RepresentablyFlat.cofiltered","kind":"def","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat.cofiltered","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L103-L103","name":"CategoryTheory.RepresentablyFlat.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L103-L104","name":"CategoryTheory.RepresentablyFlat","kind":"class","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat","doc":"A functor `F : C ⥤ D` is representably-flat functor if the comma category `(X/F)`\nis cofiltered for each `X : C`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L86-L89","name":"CategoryTheory.StructuredArrowCone.toCone","kind":"def","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.StructuredArrowCone.toCone","doc":"Given a cone `c : cone K` and a map `f : X ⟶ F.obj c.X`, we can construct a cone of structured\narrows over `X` with `f` as the cone point.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L85-L85","name":"CategoryTheory.StructuredArrowCone.toCone_π_app","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.StructuredArrowCone.toCone_π_app","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L85-L85","name":"CategoryTheory.StructuredArrowCone.toCone_pt","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.StructuredArrowCone.toCone_pt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L78-L79","name":"CategoryTheory.StructuredArrowCone.diagramToCone","kind":"def","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.StructuredArrowCone.diagramToCone","doc":"Given a diagram of `structured_arrow X F`s, we may obtain a cone with cone point `X`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L77-L77","name":"CategoryTheory.StructuredArrowCone.diagramToCone_pt","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.StructuredArrowCone.diagramToCone_pt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L77-L77","name":"CategoryTheory.StructuredArrowCone.diagramToCone_π_app","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.StructuredArrowCone.diagramToCone_π_app","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L71-L73","name":"CategoryTheory.StructuredArrowCone.toDiagram","kind":"def","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.StructuredArrowCone.toDiagram","doc":"Given a cone `c : cone K` and a map `f : X ⟶ c.X`, we can construct a cone of structured\narrows over `X` with `f` as the cone point. This is the underlying diagram.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L70-L70","name":"CategoryTheory.StructuredArrowCone.toDiagram_map","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.StructuredArrowCone.toDiagram_map","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Functor/Flat.lean#L70-L70","name":"CategoryTheory.StructuredArrowCone.toDiagram_obj","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.StructuredArrowCone.toDiagram_obj","doc":""}]}