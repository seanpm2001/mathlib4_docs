{"name":"Mathlib.Tactic.Zify","instances":[],"imports":["Init","Mathlib.Tactic.Basic","Mathlib.Tactic.NormCast","Mathlib.Tactic.Zify.Attr","Mathlib.Data.Int.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Zify.lean#L97-L98","name":"Mathlib.Tactic.Zify.nat_cast_ne","kind":"theorem","docLink":"./Mathlib/Tactic/Zify.html#Mathlib.Tactic.Zify.nat_cast_ne","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Zify.lean#L96-L96","name":"Mathlib.Tactic.Zify.nat_cast_lt","kind":"theorem","docLink":"./Mathlib/Tactic/Zify.html#Mathlib.Tactic.Zify.nat_cast_lt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Zify.lean#L95-L95","name":"Mathlib.Tactic.Zify.nat_cast_le","kind":"theorem","docLink":"./Mathlib/Tactic/Zify.html#Mathlib.Tactic.Zify.nat_cast_le","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Zify.lean#L94-L94","name":"Mathlib.Tactic.Zify.nat_cast_eq","kind":"theorem","docLink":"./Mathlib/Tactic/Zify.html#Mathlib.Tactic.Zify.nat_cast_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Zify.lean#L88-L92","name":"Mathlib.Tactic.Zify.zifyProof","kind":"def","docLink":"./Mathlib/Tactic/Zify.html#Mathlib.Tactic.Zify.zifyProof","doc":"Translate a proof and the proposition into a zified form. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Zify.lean#L77-L85","name":"Mathlib.Tactic.Zify.applySimpResultToProp'","kind":"def","docLink":"./Mathlib/Tactic/Zify.html#Mathlib.Tactic.Zify.applySimpResultToProp'","doc":"A variant of `applySimpResultToProp` that cannot close the goal, but does not need a meta\nvariable and returns a tuple of a proof and the corresponding simplified proposition. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Zify.lean#L69-L73","name":"Mathlib.Tactic.Zify.mkZifyContext","kind":"def","docLink":"./Mathlib/Tactic/Zify.html#Mathlib.Tactic.Zify.mkZifyContext","doc":"The `Simp.Context` generated by `zify`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Zify.lean#L34-L60","name":"Mathlib.Tactic.Zify.zify","kind":"def","docLink":"./Mathlib/Tactic/Zify.html#Mathlib.Tactic.Zify.zify","doc":"The `zify` tactic is used to shift propositions from `ℕ` to `ℤ`.\nThis is often useful since `ℤ` has well-behaved subtraction.\n```\nexample (a b c x y z : ℕ) (h : ¬ x*y*z < 0) : c < a + 3*b := by\n  zify\n  zify at h\n  /-\n  h : ¬↑x * ↑y * ↑z < 0\n  ⊢ ↑c < ↑a + 3 * ↑b\n  -/\n```\n`zify` can be given extra lemmas to use in simplification. This is especially useful in the\npresence of nat subtraction: passing `≤` arguments will allow `push_cast` to do more work.\n```\nexample (a b c : ℕ) (h : a - b < c) (hab : b ≤ a) : false := by\n  zify [hab] at h\n  /- h : ↑a - ↑b < ↑c -/\n```\n`zify` makes use of the `@[zify_simps]` attribute to move propositions,\nand the `push_cast` tactic to simplify the `ℤ`-valued expressions.\n`zify` is in some sense dual to the `lift` tactic. `lift (z : ℤ) to ℕ` will change the type of an\ninteger `z` (in the supertype) to `ℕ` (the subtype), given a proof that `z ≥ 0`;\npropositions concerning `z` will still be over `ℤ`. `zify` changes propositions about `ℕ` (the\nsubtype) to propositions about `ℤ` (the supertype), without changing the type of any variable.\n"}]}