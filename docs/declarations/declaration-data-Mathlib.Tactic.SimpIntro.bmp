{"name":"Mathlib.Tactic.SimpIntro","instances":[],"imports":["Init","Lean","Std.Lean.Parser"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/SimpIntro.lean#L49-L74","name":"Mathlib.Tactic.«tacticSimp_intro_____..Only_»","kind":"def","docLink":"./Mathlib/Tactic/SimpIntro.html#Mathlib.Tactic.«tacticSimp_intro_____..Only_»","doc":"The `simp_intro` tactic is a combination of `simp` and `intro`: it will simplify the types of\nvariables as it introduces them and uses the new variables to simplify later arguments\nand the goal.\n* `simp_intro x y z` introduces variables named `x y z`\n* `simp_intro x y z ..` introduces variables named `x y z` and then keeps introducing `_` binders\n* `simp_intro (config := cfg) (discharger := tac) x y .. only [h₁, h₂]`:\n  `simp_intro` takes the same options as `simp` (see `simp`)\n```\nexample : x + 0 = y → x = z := by\n  simp_intro h\n  -- h: x = y ⊢ y = z\n  sorry\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/SimpIntro.lean#L22-L46","name":"Mathlib.Tactic.simpIntroCore","kind":"opaque","docLink":"./Mathlib/Tactic/SimpIntro.html#Mathlib.Tactic.simpIntroCore","doc":"Main loop of the `simp_intro` tactic.\n* `g`: the original goal\n* `ctx`: the simp context, which is extended with local variables as we enter the binders\n* `discharge?`: the discharger\n* `more`: if true, we will keep introducing binders as long as we can\n* `ids`: the list of binder identifiers\n"}]}