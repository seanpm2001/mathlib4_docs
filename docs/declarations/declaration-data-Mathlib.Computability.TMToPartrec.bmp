{"name":"Mathlib.Computability.TMToPartrec","instances":[{"typeNames":["Eq","Turing.ToPartrec.Code"],"name":"Turing.ToPartrec.instDecidableEqCode","className":"Decidable"},{"typeNames":["Turing.ToPartrec.Code"],"name":"Turing.ToPartrec.instInhabitedCode","className":"Inhabited"},{"typeNames":["Turing.ToPartrec.Cont"],"name":"Turing.ToPartrec.instInhabitedCont","className":"Inhabited"},{"typeNames":["Turing.ToPartrec.Cfg"],"name":"Turing.ToPartrec.instInhabitedCfg","className":"Inhabited"},{"typeNames":["Eq","Turing.PartrecToTM2.Γ'"],"name":"Turing.PartrecToTM2.instDecidableEqΓ'","className":"Decidable"},{"typeNames":["Turing.PartrecToTM2.Γ'"],"name":"Turing.PartrecToTM2.instInhabitedΓ'","className":"Inhabited"},{"typeNames":["Turing.PartrecToTM2.Γ'"],"name":"Turing.PartrecToTM2.instFintypeΓ'","className":"Fintype"},{"typeNames":["Eq","Turing.PartrecToTM2.K'"],"name":"Turing.PartrecToTM2.instDecidableEqK'","className":"Decidable"},{"typeNames":["Turing.PartrecToTM2.K'"],"name":"Turing.PartrecToTM2.instInhabitedK'","className":"Inhabited"},{"typeNames":["Eq","Turing.PartrecToTM2.Cont'"],"name":"Turing.PartrecToTM2.instDecidableEqCont'","className":"Decidable"},{"typeNames":["Turing.PartrecToTM2.Cont'"],"name":"Turing.PartrecToTM2.instInhabitedCont'","className":"Inhabited"},{"typeNames":["Turing.PartrecToTM2.Λ'"],"name":"Turing.PartrecToTM2.Λ'.instInhabited","className":"Inhabited"},{"typeNames":["Eq","Turing.PartrecToTM2.Λ'"],"name":"Turing.PartrecToTM2.Λ'.instDecidableEq","className":"Decidable"}],"imports":["Init","Mathlib.Computability.Halting","Mathlib.Computability.TuringMachine","Mathlib.Data.Num.Lemmas","Mathlib.Tactic.DeriveFintype"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L2070-L2071","name":"Turing.PartrecToTM2.tr_supports","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_supports","doc":"The set `codeSupp c k` is a finite set that witnesses the effective finiteness of the `tr`\nTuring machine. Starting from the initial state `trNormal c k`, forward simulation uses only\nstates in `codeSupp c k`, so this is a finite state machine. Even though the underlying type of\nstate labels `Λ'` is infinite, for a given partial recursive function `c` and continuation `k`,\nonly finitely many states are accessed, corresponding roughly to subterms of `c`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L2061-L2062","name":"Turing.PartrecToTM2.codeSupp_supports","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp_supports","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L2041-L2058","name":"Turing.PartrecToTM2.contSupp_supports","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.contSupp_supports","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L2001-L2038","name":"Turing.PartrecToTM2.codeSupp'_supports","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp'_supports","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1984-L1998","name":"Turing.PartrecToTM2.trNormal_supports","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trNormal_supports","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1978-L1981","name":"Turing.PartrecToTM2.trStmts₁_supports'","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trStmts₁_supports'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1953-L1975","name":"Turing.PartrecToTM2.trStmts₁_supports","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trStmts₁_supports","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1938-L1950","name":"Turing.PartrecToTM2.ret_supports","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.ret_supports","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1934-L1935","name":"Turing.PartrecToTM2.head_supports","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.head_supports","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1929-L1931","name":"Turing.PartrecToTM2.supports_biUnion","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.supports_biUnion","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1925-L1926","name":"Turing.PartrecToTM2.supports_union","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.supports_union","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1922-L1922","name":"Turing.PartrecToTM2.supports_singleton","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.supports_singleton","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1918-L1919","name":"Turing.PartrecToTM2.supports_insert","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.supports_insert","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1914-L1915","name":"Turing.PartrecToTM2.Supports","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Supports","doc":"A shorthand for the predicate that we are proving in the main theorems `trStmts₁_supports`,\n`codeSupp'_supports`, `contSupp_supports`, `codeSupp_supports`. The set `S` is fixed throughout\nthe proof, and denotes the full set of states in the machine, while `K` is a subset that we are\ncurrently proving a property about. The predicate asserts that every state in `K` is closed in `S`\nunder forward simulation, i.e. stepping forward through evaluation starting from any state in `K`\nstays entirely within `S`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1897-L1905","name":"Turing.PartrecToTM2.Λ'.Supports","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.Supports","doc":"The statement `Λ'.Supports S q` means that `contSupp k ⊆ S` for any `ret k`\nreachable from `q`.\n(This is a technical condition used in the proof that the machine is supported.) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1890-L1891","name":"Turing.PartrecToTM2.contSupp_halt","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.contSupp_halt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1884-L1886","name":"Turing.PartrecToTM2.contSupp_fix","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.contSupp_fix","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1880-L1881","name":"Turing.PartrecToTM2.contSupp_comp","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.contSupp_comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1874-L1876","name":"Turing.PartrecToTM2.contSupp_cons₂","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.contSupp_cons₂","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1863-L1870","name":"Turing.PartrecToTM2.contSupp_cons₁","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.contSupp_cons₁","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1856-L1859","name":"Turing.PartrecToTM2.codeSupp_fix","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp_fix","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1849-L1852","name":"Turing.PartrecToTM2.codeSupp_case","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp_case","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1840-L1845","name":"Turing.PartrecToTM2.codeSupp_comp","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp_comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1833-L1836","name":"Turing.PartrecToTM2.codeSupp_cons","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp_cons","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1828-L1829","name":"Turing.PartrecToTM2.codeSupp_tail","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp_tail","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1823-L1824","name":"Turing.PartrecToTM2.codeSupp_succ","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp_succ","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1818-L1819","name":"Turing.PartrecToTM2.codeSupp_zero","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1813-L1814","name":"Turing.PartrecToTM2.codeSupp_self","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp_self","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1808-L1809","name":"Turing.PartrecToTM2.codeSupp","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp","doc":"The (finite!) set of machine states visited during the course of evaluation of `c` in\ncontinuation `k`. This is actually closed under forward simulation (see `tr_supports`), and the\nexistence of this set means that the machine constructed in this section is in fact a proper\nTuring machine, with a finite set of states. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1791-L1801","name":"Turing.PartrecToTM2.contSupp","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.contSupp","doc":"The (finite!) set of machine states visited during the course of evaluation of a continuation\n`k`, not including the initial state `ret k`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1785-L1786","name":"Turing.PartrecToTM2.codeSupp'_self","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp'_self","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1762-L1781","name":"Turing.PartrecToTM2.codeSupp'","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.codeSupp'","doc":"The (finite!) set of machine states visited during the course of evaluation of `c`,\nincluding the state `ret k` but not any states after that (that is, the states visited while\nevaluating `k`). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1755-L1756","name":"Turing.PartrecToTM2.trStmts₁_self","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trStmts₁_self","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1734-L1752","name":"Turing.PartrecToTM2.trStmts₁_trans","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trStmts₁_trans","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1723-L1731","name":"Turing.PartrecToTM2.trStmts₁","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trStmts₁","doc":"The set of machine states reachable via downward label jumps, discounting jumps via `ret`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1706-L1719","name":"Turing.PartrecToTM2.tr_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1701-L1703","name":"Turing.PartrecToTM2.tr_init","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_init","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1697-L1698","name":"Turing.PartrecToTM2.init","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.init","doc":"The initial state, evaluating function `c` on input `v`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1691-L1693","name":"Turing.PartrecToTM2.tr_respects","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_respects","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1637-L1688","name":"Turing.PartrecToTM2.tr_ret_respects","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_ret_respects","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1603-L1634","name":"Turing.PartrecToTM2.trNormal_respects","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trNormal_respects","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1559-L1600","name":"Turing.PartrecToTM2.pred_ok","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.pred_ok","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1526-L1556","name":"Turing.PartrecToTM2.succ_ok","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.succ_ok","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1496-L1523","name":"Turing.PartrecToTM2.head_stack_ok","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.head_stack_ok","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1480-L1493","name":"Turing.PartrecToTM2.head_main_ok","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.head_main_ok","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1470-L1477","name":"Turing.PartrecToTM2.trList_ne_consₗ","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trList_ne_consₗ","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1466-L1467","name":"Turing.PartrecToTM2.trNat_natEnd","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trNat_natEnd","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1462-L1463","name":"Turing.PartrecToTM2.trNum_natEnd","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trNum_natEnd","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1454-L1459","name":"Turing.PartrecToTM2.trPosNum_natEnd","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trPosNum_natEnd","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1443-L1451","name":"Turing.PartrecToTM2.copy_ok","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.copy_ok","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1416-L1440","name":"Turing.PartrecToTM2.clear_ok","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.clear_ok","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1393-L1413","name":"Turing.PartrecToTM2.move₂_ok","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.move₂_ok","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1387-L1390","name":"Turing.PartrecToTM2.unrev_ok","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.unrev_ok","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1352-L1384","name":"Turing.PartrecToTM2.move_ok","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.move_ok","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1348-L1349","name":"Turing.PartrecToTM2.splitAtPred_false","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.splitAtPred_false","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1328-L1345","name":"Turing.PartrecToTM2.splitAtPred_eq","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.splitAtPred_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1320-L1325","name":"Turing.PartrecToTM2.splitAtPred","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.splitAtPred","doc":"This could be a general list definition, but it is also somewhat specialized to this\napplication. `splitAtPred p L` will search `L` for the first element satisfying `p`.\nIf it is found, say `L = l₁ ++ a :: l₂` where `a` satisfies `p` but `l₁` does not, then it returns\n`(l₁, some a, l₂)`. Otherwise, if there is no such element, it returns `(L, none, [])`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1310-L1313","name":"Turing.PartrecToTM2.TrCfg","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.TrCfg","doc":"The `Cfg` states map to `Cfg'` states almost one to one, except that in normal operation the\nlocal store contains an arbitrary garbage value. To make the final theorem cleaner we explicitly\nclear it in the halt state so that there is exactly one configuration corresponding to output `v`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1302-L1303","name":"Turing.PartrecToTM2.halt","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.halt","doc":"The halting state corresponding to a `List ℕ` output value. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1297-L1298","name":"Turing.PartrecToTM2.K'.elim_update_stack","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.elim_update_stack","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1292-L1293","name":"Turing.PartrecToTM2.K'.elim_update_aux","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.elim_update_aux","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1287-L1288","name":"Turing.PartrecToTM2.K'.elim_update_rev","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.elim_update_rev","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1282-L1283","name":"Turing.PartrecToTM2.K'.elim_update_main","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.elim_update_main","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1276-L1276","name":"Turing.PartrecToTM2.K'.elim_stack","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.elim_stack","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1274-L1274","name":"Turing.PartrecToTM2.K'.elim_aux","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.elim_aux","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1272-L1272","name":"Turing.PartrecToTM2.K'.elim_rev","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.elim_rev","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1270-L1270","name":"Turing.PartrecToTM2.K'.elim_main","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.elim_main","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1260-L1264","name":"Turing.PartrecToTM2.K'.elim","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.elim","doc":"This is the nondependent eliminator for `K'`, but we use it specifically here in order to\nrepresent the stack data as four lists rather than as a function `K' → List Γ'`, because this makes\nrewrites easier. The theorems `K'.elim_update_main` et. al. show how such a function is updated\nafter an `update` to one of the components. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1252-L1253","name":"Turing.PartrecToTM2.trContStack","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trContStack","doc":"The data part of a continuation is a list of lists, which is encoded on the `stack` stack\nusing `trLList`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1242-L1247","name":"Turing.PartrecToTM2.contStack","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.contStack","doc":"The data part of a continuation is a list of lists, which is encoded on the `stack` stack\nusing `trLList`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1234-L1236","name":"Turing.PartrecToTM2.trLList","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trLList","doc":"Lists of lists are translated with a `consₗ` after each encoded list.\nFor example:\n\n    [] = []\n    [[]] = [consₗ]\n    [[], []] = [consₗ, consₗ]\n    [[0]] = [cons, consₗ]\n    [[1, 2], [0]] = [bit1, cons, bit0, bit1, cons, consₗ, cons, consₗ]\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1219-L1221","name":"Turing.PartrecToTM2.trList","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trList","doc":"Lists are translated with a `cons` after each encoded number.\nFor example:\n\n    [] = []\n    [0] = [cons]\n    [1] = [bit1, cons]\n    [6, 0] = [bit0, bit1, bit1, cons, cons]\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1206-L1207","name":"Turing.PartrecToTM2.trNat_default","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trNat_default","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1202-L1202","name":"Turing.PartrecToTM2.trNat_zero","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trNat_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1197-L1198","name":"Turing.PartrecToTM2.trNat","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trNat","doc":"Because we use binary encoding, we define `trNat` in terms of `trNum`, using `Num`, which are\nbinary natural numbers. (We could also use `Nat.binaryRecOn`, but `Num` and `PosNum` make for\neasy inductions.) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1189-L1191","name":"Turing.PartrecToTM2.trNum","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trNum","doc":"We use `Num` to define the translation of binary natural numbers. Positive numbers are\ntranslated using `trPosNum`, and `trNum 0 = []`. So there are never any trailing `bit0`'s in\na translated `Num`.\n\n    0 = []\n    1 = [bit1]\n    2 = [bit0, bit1]\n    3 = [bit1, bit1]\n    4 = [bit0, bit0, bit1]\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1173-L1176","name":"Turing.PartrecToTM2.trPosNum","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trPosNum","doc":"We use `PosNum` to define the translation of binary natural numbers. A natural number is\nrepresented as a little-endian list of `bit0` and `bit1` elements:\n\n    1 = [bit1]\n    2 = [bit0, bit1]\n    3 = [bit1, bit1]\n    4 = [bit0, bit0, bit1]\n\nIn particular, this representation guarantees no trailing `bit0`'s at the end of the list. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1156-L1161","name":"Turing.PartrecToTM2.trCont","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trCont","doc":"Translating a `Cont` continuation to a `Cont'` continuation simply entails dropping all the\ndata. This data is instead encoded in `trContStack` in the configuration. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1147-L1147","name":"Turing.PartrecToTM2.tr_ret_halt","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_ret_halt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1144-L1145","name":"Turing.PartrecToTM2.tr_ret_fix","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_ret_fix","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1142-L1142","name":"Turing.PartrecToTM2.tr_ret_comp","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_ret_comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1139-L1140","name":"Turing.PartrecToTM2.tr_ret_cons₂","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_ret_cons₂","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1134-L1137","name":"Turing.PartrecToTM2.tr_ret_cons₁","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_ret_cons₁","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1127-L1132","name":"Turing.PartrecToTM2.tr_pred","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_pred","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1121-L1125","name":"Turing.PartrecToTM2.tr_succ","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_succ","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1118-L1119","name":"Turing.PartrecToTM2.tr_copy","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_copy","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1115-L1116","name":"Turing.PartrecToTM2.tr_clear","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_clear","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1113-L1113","name":"Turing.PartrecToTM2.tr_read","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_read","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1110-L1111","name":"Turing.PartrecToTM2.tr_push","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_push","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1106-L1108","name":"Turing.PartrecToTM2.tr_move","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr_move","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1061-L1100","name":"Turing.PartrecToTM2.tr","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.tr","doc":"The main program. See the section documentation for details. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1048-L1057","name":"Turing.PartrecToTM2.trNormal","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.trNormal","doc":"The program that evaluates code `c` with continuation `k`. This expects an initial state where\n`trList v` is on `main`, `trContStack k` is on `stack`, and `aux` and `rev` are empty.\nSee the section documentation for details. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1037-L1041","name":"Turing.PartrecToTM2.head","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.head","doc":"Assuming `trList v` is on the front of stack `k`, remove it, and push `v.headI` onto `main`.\nSee the section documentation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1031-L1032","name":"Turing.PartrecToTM2.move₂","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.move₂","doc":"Move elements from `k₁` to `k₂` without reversion, by performing a double move via the `rev`\nstack. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1025-L1026","name":"Turing.PartrecToTM2.moveExcl","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.moveExcl","doc":"Move elements from `k₁` to `k₂` while `p` holds, with the last element being left on `k₁`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1020-L1021","name":"Turing.PartrecToTM2.unrev","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.unrev","doc":"Move everything from the `rev` stack to the `main` stack (reversed). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1015-L1016","name":"Turing.PartrecToTM2.push'","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.push'","doc":"Push the value in the local store to the given stack. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1009-L1010","name":"Turing.PartrecToTM2.peek'","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.peek'","doc":"Peek a value from the stack and place the result in local store. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L1003-L1004","name":"Turing.PartrecToTM2.pop'","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.pop'","doc":"Pop a value from the stack and place the result in local store. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L995-L998","name":"Turing.PartrecToTM2.natEnd","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.natEnd","doc":"A predicate that detects the end of a natural number, either `Γ'.cons` or `Γ'.consₗ` (or\nimplicitly the end of the list), for use in predicate-taking functions like `move` and `clear`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L986-L987","name":"Turing.PartrecToTM2.Cfg'","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Cfg'","doc":"The type of TM2 configurations used by this machine. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L981-L982","name":"Turing.PartrecToTM2.Stmt'","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Stmt'","doc":"The type of TM2 statements used by this machine. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L952-L977","name":"Turing.PartrecToTM2.Λ'.instDecidableEq","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.instDecidableEq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L948-L949","name":"Turing.PartrecToTM2.Λ'.instInhabited","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.instInhabited","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L931-L931","name":"Turing.PartrecToTM2.Λ'.ret","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.ret","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L930-L930","name":"Turing.PartrecToTM2.Λ'.pred","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.pred","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L929-L929","name":"Turing.PartrecToTM2.Λ'.succ","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.succ","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L928-L928","name":"Turing.PartrecToTM2.Λ'.read","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.read","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L927-L927","name":"Turing.PartrecToTM2.Λ'.push","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.push","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L926-L926","name":"Turing.PartrecToTM2.Λ'.copy","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.copy","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L925-L925","name":"Turing.PartrecToTM2.Λ'.clear","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.clear","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L924-L924","name":"Turing.PartrecToTM2.Λ'.move","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'.move","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L923-L931","name":"Turing.PartrecToTM2.Λ'","kind":"inductive","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Λ'","doc":"The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L910-L910","name":"Turing.PartrecToTM2.instInhabitedCont'","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.instInhabitedCont'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L910-L910","name":"Turing.PartrecToTM2.instDecidableEqCont'","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.instDecidableEqCont'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L909-L909","name":"Turing.PartrecToTM2.Cont'.fix","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Cont'.fix","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L908-L908","name":"Turing.PartrecToTM2.Cont'.comp","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Cont'.comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L907-L907","name":"Turing.PartrecToTM2.Cont'.cons₂","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Cont'.cons₂","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L906-L906","name":"Turing.PartrecToTM2.Cont'.cons₁","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Cont'.cons₁","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L905-L905","name":"Turing.PartrecToTM2.Cont'.halt","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Cont'.halt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L904-L910","name":"Turing.PartrecToTM2.Cont'","kind":"inductive","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Cont'","doc":"Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L891-L891","name":"Turing.PartrecToTM2.instInhabitedK'","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.instInhabitedK'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L891-L891","name":"Turing.PartrecToTM2.instDecidableEqK'","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.instDecidableEqK'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L890-L890","name":"Turing.PartrecToTM2.K'.stack","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.stack","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L889-L889","name":"Turing.PartrecToTM2.K'.aux","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.aux","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L888-L888","name":"Turing.PartrecToTM2.K'.rev","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.rev","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L887-L887","name":"Turing.PartrecToTM2.K'.main","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'.main","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L886-L891","name":"Turing.PartrecToTM2.K'","kind":"inductive","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.K'","doc":"The four stacks used by the program. `main` is used to store the input value in `trNormal`\nmode and the output value in `Λ'.ret` mode, while `stack` is used to keep all the data for the\ncontinuations. `rev` is used to store reversed lists when transferring values between stacks, and\n`aux` is only used once in `cons₁`. See the section documentation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L875-L875","name":"Turing.PartrecToTM2.instFintypeΓ'","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.instFintypeΓ'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L875-L875","name":"Turing.PartrecToTM2.instInhabitedΓ'","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.instInhabitedΓ'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L875-L875","name":"Turing.PartrecToTM2.instDecidableEqΓ'","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.instDecidableEqΓ'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L874-L874","name":"Turing.PartrecToTM2.Γ'.bit1","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Γ'.bit1","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L873-L873","name":"Turing.PartrecToTM2.Γ'.bit0","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Γ'.bit0","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L872-L872","name":"Turing.PartrecToTM2.Γ'.cons","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Γ'.cons","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L871-L871","name":"Turing.PartrecToTM2.Γ'.consₗ","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Γ'.consₗ","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L870-L875","name":"Turing.PartrecToTM2.Γ'","kind":"inductive","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.PartrecToTM2.Γ'","doc":"The alphabet for the stacks in the program. `bit0` and `bit1` are used to represent `ℕ` values\nas lists of binary digits, `cons` is used to separate `List ℕ` values, and `consₗ` is used to\nseparate `List (List ℕ)` values. See the section documentation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L725-L746","name":"Turing.ToPartrec.stepRet_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.stepRet_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L721-L722","name":"Turing.ToPartrec.stepNormal_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.stepNormal_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L701-L718","name":"Turing.ToPartrec.code_is_ok","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.code_is_ok","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L628-L698","name":"Turing.ToPartrec.cont_eval_fix","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.cont_eval_fix","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L616-L625","name":"Turing.ToPartrec.stepNormal.is_ret","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.stepNormal.is_ret","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L610-L613","name":"Turing.ToPartrec.Code.Ok.zero","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.Ok.zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L605-L607","name":"Turing.ToPartrec.Code.Ok","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.Ok","doc":"This is a temporary definition, because we will prove in `code_is_ok` that it always holds.\nIt asserts that `c` is semantically correct; that is, for any `k` and `v`,\n`eval (stepNormal c k v) = eval (Cfg.ret k (Code.eval c v))`, as an equality of partial values\n(so one diverges iff the other does).\n\nIn particular, we can let `k = Cont.halt`, and then this asserts that `stepNormal c Cont.halt v`\nevaluates to `Cfg.halt (Code.eval c v)`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L583-L595","name":"Turing.ToPartrec.stepRet_then","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.stepRet_then","doc":"The `stepRet` function respects the `then k'` homomorphism. Note that this is an exact\nequality, not a simulation; the original and embedded machines move in lock-step until the\nembedded machine reaches the halt state. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L570-L577","name":"Turing.ToPartrec.stepNormal_then","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.stepNormal_then","doc":"The `stepNormal` function respects the `then k'` homomorphism. Note that this is an exact\nequality, not a simulation; the original and embedded machines move in lock-step until the\nembedded machine reaches the halt state. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L562-L564","name":"Turing.ToPartrec.Cfg.then","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cfg.then","doc":"The `then k` function is a \"configuration homomorphism\". Its operation on states is to append\n`k` to the continuation of a `Cfg.ret` state, and to run `k` on `v` if we are in the `Cfg.halt v`\nstate. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L552-L556","name":"Turing.ToPartrec.Cont.then_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cont.then_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L544-L549","name":"Turing.ToPartrec.Cont.then","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cont.then","doc":"In order to extract a compositional semantics from the sequential execution behavior of\nconfigurations, we observe that continuations have a monoid structure, with `Cont.halt` as the unit\nand `Cont.then` as the multiplication. `Cont.then k₁ k₂` runs `k₁` until it halts, and then takes\nthe result of `k₁` and passes it to `k₂`.\n\nWe will not prove it is associative (although it is), but we are instead interested in the\nassociativity law `k₂ (eval c k₁) = eval c (k₁.then k₂)`. This holds at both the sequential and\ncompositional levels, and allows us to express running a machine without the ambient continuation\nand relate it to the original machine's evaluation steps. In the literature this is usually\nwhere one uses Turing machines embedded inside other Turing machines, but this approach allows us\nto avoid changing the ambient type `Cfg` in the middle of the recursion.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L527-L529","name":"Turing.ToPartrec.step","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.step","doc":"If we are not done (in `Cfg.halt` state), then we must be still stuck on a continuation, so\nthis main loop calls `stepRet` with the new continuation. The overall `step` function transitions\nfrom one `Cfg` to another, only halting at the `Cfg.halt` state. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L516-L521","name":"Turing.ToPartrec.stepRet","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.stepRet","doc":"Evaluating a continuation `k : Cont` on input `v : List ℕ`. This is the second part of\nevaluation, when we receive results from continuations built by `stepNormal`.\n\n* `Cont.halt v = v`, so we are done and transition to the `Cfg.halt v` state\n* `Cont.cons₁ fs as k v = k (v.headI :: fs as)`, so we evaluate `fs as` now with the continuation\n  `k (v.headI :: _)` (called `cons₂ v k`).\n* `Cont.cons₂ ns k v = k (ns.headI :: v)`, where we now have everything we need to evaluate\n  `ns.headI :: v`, so we return it to `k`.\n* `Cont.comp f k v = k (f v)`, so we call `f v` with `k` as the continuation.\n* `Cont.fix f k v = k (if v.headI = 0 then k v.tail else fix f v.tail)`, where `v` is a value,\n  so we evaluate the if statement and either call `k` with `v.tail`, or call `fix f v` with `k` as\n  the continuation (which immediately calls `f` with `Cont.fix f k` as the continuation).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L492-L500","name":"Turing.ToPartrec.stepNormal","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.stepNormal","doc":"Evaluating `c : Code` in a continuation `k : Cont` and input `v : List ℕ`. This goes by\nrecursion on `c`, building an augmented continuation and a value to pass to it.\n\n* `zero' v = 0 :: v` evaluates immediately, so we return it to the parent continuation\n* `succ v = [v.headI.succ]` evaluates immediately, so we return it to the parent continuation\n* `tail v = v.tail` evaluates immediately, so we return it to the parent continuation\n* `cons f fs v = (f v).headI :: fs v` requires two sub-evaluations, so we evaluate\n  `f v` in the continuation `k (_.headI :: fs v)` (called `Cont.cons₁ fs v k`)\n* `comp f g v = f (g v)` requires two sub-evaluations, so we evaluate\n  `g v` in the continuation `k (f _)` (called `Cont.comp f k`)\n* `case f g v = v.head.casesOn (f v.tail) (fun n => g (n :: v.tail))` has the information needed\n  to evaluate the case statement, so we do that and transition to either\n  `f v` or `g (n :: v.tail)`.\n* `fix f v = let v' := f v; if v'.headI = 0 then k v'.tail else fix f v'.tail`\n  needs to first evaluate `f v`, so we do that and leave the rest for the continuation (called\n  `Cont.fix f k`)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L470-L470","name":"Turing.ToPartrec.instInhabitedCfg","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.instInhabitedCfg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L469-L469","name":"Turing.ToPartrec.Cfg.ret","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cfg.ret","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L468-L468","name":"Turing.ToPartrec.Cfg.halt","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cfg.halt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L467-L470","name":"Turing.ToPartrec.Cfg","kind":"inductive","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cfg","doc":"The set of configurations of the machine:\n\n* `halt v`: The machine is about to stop and `v : List ℕ` is the result.\n* `ret k v`: The machine is about to pass `v : List ℕ` to continuation `k : cont`.\n\nWe don't have a state corresponding to normal evaluation because these are evaluated immediately\nto a `ret` \"in zero steps\" using the `stepNormal` function. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L450-L457","name":"Turing.ToPartrec.Cont.eval","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cont.eval","doc":"The semantics of a continuation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L441-L441","name":"Turing.ToPartrec.instInhabitedCont","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.instInhabitedCont","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L440-L440","name":"Turing.ToPartrec.Cont.fix","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cont.fix","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L439-L439","name":"Turing.ToPartrec.Cont.comp","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cont.comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L438-L438","name":"Turing.ToPartrec.Cont.cons₂","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cont.cons₂","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L437-L437","name":"Turing.ToPartrec.Cont.cons₁","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cont.cons₁","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L436-L436","name":"Turing.ToPartrec.Cont.halt","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cont.halt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L435-L441","name":"Turing.ToPartrec.Cont","kind":"inductive","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Cont","doc":"The type of continuations, built up during evaluation of a `Code` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L288-L392","name":"Turing.ToPartrec.Code.exists_code","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.exists_code","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L267-L285","name":"Turing.ToPartrec.Code.exists_code.comp","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.exists_code.comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L255-L262","name":"Turing.ToPartrec.Code.prec","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.prec","doc":"`prec f g` implements the `prec` (primitive recursion) operation of partial recursive\nfunctions. `prec f g` evaluates as:\n\n* `prec f g [] = [f []]`\n* `prec f g (0 :: v) = [f v]`\n* `prec f g (n+1 :: v) = [g (n :: prec f g (n :: v) :: v)]`\n\nIt is implemented as:\n\n    G (a :: b :: IH :: v) = (b :: a+1 :: b-1 :: g (a :: IH :: v) :: v)\n    F (0 :: f_v :: v) = (f_v :: v)\n    F (n+1 :: f_v :: v) = (fix G (0 :: n :: f_v :: v)).tail.tail\n    prec f g (a :: v) = [(F (a :: f v :: v)).head]\n\nBecause `fix` always evaluates its body at least once, we must special case the `0` case to avoid\ncalling `g` more times than necessary (which could be bad if `g` diverges). If the input is\n`0 :: v`, then `F (0 :: f v :: v) = (f v :: v)` so we return `[f v]`. If the input is `n+1 :: v`,\nwe evaluate the function from the bottom up, with initial state `0 :: n :: f v :: v`. The first\nnumber counts up, providing arguments for the applications to `g`, while the second number counts\ndown, providing the exit condition (this is the initial `b` in the return value of `G`, which is\nstripped by `fix`). After the `fix` is complete, the final state is `n :: 0 :: res :: v` where\n`res` is the desired result, and the rest reduces this to `[res]`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L229-L230","name":"Turing.ToPartrec.Code.rfind","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.rfind","doc":"`rfind f` performs the function of the `rfind` primitive of partial recursive functions.\n`rfind f v` returns the smallest `n` such that `(f (n :: v)).head = 0`.\n\nIt is implemented as:\n\n    rfind f v = pred (fix (fun (n::v) => f (n::v) :: n+1 :: v) (0 :: v))\n\nThe idea is that the initial state is `0 :: v`, and the `fix` keeps `n :: v` as its internal state;\nit calls `f (n :: v)` as the exit test and `n+1 :: v` as the next state. At the end we get\n`n+1 :: v` where `n` is the desired output, and `pred (n+1 :: v) = [n]` returns the result.\n "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L214-L215","name":"Turing.ToPartrec.Code.pred_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.pred_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L209-L210","name":"Turing.ToPartrec.Code.pred","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.pred","doc":"`pred` returns the predecessor of the head of the input:\n`pred [] = [0]`, `pred (0 :: v) = [0]`, `pred (n+1 :: v) = [n]`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L204-L204","name":"Turing.ToPartrec.Code.zero_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.zero_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L199-L200","name":"Turing.ToPartrec.Code.zero","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.zero","doc":"`zero` is the constant zero function: `zero v = [0]`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L195-L195","name":"Turing.ToPartrec.Code.head_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.head_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L190-L191","name":"Turing.ToPartrec.Code.head","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.head","doc":"`head` gets the head of the input list: `head [] = [0]`, `head (n :: v) = [n]`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L186-L186","name":"Turing.ToPartrec.Code.id_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.id_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L181-L182","name":"Turing.ToPartrec.Code.id","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.id","doc":"`id` is the identity function: `id v = v`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L177-L177","name":"Turing.ToPartrec.Code.nil_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.nil_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L172-L173","name":"Turing.ToPartrec.Code.nil","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.nil","doc":"`nil` is the constant nil function: `nil v = []`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L166-L169","name":"Turing.ToPartrec.Code.fix_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.fix_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L161-L163","name":"Turing.ToPartrec.Code.case_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.case_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L158-L158","name":"Turing.ToPartrec.Code.comp_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.comp_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L152-L155","name":"Turing.ToPartrec.Code.cons_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.cons_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L149-L149","name":"Turing.ToPartrec.Code.tail_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.tail_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L146-L146","name":"Turing.ToPartrec.Code.succ_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.succ_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L143-L143","name":"Turing.ToPartrec.Code.zero'_eval","kind":"theorem","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.zero'_eval","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L122-L133","name":"Turing.ToPartrec.Code.eval","kind":"def","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.eval","doc":"The semantics of the `Code` primitives, as partial functions `List ℕ →. List ℕ`. By convention\nwe functions that return a single result return a singleton `[n]`, or in some cases `n :: v` where\n`v` will be ignored by a subsequent function.\n\n* `zero'` appends a `0` to the input. That is, `zero' v = 0 :: v`.\n* `succ` returns the successor of the head of the input, defaulting to zero if there is no head:\n  * `succ [] = [1]`\n  * `succ (n :: v) = [n + 1]`\n* `tail` returns the tail of the input\n  * `tail [] = []`\n  * `tail (n :: v) = v`\n* `cons f fs` calls `f` and `fs` on the input and conses the results:\n  * `cons f fs v = (f v).head :: fs v`\n* `comp f g` calls `f` on the output of `g`:\n  * `comp f g v = f (g v)`\n* `case f g` cases on the head of the input, calling `f` or `g` depending on whether it is zero or\n  a successor (similar to `Nat.casesOn`).\n  * `case f g [] = f []`\n  * `case f g (0 :: v) = f v`\n  * `case f g (n+1 :: v) = g (n :: v)`\n* `fix f` calls `f` repeatedly, using the head of the result of `f` to decide whether to call `f`\n  again or finish:\n  * `fix f v = []` if `f v = []`\n  * `fix f v = w` if `f v = 0 :: w`\n  * `fix f v = fix f w` if `f v = n+1 :: w` (the exact value of `n` is discarded)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L86-L86","name":"Turing.ToPartrec.instInhabitedCode","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.instInhabitedCode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L86-L86","name":"Turing.ToPartrec.instDecidableEqCode","kind":"instance","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.instDecidableEqCode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L85-L85","name":"Turing.ToPartrec.Code.fix","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.fix","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L84-L84","name":"Turing.ToPartrec.Code.case","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.case","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L83-L83","name":"Turing.ToPartrec.Code.comp","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L82-L82","name":"Turing.ToPartrec.Code.cons","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.cons","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L81-L81","name":"Turing.ToPartrec.Code.tail","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.tail","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L80-L80","name":"Turing.ToPartrec.Code.succ","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.succ","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L79-L79","name":"Turing.ToPartrec.Code.zero'","kind":"ctor","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code.zero'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/TMToPartrec.lean#L78-L86","name":"Turing.ToPartrec.Code","kind":"inductive","docLink":"./Mathlib/Computability/TMToPartrec.html#Turing.ToPartrec.Code","doc":"The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. "}]}