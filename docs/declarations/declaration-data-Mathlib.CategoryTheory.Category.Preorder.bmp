{"name":"Mathlib.CategoryTheory.Category.Preorder","instances":[{"typeNames":[],"name":"Preorder.smallCategory","className":"CategoryTheory.Category"},{"typeNames":["Quiver.Hom","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","Preorder.smallCategory"],"name":"Preorder.Preorder.subsingleton_hom","className":"Subsingleton"},{"typeNames":["Quiver.Hom","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","Preorder.smallCategory","Top.top","OrderTop.toTop","Preorder.toLE"],"name":"CategoryTheory.uniqueToTop","className":"Unique"},{"typeNames":["Quiver.Hom","CategoryTheory.CategoryStruct.toQuiver","CategoryTheory.Category.toCategoryStruct","Preorder.smallCategory","Bot.bot","OrderBot.toBot","Preorder.toLE"],"name":"CategoryTheory.uniqueFromBot","className":"Unique"}],"imports":["Init","Mathlib.CategoryTheory.Equivalence","Mathlib.Order.Hom.Basic","Mathlib.Data.ULift"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L192-L194","name":"CategoryTheory.Equivalence.toOrderIso_symm_apply","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.Equivalence.toOrderIso_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L187-L188","name":"CategoryTheory.Equivalence.toOrderIso_apply","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.Equivalence.toOrderIso_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L173-L181","name":"CategoryTheory.Equivalence.toOrderIso","kind":"def","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.Equivalence.toOrderIso","doc":"A categorical equivalence between partial orders is just an order isomorphism.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L167-L168","name":"CategoryTheory.Iso.to_eq","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.Iso.to_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L158-L158","name":"CategoryTheory.Functor.monotone","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.Functor.monotone","doc":"A functor between preorder categories is monotone.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L143-L144","name":"Monotone.functor_obj","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#Monotone.functor_obj","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L137-L139","name":"Monotone.functor","kind":"def","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#Monotone.functor","doc":"A monotone function between preorders induces a functor between the associated categories.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L124-L126","name":"CategoryTheory.uniqueFromBot","kind":"instance","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.uniqueFromBot","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L119-L121","name":"CategoryTheory.uniqueToTop","kind":"instance","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.uniqueToTop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L115-L116","name":"CategoryTheory.le_of_op_hom","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.le_of_op_hom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L111-L112","name":"CategoryTheory.opHomOfLE","kind":"def","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.opHomOfLE","doc":"Construct a morphism in the opposite of a preorder category from an inequality. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L106-L107","name":"CategoryTheory.homOfLE_leOfHom","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE_leOfHom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L99-L100","name":"CategoryTheory.leOfHom_homOfLE","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.leOfHom_homOfLE","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L94-L94","name":"Quiver.Hom.le","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#Quiver.Hom.le","doc":"**Alias** of `CategoryTheory.leOfHom`."},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L90-L91","name":"CategoryTheory.leOfHom","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.leOfHom","doc":"Extract the underlying inequality from a morphism in a preorder category.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L83-L85","name":"CategoryTheory.homOfLE_comp","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE_comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L78-L79","name":"CategoryTheory.homOfLE_refl","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE_refl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L74-L74","name":"LE.le.hom","kind":"def","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#LE.le.hom","doc":"**Alias** of `CategoryTheory.homOfLE`."},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L70-L71","name":"CategoryTheory.homOfLE","kind":"def","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE","doc":"Express an inequality as a morphism in the corresponding preorder category.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L57-L58","name":"Preorder.Preorder.subsingleton_hom","kind":"instance","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#Preorder.Preorder.subsingleton_hom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Category/Preorder.lean#L50-L53","name":"Preorder.smallCategory","kind":"instance","docLink":"./Mathlib/CategoryTheory/Category/Preorder.html#Preorder.smallCategory","doc":"The category structure coming from a preorder. There is a morphism `X ⟶ Y` if and only if `X ≤ Y`.\n\nBecause we don't allow morphisms to live in `Prop`,\nwe have to define `X ⟶ Y` as `ULift (PLift (X ≤ Y))`.\nSee `CategoryTheory.homOfLE` and `CategoryTheory.leOfHom`.\n\nSee <https://stacks.math.columbia.edu/tag/00D3>.\n"}]}