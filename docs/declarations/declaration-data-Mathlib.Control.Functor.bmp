{"name":"Mathlib.Control.Functor","instances":[{"typeNames":["Functor.Const"],"name":"Functor.Const.functor","className":"Functor"},{"typeNames":["Functor.Const","Functor.Const.functor"],"name":"Functor.Const.lawfulFunctor","className":"LawfulFunctor"},{"typeNames":["Functor.Const"],"name":"Functor.Const.instInhabitedConst","className":"Inhabited"},{"typeNames":["Functor.AddConst"],"name":"Functor.AddConst.functor","className":"Functor"},{"typeNames":["Functor.AddConst","Functor.AddConst.functor"],"name":"Functor.AddConst.lawfulFunctor","className":"LawfulFunctor"},{"typeNames":["Functor.AddConst"],"name":"Functor.instInhabitedAddConst","className":"Inhabited"},{"typeNames":["Functor.Comp"],"name":"Functor.Comp.instInhabitedComp","className":"Inhabited"},{"typeNames":["Functor.Comp"],"name":"Functor.Comp.functor","className":"Functor"},{"typeNames":["Functor.Comp","Functor.Comp.functor"],"name":"Functor.Comp.lawfulFunctor","className":"LawfulFunctor"},{"typeNames":["Functor.Comp"],"name":"Functor.Comp.instPureComp","className":"Pure"},{"typeNames":["Functor.Comp"],"name":"Functor.Comp.instSeqComp","className":"Seq"},{"typeNames":["Functor.Comp"],"name":"Functor.Comp.instApplicativeComp","className":"Applicative"}],"imports":["Init","Mathlib.Control.Basic","Mathlib.Init.Set","Std.Tactic.Lint"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L312-L315","name":"Functor.«term_$>_»","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.«term_$>_»","doc":"If `f` is a functor, if `fb : f β` and `a : α`, then `mapConstRev fb a` is the result of\napplying `f.map` to the constant function `β → α` sending everything to `a`, and then\nevaluating at `fb`. In other words it's `const a <$> fb`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L308-L310","name":"Functor.mapConstRev","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.mapConstRev","doc":"If `f` is a functor, if `fb : f β` and `a : α`, then `mapConstRev fb a` is the result of\napplying `f.map` to the constant function `β → α` sending everything to `a`, and then\nevaluating at `fb`. In other words it's `const a <$> fb`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L301-L302","name":"Functor.of_mem_supp","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.of_mem_supp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L297-L298","name":"Functor.supp","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.supp","doc":"If we consider `x : F α` to, in some sense, contain values of type `α`, then\n`supp x` is the set of values of type `α` that `x` contains. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L289-L292","name":"Functor.Liftr","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Liftr","doc":"If we consider `x : F α` to, in some sense, contain values of type `α`, then\n`Liftr r x y` relates `x` and `y` iff (1) `x` and `y` have the same shape and\n(2) we can pair values `a` from `x` and `b` from `y` so that `r a b` holds. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L282-L283","name":"Functor.Liftp","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Liftp","doc":"If we consider `x : F α` to, in some sense, contain values of type `α`,\npredicate `Liftp p x` holds iff every value contained by `x` satisfies `p`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L273-L274","name":"Functor.Comp.instApplicativeComp","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.instApplicativeComp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L268-L270","name":"Functor.Comp.run_seq","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.run_seq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L263-L264","name":"Functor.Comp.run_pure","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.run_pure","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L259-L260","name":"Functor.Comp.instSeqComp","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.instSeqComp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L256-L257","name":"Functor.Comp.instPureComp","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.instPureComp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L250-L252","name":"Functor.Comp.seq","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.seq","doc":"The `<*>` operation for the composition of applicative functors. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L233-L234","name":"Functor.Comp.functor_id_comp","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.functor_id_comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L227-L229","name":"Functor.Comp.functor_comp_id","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.functor_comp_id","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L221-L224","name":"Functor.Comp.lawfulFunctor","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.lawfulFunctor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L215-L217","name":"Functor.Comp.comp_map","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.comp_map","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L210-L211","name":"Functor.Comp.id_map","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.id_map","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L201-L203","name":"Functor.Comp.run_map","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.run_map","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L196-L197","name":"Functor.Comp.map_mk","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.map_mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L193-L193","name":"Functor.Comp.functor","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.functor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L189-L190","name":"Functor.Comp.map","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.map","doc":"The map operation for the composition `Comp F G` of functors `F` and `G`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L183-L184","name":"Functor.Comp.instInhabitedComp","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.instInhabitedComp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L179-L180","name":"Functor.Comp.ext","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.ext","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L171-L172","name":"Functor.Comp.run","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.run","doc":"Extract a term of `F (G α)` from a term of `Comp F G α`, which is the same type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L166-L167","name":"Functor.Comp.mk","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Comp.mk","doc":"Construct a term of `Comp F G α` from a term of `F (G α)`, which is the same type.\nCan be used as a pattern to extract a term of `F (G α)`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L159-L160","name":"Functor.Comp","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Comp","doc":"`Functor.Comp` is a wrapper around `Function.Comp` for types.\nIt prevents Lean's type class resolution mechanism from trying\na `Functor (Comp F id)` when `Functor F` would do. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L153-L154","name":"Functor.instInhabitedAddConst","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.instInhabitedAddConst","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L149-L150","name":"Functor.AddConst.lawfulFunctor","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.AddConst.lawfulFunctor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L145-L146","name":"Functor.AddConst.functor","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.AddConst.functor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L141-L142","name":"Functor.AddConst.run","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.AddConst.run","doc":"Extract the element of `α` from the constant functor. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L136-L137","name":"Functor.AddConst.mk","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.AddConst.mk","doc":"`AddConst.mk` is the canonical map `α → AddConst α β`, which is the identity,\nwhere `AddConst α β = Const α β`. It can be used as a pattern to extract this value. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L129-L130","name":"Functor.AddConst","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.AddConst","doc":"`AddConst α` is a synonym for constant functor `Const α`, mapping\nevery type to `α`. When `α` has an additive monoid structure,\n`AddConst α` has an `Applicative` instance. (If `α` has a\nmultiplicative monoid structure, see `Functor.Const`.) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L120-L121","name":"Functor.Const.instInhabitedConst","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.Const.instInhabitedConst","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L118-L118","name":"Functor.Const.lawfulFunctor","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.Const.lawfulFunctor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L116-L116","name":"Functor.Const.functor","kind":"instance","docLink":"./Mathlib/Control/Functor.html#Functor.Const.functor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L112-L113","name":"Functor.Const.map","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Const.map","doc":"The map operation of the `Const γ` functor. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L106-L107","name":"Functor.Const.ext","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.Const.ext","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L100-L101","name":"Functor.Const.run","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Const.run","doc":"Extract the element of `α` from the `Const` functor. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L95-L96","name":"Functor.Const.mk'","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Const.mk'","doc":"`Const.mk'` is `Const.mk` but specialized to map `α` to\n`Const α PUnit`, where `PUnit` is the terminal object in `Type _`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L89-L90","name":"Functor.Const.mk","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Const.mk","doc":"`Const.mk` is the canonical map `α → Const α β` (the identity), and\nit can be used as a pattern to extract this value. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L82-L83","name":"Functor.Const","kind":"def","docLink":"./Mathlib/Control/Functor.html#Functor.Const","doc":"`Const α` is the constant functor, mapping every type to `α`. When\n`α` has a monoid structure, `Const α` has an `Applicative` instance.\n(If `α` has an additive monoid structure, see `Functor.AddConst`.) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L72-L73","name":"id.mk","kind":"def","docLink":"./Mathlib/Control/Functor.html#id.mk","doc":"Introduce `id` as a quasi-functor. (Note that where a lawful `Monad` or\n`Applicative` or `Functor` is needed, `Id` is the correct definition). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L55-L65","name":"Functor.ext","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.ext","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L49-L51","name":"Functor.map_comp_map","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.map_comp_map","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Functor.lean#L46-L46","name":"Functor.map_id","kind":"theorem","docLink":"./Mathlib/Control/Functor.html#Functor.map_id","doc":""}]}