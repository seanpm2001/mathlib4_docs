{"name":"Mathlib.Computability.NFA","instances":[{"typeNames":["NFA"],"name":"NFA.instInhabitedNFA","className":"Inhabited"}],"imports":["Init","Mathlib.Computability.DFA","Mathlib.Data.Fintype.Powerset"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L163-L169","name":"DFA.toNFA_correct","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#DFA.toNFA_correct","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L152-L159","name":"DFA.toNFA_evalFrom_match","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#DFA.toNFA_evalFrom_match","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L144-L148","name":"DFA.toNFA","kind":"def","docLink":"./Mathlib/Computability/NFA.html#DFA.toNFA","doc":"`M.toNFA` is an `NFA` constructed from a `DFA` `M` by using the same start and accept\nstates and a transition function which sends `s` with input `a` to the singleton `M.step s a`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L144-L144","name":"DFA.toNFA_start","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#DFA.toNFA_start","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L144-L144","name":"DFA.toNFA_step","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#DFA.toNFA_step","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L144-L144","name":"DFA.toNFA_accept","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#DFA.toNFA_accept","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L129-L135","name":"NFA.pumping_lemma","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.pumping_lemma","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L123-L126","name":"NFA.toDFA_correct","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.toDFA_correct","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L116-L119","name":"NFA.toDFA","kind":"def","docLink":"./Mathlib/Computability/NFA.html#NFA.toDFA","doc":"`M.toDFA` is a `DFA` constructed from a `NFA` `M` using the subset construction. The\nstates is the type of `Set`s of `M.state` and the step function is `M.stepSet`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L112-L112","name":"NFA.mem_accepts","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.mem_accepts","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L109-L109","name":"NFA.accepts","kind":"def","docLink":"./Mathlib/Computability/NFA.html#NFA.accepts","doc":"`M.accepts` is the language of `x` such that there is an accept state in `M.eval x`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L104-L105","name":"NFA.eval_append_singleton","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.eval_append_singleton","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L99-L100","name":"NFA.eval_singleton","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.eval_singleton","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L94-L95","name":"NFA.eval_nil","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.eval_nil","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L89-L90","name":"NFA.eval","kind":"def","docLink":"./Mathlib/Computability/NFA.html#NFA.eval","doc":"`M.eval x` computes all possible paths though `M` with input `x` starting at an element of\n`M.start`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L82-L84","name":"NFA.evalFrom_append_singleton","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.evalFrom_append_singleton","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L77-L78","name":"NFA.evalFrom_singleton","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.evalFrom_singleton","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L72-L73","name":"NFA.evalFrom_nil","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.evalFrom_nil","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L67-L68","name":"NFA.evalFrom","kind":"def","docLink":"./Mathlib/Computability/NFA.html#NFA.evalFrom","doc":"`M.evalFrom S x` computes all possible paths though `M` with input `x` starting at an element\nof `S`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L62-L62","name":"NFA.stepSet_empty","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.stepSet_empty","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L57-L58","name":"NFA.mem_stepSet","kind":"theorem","docLink":"./Mathlib/Computability/NFA.html#NFA.mem_stepSet","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L53-L54","name":"NFA.stepSet","kind":"def","docLink":"./Mathlib/Computability/NFA.html#NFA.stepSet","doc":"`M.stepSet S a` is the union of `M.step s a` for all `s ∈ S`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L49-L50","name":"NFA.instInhabitedNFA","kind":"instance","docLink":"./Mathlib/Computability/NFA.html#NFA.instInhabitedNFA","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L42-L42","name":"NFA.accept","kind":"def","docLink":"./Mathlib/Computability/NFA.html#NFA.accept","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L41-L41","name":"NFA.start","kind":"def","docLink":"./Mathlib/Computability/NFA.html#NFA.start","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L40-L40","name":"NFA.step","kind":"def","docLink":"./Mathlib/Computability/NFA.html#NFA.step","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L39-L39","name":"NFA.mk","kind":"ctor","docLink":"./Mathlib/Computability/NFA.html#NFA.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Computability/NFA.lean#L39-L42","name":"NFA","kind":"structure","docLink":"./Mathlib/Computability/NFA.html#NFA","doc":"An NFA is a set of states (`σ`), a transition function from state to state labelled by the\nalphabet (`step`), a starting state (`start`) and a set of acceptance states (`accept`).\nNote the transition function sends a state to a `Set` of states. These are the states that it\nmay be sent to. "}]}