{"name":"Lean.Meta.Tactic.Apply","instances":[],"imports":["Init","Lean.Util.FindMVar","Lean.Meta.SynthInstance","Lean.Meta.CollectMVars","Lean.Meta.Tactic.Util"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L224-L231","name":"Lean.MVarId.exfalso","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.MVarId.exfalso","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L221-L222","name":"Lean.Meta.splitAnd","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.splitAnd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L217-L218","name":"Lean.MVarId.splitAnd","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.MVarId.splitAnd","doc":"Apply `And.intro` as much as possible to goal `mvarId`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L199-L209","name":"Lean.Meta.splitAndCore.go","kind":"opaque","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.splitAndCore.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L191-L212","name":"Lean.Meta.splitAndCore","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.splitAndCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L188-L189","name":"Lean.Meta.apply","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.apply","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L162-L173","name":"Lean.MVarId.apply.go","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.MVarId.apply.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L130-L185","name":"Lean.MVarId.apply","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.MVarId.apply","doc":"Close the given goal using `apply e`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L87-L91","name":"Lean.Meta.postprocessAppMVars","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.postprocessAppMVars","doc":"If `synthAssignedInstances` is `true`, then `apply` will synthesize instance implicit arguments\neven if they have assigned by `isDefEq`, and then check whether the synthesized value matches the\none inferred. The `congr` tactic sets this flag to false.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L68-L80","name":"Lean.Meta.appendParentTag","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.appendParentTag","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L55-L66","name":"Lean.Meta.synthAppInstances","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.synthAppInstances","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L48-L50","name":"Lean.Meta.getExpectedNumArgs","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.getExpectedNumArgs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L44-L46","name":"Lean.Meta.getExpectedNumArgsAux","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.getExpectedNumArgsAux","doc":"Compute the number of expected arguments and whether the result type is of the form\n(?m ...) where ?m is an unassigned metavariable.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L38-L38","name":"Lean.Meta.ApplyConfig.approx","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig.approx","doc":"If `approx := true`, then we turn on `isDefEq` approximations. That is, we use\nthe `approxDefEq` combinator.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L33-L33","name":"Lean.Meta.ApplyConfig.allowSynthFailures","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig.allowSynthFailures","doc":"If `allowSynthFailures` is `true`, then `apply` will return instance implicit arguments\nfor which typeclass search failed as new goals.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L28-L28","name":"Lean.Meta.ApplyConfig.synthAssignedInstances","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig.synthAssignedInstances","doc":"If `synthAssignedInstances` is `true`, then `apply` will synthesize instance implicit arguments\neven if they have assigned by `isDefEq`, and then check whether the synthesized value matches the\none inferred. The `congr` tactic sets this flag to false.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L22-L22","name":"Lean.Meta.ApplyConfig.newGoals","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig.newGoals","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L21-L38","name":"Lean.Meta.ApplyConfig","kind":"structure","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig","doc":"Configures the behaviour of the `apply` tactic. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L18-L18","name":"Lean.Meta.ApplyNewGoals.all","kind":"ctor","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.all","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L18-L18","name":"Lean.Meta.ApplyNewGoals.nonDependentOnly","kind":"ctor","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentOnly","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L18-L18","name":"Lean.Meta.ApplyNewGoals.nonDependentFirst","kind":"ctor","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L17-L18","name":"Lean.Meta.ApplyNewGoals","kind":"inductive","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals","doc":"Controls which new mvars are turned in to goals by the `apply` tactic.\n- `nonDependentFirst`  mvars that don't depend on other goals appear first in the goal list.\n- `nonDependentOnly` only mvars that don't depend on other goals are added to goal list.\n- `all` all unassigned mvars are added to the goal list.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Tactic/Apply.lean#L1-L1","name":"Lean.Meta.ApplyConfig.mk","kind":"ctor","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig.mk","doc":""}]}