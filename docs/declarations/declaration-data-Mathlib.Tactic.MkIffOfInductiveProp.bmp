{"name":"Mathlib.Tactic.MkIffOfInductiveProp","instances":[],"imports":["Init","Lean","Mathlib.Lean.Meta","Mathlib.Tactic.LeftRight"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L369-L388","name":"Mathlib.Tactic.MkIff.mkIffOfInductiveProp","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductiveProp","doc":"`mk_iff_of_inductive_prop i r` makes an `iff` rule for the inductively-defined proposition `i`.\nThe new rule `r` has the shape `∀ps is, i as ↔ ⋁_j, ∃cs, is = cs`, where `ps` are the type\nparameters, `is` are the indices, `j` ranges over all possible constructors, the `cs` are the\nparameters for each of the constructors, and the equalities `is = cs` are the instantiations for\neach constructor for each of the indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, `mk_iff_of_inductive_prop` on `List.Chain` produces:\n\n```lean\n∀ { α : Type _} (R : α → α → Prop) (a : α) (l : List α),\n  Chain R a l ↔ l = [] ∨ ∃(b : α) (l' : List α), R a b ∧ Chain R b l ∧ l = b :: l'\n```\n\nSee also the `mk_iff` user attribute.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L328-L367","name":"Mathlib.Tactic.MkIff.mkIff","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIff","doc":"Applying the `mk_iff` attribute to an inductively-defined proposition `mk_iff` makes an `iff` rule\n`r` with the shape `∀ps is, i as ↔ ⋁_j, ∃cs, is = cs`, where `ps` are the type parameters, `is` are\nthe indices, `j` ranges over all possible constructors, the `cs` are the parameters for each of the\nconstructors, and the equalities `is = cs` are the instantiations for each constructor for each of\nthe indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, if we try the following:\n```lean\n@[mk_iff]\nstructure Foo (m n : Nat) : Prop where\n  equal : m = n\n  sum_eq_two : m + n = 2\n```\n\nThen `#check Foo_iff` returns:\n```lean\nFoo_iff : ∀ (m n : Nat), Foo m n ↔ m = n ∧ m + n = 2\n```\n\nYou can add an optional string after `mk_iff` to change the name of the generated lemma.\nFor example, if we try the following:\n```lean\n@[mk_iff bar]\nstructure Foo (m n : Nat) : Prop where\n  equal : m = n\n  sum_eq_two : m + n = 2\n```\n\nThen `#check bar` returns:\n```lean\nbar : ∀ (m n : ℕ), Foo m n ↔ m = n ∧ m + n = 2\n```\n\nSee also the user command `mk_iff_of_inductive_prop`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L285-L326","name":"Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl","doc":"Implementation for both `mk_iff` and `mk_iff_of_inductive_prop`.y\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L240-L281","name":"Mathlib.Tactic.MkIff.toInductive","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toInductive","doc":"Proves the right to left direction of a generated iff theorem.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L232-L236","name":"Mathlib.Tactic.MkIff.listBoolMerge","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge","doc":"Iterate over two lists, if the first element of the first list is `false`, insert `none` into the\nresult and continue with the tail of first list. Otherwise, wrap the first element of the second\nlist with `some` and continue with the tails of both lists. Return when either list is empty.\n\nExample:\n```\nlistBoolMerge [false, true, false, true] [0, 1, 2, 3, 4] = [none, (some 0), none, (some 1)]\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L213-L220","name":"Mathlib.Tactic.MkIff.nCasesProd","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesProd","doc":"Calls `cases` on `h` (assumed to be a binary product) `n` times, and returns\nthe resulting subgoal and the new hypotheses.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L200-L208","name":"Mathlib.Tactic.MkIff.nCasesSum","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesSum","doc":"Calls `cases` on `h` (assumed to be a binary sum) `n` times, and returns\nthe resulting subgoals and their corresponding new hypotheses.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L179-L195","name":"Mathlib.Tactic.MkIff.toCases","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toCases","doc":"Proves the left to right direction of a generated iff theorem.\n`shape` is the output of a call to `constrToProp`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L160-L174","name":"Mathlib.Tactic.MkIff.splitThenConstructor","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.splitThenConstructor","doc":"Splits the goal `n` times via `refine ⟨?_,?_⟩`, and then applies `constructor` to\nclose the resulting subgoals.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L124-L155","name":"Mathlib.Tactic.MkIff.constrToProp","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.constrToProp","doc":"Converts an inductive constructor `c` into a `Shape` that will be used later in\nwhile proving the iff theorem, and a proposition representing the constructor.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L119-L119","name":"Mathlib.Tactic.MkIff.Shape.neqs","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.neqs","doc":"The number of equalities, or `none` in the case when we've reduced something\nof the form `p ∧ True` to just `p`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L114-L114","name":"Mathlib.Tactic.MkIff.Shape.variablesKept","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.variablesKept","doc":"For each forall-bound variable in the type of the constructor, minus\nthe \"params\" that apply to the entire inductive type, this list contains `true`\nif that variable has been kept after `compactRelation`.\n\nFor example, `List.Chain.nil` has type\n```lean\n  ∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []`\n```\nand the first two variables `α` and `R` are \"params\", while the `a : α` gets\neliminated in a `compactRelation`, so `variablesKept = [false]`.\n\n`List.Chain.cons` has type\n```lean\n  ∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α},\n     R a b → List.Chain R b l → List.Chain R a (b :: l)\n```\nand the `a : α` gets eliminated, so `compactRelation = [false,true,true,true,true]`.\n "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L95-L119","name":"Mathlib.Tactic.MkIff.Shape","kind":"structure","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape","doc":"Auxiliary data associated with a single constructor of an inductive declaration.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L88-L91","name":"Mathlib.Tactic.MkIff.List.init","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.List.init","doc":"Drops the final element of a list. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L85-L85","name":"Mathlib.Tactic.MkIff.mkOrList","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOrList","doc":"`mkOrList [x1, x2, ...]` is defined as `x1 ∨ (x2 ∨ ...)`, or `False` if the list is empty. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L82-L82","name":"Mathlib.Tactic.MkIff.mkAndList","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkAndList","doc":"`mkAndList [x1, x2, ...]` is defined as `x1 ∧ (x2 ∧ ...)`, or `True` if the list is empty. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L76-L79","name":"Mathlib.Tactic.MkIff.mkOpList","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList","doc":"`mkOpList op empty [x1, x2, ...]` is defined as `op x1 (op x2 ...)`.\nReturns `empty` if the list is empty. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L65-L72","name":"Mathlib.Tactic.MkIff.mkExistsList","kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkExistsList","doc":"Generates an expression of the form `∃(args), inner`. `args` is assumed to be a list of fvars.\nWhen possible, `p ∧ q` is used instead of `∃(_ : p), q`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L50-L61","name":"Mathlib.Tactic.MkIff.compactRelation","kind":"opaque","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.compactRelation","doc":"`compactRelation bs as_ps`: Produce a relation of the form:\n```lean\nR := λ as ∃ bs, Λ_i a_i = p_i[bs]\n```\nThis relation is user-visible, so we compact it by removing each `b_j` where a `p_i = b_j`, and\nhence `a_i = b_j`. We need to take care when there are `p_i` and `p_j` with `p_i = p_j = b_k`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/MkIffOfInductiveProp.lean#L1-L1","name":"Mathlib.Tactic.MkIff.Shape.mk","kind":"ctor","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.mk","doc":""}]}