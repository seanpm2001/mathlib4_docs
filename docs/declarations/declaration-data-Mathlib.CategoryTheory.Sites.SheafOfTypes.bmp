{"name":"Mathlib.CategoryTheory.Sites.SheafOfTypes","instances":[{"typeNames":["CategoryTheory.Presieve.FamilyOfElements","Bot.bot","CategoryTheory.Presieve","CompleteLattice.toBot","CategoryTheory.instCompleteLatticePresieve"],"name":"CategoryTheory.Presieve.instInhabitedFamilyOfElementsBotPresieveToBotInstCompleteLatticePresieve","className":"Inhabited"},{"typeNames":["CategoryTheory.Equalizer.FirstObj","Bot.bot","CategoryTheory.Presieve","CompleteLattice.toBot","CategoryTheory.instCompleteLatticePresieve"],"name":"CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieveToBotInstCompleteLatticePresieve","className":"Inhabited"},{"typeNames":["CategoryTheory.Equalizer.FirstObj","CategoryTheory.Sieve.arrows","Bot.bot","CategoryTheory.Sieve","CompleteLattice.toBot","CategoryTheory.Sieve.instCompleteLatticeSieve"],"name":"CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieveToBotInstCompleteLatticeSieve","className":"Inhabited"},{"typeNames":["CategoryTheory.Equalizer.Sieve.SecondObj","Bot.bot","CategoryTheory.Sieve","CompleteLattice.toBot","CategoryTheory.Sieve.instCompleteLatticeSieve"],"name":"CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieveToBotInstCompleteLatticeSieve","className":"Inhabited"},{"typeNames":["CategoryTheory.Equalizer.Presieve.SecondObj","Bot.bot","CategoryTheory.Presieve","CompleteLattice.toBot","CategoryTheory.instCompleteLatticePresieve"],"name":"CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieveToBotInstCompleteLatticePresieve","className":"Inhabited"},{"typeNames":["CategoryTheory.SheafOfTypes"],"name":"CategoryTheory.SheafOfTypes.instCategorySheafOfTypes","className":"CategoryTheory.Category"},{"typeNames":["CategoryTheory.SheafOfTypes.Hom"],"name":"CategoryTheory.SheafOfTypes.instInhabitedHom","className":"Inhabited"},{"typeNames":["CategoryTheory.SheafOfTypes","CategoryTheory.SheafOfTypes.instCategorySheafOfTypes","CategoryTheory.Functor","Opposite","CategoryTheory.Category.opposite","_builtin_typeu","CategoryTheory.types","CategoryTheory.Functor.category","Opposite","CategoryTheory.Category.opposite","_builtin_typeu","CategoryTheory.types","CategoryTheory.sheafOfTypesToPresheaf"],"name":"CategoryTheory.instFullSheafOfTypesInstCategorySheafOfTypesFunctorOppositeOppositeTypeTypesCategorySheafOfTypesToPresheaf","className":"CategoryTheory.Full"},{"typeNames":["CategoryTheory.SheafOfTypes","CategoryTheory.SheafOfTypes.instCategorySheafOfTypes","CategoryTheory.Functor","Opposite","CategoryTheory.Category.opposite","_builtin_typeu","CategoryTheory.types","CategoryTheory.Functor.category","Opposite","CategoryTheory.Category.opposite","_builtin_typeu","CategoryTheory.types","CategoryTheory.sheafOfTypesToPresheaf"],"name":"CategoryTheory.instFaithfulSheafOfTypesInstCategorySheafOfTypesFunctorOppositeOppositeTypeTypesCategorySheafOfTypesToPresheaf","className":"CategoryTheory.Faithful"},{"typeNames":["CategoryTheory.SheafOfTypes","Bot.bot","CategoryTheory.GrothendieckTopology","CompleteLattice.toBot","CategoryTheory.GrothendieckTopology.instCompleteLatticeGrothendieckTopology"],"name":"CategoryTheory.instInhabitedSheafOfTypesBotGrothendieckTopologyToBotInstCompleteLatticeGrothendieckTopology","className":"Inhabited"}],"imports":["Init","Mathlib.CategoryTheory.Sites.Pretopology","Mathlib.CategoryTheory.Limits.Shapes.Types"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1088-L1089","name":"CategoryTheory.instInhabitedSheafOfTypesBotGrothendieckTopologyToBotInstCompleteLatticeGrothendieckTopology","kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.instInhabitedSheafOfTypesBotGrothendieckTopologyToBotInstCompleteLatticeGrothendieckTopology","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1076-L1084","name":"CategoryTheory.sheafOfTypesBotEquiv","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.sheafOfTypesBotEquiv","doc":"The category of sheaves on the bottom (trivial) grothendieck topology is equivalent to the category\nof presheaves.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1075-L1075","name":"CategoryTheory.sheafOfTypesBotEquiv_unitIso_hom_app_val","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.sheafOfTypesBotEquiv_unitIso_hom_app_val","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1075-L1075","name":"CategoryTheory.sheafOfTypesBotEquiv_inverse_obj_val","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.sheafOfTypesBotEquiv_inverse_obj_val","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1075-L1075","name":"CategoryTheory.sheafOfTypesBotEquiv_inverse_map","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.sheafOfTypesBotEquiv_inverse_map","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1075-L1075","name":"CategoryTheory.sheafOfTypesBotEquiv_unitIso_inv_app_val","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.sheafOfTypesBotEquiv_unitIso_inv_app_val","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1075-L1075","name":"CategoryTheory.sheafOfTypesBotEquiv_counitIso","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.sheafOfTypesBotEquiv_counitIso","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1075-L1075","name":"CategoryTheory.sheafOfTypesBotEquiv_functor","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.sheafOfTypesBotEquiv_functor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1069-L1069","name":"CategoryTheory.instFaithfulSheafOfTypesInstCategorySheafOfTypesFunctorOppositeOppositeTypeTypesCategorySheafOfTypesToPresheaf","kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.instFaithfulSheafOfTypesInstCategorySheafOfTypesFunctorOppositeOppositeTypeTypesCategorySheafOfTypesToPresheaf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1067-L1067","name":"CategoryTheory.instFullSheafOfTypesInstCategorySheafOfTypesFunctorOppositeOppositeTypeTypesCategorySheafOfTypesToPresheaf","kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.instFullSheafOfTypesInstCategorySheafOfTypesFunctorOppositeOppositeTypeTypesCategorySheafOfTypesToPresheaf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1059-L1063","name":"CategoryTheory.sheafOfTypesToPresheaf","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.sheafOfTypesToPresheaf","doc":"The inclusion functor from sheaves to presheaves. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1058-L1058","name":"CategoryTheory.sheafOfTypesToPresheaf_obj","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.sheafOfTypesToPresheaf_obj","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1058-L1058","name":"CategoryTheory.sheafOfTypesToPresheaf_map","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.sheafOfTypesToPresheaf_map","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1052-L1053","name":"CategoryTheory.SheafOfTypes.instInhabitedHom","kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.instInhabitedHom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1048-L1049","name":"CategoryTheory.SheafOfTypes.Hom.ext'","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.Hom.ext'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1036-L1042","name":"CategoryTheory.SheafOfTypes.instCategorySheafOfTypes","kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.instCategorySheafOfTypes","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1035-L1035","name":"CategoryTheory.SheafOfTypes.instCategorySheafOfTypes_id_val","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.instCategorySheafOfTypes_id_val","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1035-L1035","name":"CategoryTheory.SheafOfTypes.instCategorySheafOfTypes_comp_val","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.instCategorySheafOfTypes_comp_val","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1031-L1031","name":"CategoryTheory.SheafOfTypes.Hom.val","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.Hom.val","doc":"a morphism between the underlying presheaves "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1029-L1029","name":"CategoryTheory.SheafOfTypes.Hom.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.Hom.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1029-L1031","name":"CategoryTheory.SheafOfTypes.Hom","kind":"structure","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.Hom","doc":"Morphisms between sheaves of types are just morphisms between the underlying presheaves. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1028-L1028","name":"CategoryTheory.SheafOfTypes.Hom.ext","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.Hom.ext","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1028-L1028","name":"CategoryTheory.SheafOfTypes.Hom.ext_iff","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.Hom.ext_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1019-L1019","name":"CategoryTheory.SheafOfTypes.cond","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.cond","doc":"the condition that the presheaf is a sheaf "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1017-L1017","name":"CategoryTheory.SheafOfTypes.val","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.val","doc":"the underlying presheaf "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1015-L1015","name":"CategoryTheory.SheafOfTypes.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L1015-L1019","name":"CategoryTheory.SheafOfTypes","kind":"structure","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.SheafOfTypes","doc":"The category of sheaves on a grothendieck topology. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L986-L1001","name":"CategoryTheory.Equalizer.Presieve.sheaf_condition","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Presieve.sheaf_condition","doc":"`P` is a sheaf for `R`, iff the fork given by `w` is an equalizer.\nSee <https://stacks.math.columbia.edu/tag/00VM>.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L970-L980","name":"CategoryTheory.Equalizer.Presieve.compatible_iff","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Presieve.compatible_iff","doc":"The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L957-L963","name":"CategoryTheory.Equalizer.Presieve.w","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Presieve.w","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L953-L954","name":"CategoryTheory.Equalizer.Presieve.secondMap","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Presieve.secondMap","doc":"The map `pr₁*` of <https://stacks.math.columbia.edu/tag/00VL>. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L949-L950","name":"CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieveToBotInstCompleteLatticePresieve","kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieveToBotInstCompleteLatticePresieve","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L945-L946","name":"CategoryTheory.Equalizer.Presieve.firstMap","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Presieve.firstMap","doc":"The map `pr₀*` of <https://stacks.math.columbia.edu/tag/00VL>. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L939-L941","name":"CategoryTheory.Equalizer.Presieve.SecondObj","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Presieve.SecondObj","doc":"The rightmost object of the fork diagram of https://stacks.math.columbia.edu/tag/00VM, which\ncontains the data used to check a family of elements for a presieve is compatible.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L903-L921","name":"CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition","doc":"`P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L889-L899","name":"CategoryTheory.Equalizer.Sieve.compatible_iff","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Sieve.compatible_iff","doc":"The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L880-L882","name":"CategoryTheory.Equalizer.Sieve.w","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Sieve.w","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L876-L877","name":"CategoryTheory.Equalizer.Sieve.secondMap","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Sieve.secondMap","doc":"The map `a` of Equations (3,4) [MM92]. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L872-L873","name":"CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieveToBotInstCompleteLatticeSieve","kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieveToBotInstCompleteLatticeSieve","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L867-L869","name":"CategoryTheory.Equalizer.Sieve.firstMap","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Sieve.firstMap","doc":"The map `p` of Equations (3,4) [MM92]. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L857-L862","name":"CategoryTheory.Equalizer.Sieve.SecondObj.ext","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Sieve.SecondObj.ext","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L849-L850","name":"CategoryTheory.Equalizer.Sieve.SecondObj","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.Sieve.SecondObj","doc":"The rightmost object of the fork diagram of Equation (3) [MM92], which contains the data used\nto check a family is compatible.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L834-L835","name":"CategoryTheory.Equalizer.forkMap","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.forkMap","doc":"The left morphism of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram\nof <https://stacks.math.columbia.edu/tag/00VM>.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L827-L828","name":"CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieveToBotInstCompleteLatticeSieve","kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieveToBotInstCompleteLatticeSieve","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L823-L824","name":"CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieveToBotInstCompleteLatticePresieve","kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieveToBotInstCompleteLatticePresieve","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L818-L820","name":"CategoryTheory.Equalizer.firstObjEqFamily","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.firstObjEqFamily","doc":"Show that `FirstObj` is isomorphic to `FamilyOfElements`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L817-L817","name":"CategoryTheory.Equalizer.firstObjEqFamily_hom","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.firstObjEqFamily_hom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L817-L817","name":"CategoryTheory.Equalizer.firstObjEqFamily_inv","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.firstObjEqFamily_inv","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L807-L812","name":"CategoryTheory.Equalizer.FirstObj.ext","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.FirstObj.ext","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L799-L800","name":"CategoryTheory.Equalizer.FirstObj","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Equalizer.FirstObj","doc":"The middle object of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram\nof <https://stacks.math.columbia.edu/tag/00VM>.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L782-L783","name":"CategoryTheory.Presieve.isSheaf_bot","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheaf_bot","doc":"Any presheaf is a sheaf for the bottom (trivial) grothendieck topology. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L765-L778","name":"CategoryTheory.Presieve.isSheaf_pretopology","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheaf_pretopology","doc":"For a topology generated by a basis, it suffices to check the sheaf condition on the basis\npresieves only.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L757-L759","name":"CategoryTheory.Presieve.isSheaf_of_yoneda","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheaf_of_yoneda","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L753-L754","name":"CategoryTheory.Presieve.isSheaf_iso","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheaf_iso","doc":"The property of being a sheaf is preserved by isomorphism. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L748-L749","name":"CategoryTheory.Presieve.isSeparated_of_isSheaf","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSeparated_of_isSheaf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L744-L745","name":"CategoryTheory.Presieve.isSheaf_of_le","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheaf_of_le","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L739-L741","name":"CategoryTheory.Presieve.IsSheaf.isSheafFor","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf.isSheafFor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L735-L736","name":"CategoryTheory.Presieve.IsSheaf","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf","doc":"A presheaf is a sheaf for a topology if it is a sheaf for every sieve in the topology.\n\nIf the given topology is given by a pretopology, `isSheaf_pretopology` shows it suffices to\ncheck the sheaf condition at presieves in the pretopology.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L726-L727","name":"CategoryTheory.Presieve.IsSeparated","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSeparated","doc":"A presheaf is separated for a topology if it is separated for every sieve in the topology. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L718-L722","name":"CategoryTheory.Presieve.isSheafFor_subsieve","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheafFor_subsieve","doc":"If `P` is a sheaf for every pullback of the sieve `S`, then `P` is a sheaf for any presieve which\ncontains `S`.\nThis is closely related to [Elephant] C2.1.6.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L693-L710","name":"CategoryTheory.Presieve.isSheafFor_subsieve_aux","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheafFor_subsieve_aux","doc":"If a presieve `R` on `X` has a subsieve `S` such that:\n\n* `P` is a sheaf for `S`.\n* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,\n\nthen `P` is a sheaf for `R`.\n\nThis is closely related to [Elephant] C2.1.6(i).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L670-L681","name":"CategoryTheory.Presieve.isSheafFor_iso","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheafFor_iso","doc":"If `P` is a sheaf for `S`, and it is iso to `P'`, then `P'` is a sheaf for `S`. This shows that\n\"being a sheaf for a presieve\" is a mathematical or hygienic property.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L661-L664","name":"CategoryTheory.Presieve.isSheafFor_top_sieve","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheafFor_top_sieve","doc":"Every presheaf is a sheaf for the maximal sieve.\n\n[Elephant] C2.1.5(ii)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L648-L654","name":"CategoryTheory.Presieve.isSheafFor_singleton_iso","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheafFor_singleton_iso","doc":"Every presheaf is a sheaf for the family {𝟙 X}.\n\n[Elephant] C2.1.5(i)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L627-L641","name":"CategoryTheory.Presieve.isSheafFor_iff_generate","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheafFor_iff_generate","doc":"C2.1.3 in [Elephant] "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L621-L623","name":"CategoryTheory.Presieve.IsSheafFor.valid_glue","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheafFor.valid_glue","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L615-L617","name":"CategoryTheory.Presieve.IsSheafFor.isAmalgamation","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheafFor.isAmalgamation","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L610-L612","name":"CategoryTheory.Presieve.IsSheafFor.amalgamate","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheafFor.amalgamate","doc":"Get the amalgamation of the given compatible family, provided we have a sheaf. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L605-L606","name":"CategoryTheory.Presieve.IsSheafFor.isSeparatedFor","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheafFor.isSeparatedFor","doc":"If `P` is a sheaf for `R`, it is separated for `R`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L598-L601","name":"CategoryTheory.Presieve.IsSeparatedFor.isSheafFor","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSeparatedFor.isSheafFor","doc":"If `P` is separated for `R` and every family has an amalgamation, then `P` is a sheaf for `R`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L580-L593","name":"CategoryTheory.Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor","doc":"`P` is a sheaf for `R` iff it is separated for `R` and there exists an amalgamation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L573-L576","name":"CategoryTheory.Presieve.IsSheafFor.hom_ext","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheafFor.hom_ext","doc":"If `P` is a sheaf for the sieve `S` on `X`, then if two natural transformations from `yoneda.obj X`\nto `P` agree when restricted to the subfunctor given by `S`, they are equal.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L564-L566","name":"CategoryTheory.Presieve.IsSheafFor.unique_extend","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheafFor.unique_extend","doc":"The extension of `f` to `yoneda.obj X` is unique. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L558-L560","name":"CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend","doc":"Show that the extension of `f : S.functor ⟶ P` to all of `yoneda.obj X` is in fact an extension, ie\nthat the triangle below commutes, provided `P` is a sheaf for `S`\n\n      f\n   S  →  P\n   ↓  ↗\n   yX\n\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L557-L557","name":"CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend_assoc","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend_assoc","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L542-L544","name":"CategoryTheory.Presieve.IsSheafFor.extend","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheafFor.extend","doc":"If `P` is a sheaf for the sieve `S` on `X`, a natural transformation from `S` (viewed as a functor)\nto `P` can be (uniquely) extended to all of `yoneda.obj X`.\n\n      f\n   S  →  P\n   ↓  ↗\n   yX\n\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L520-L529","name":"CategoryTheory.Presieve.isSheafFor_iff_yonedaSheafCondition","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSheafFor_iff_yonedaSheafCondition","doc":"The yoneda version of the sheaf condition is equivalent to the sheaf condition.\n\nC2.1.4 of [Elephant].\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L499-L513","name":"CategoryTheory.Presieve.extension_iff_amalgamation","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.extension_iff_amalgamation","doc":"(Implementation). A lemma useful to prove `isSheafFor_iff_yonedaSheafCondition`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L475-L495","name":"CategoryTheory.Presieve.natTransEquivCompatibleFamily","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.natTransEquivCompatibleFamily","doc":"(Implementation). This is a (primarily internal) equivalence between natural transformations\nand compatible families.\n\nCf the discussion after Lemma 7.47.10 in <https://stacks.math.columbia.edu/tag/00YW>. See also\nthe proof of C2.1.4 of [Elephant], and the discussion in [MM92], Chapter III, Section 4.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L463-L464","name":"CategoryTheory.Presieve.YonedaSheafCondition","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.YonedaSheafCondition","doc":"This is an equivalent condition to be a sheaf, which is useful for the abstraction to local\noperators on elementary toposes. However this definition is defined only for sieves, not presieves.\nThe equivalence between this and `IsSheafFor` is given in `isSheafFor_iff_yonedaSheafCondition`.\nThis version is also useful to establish that being a sheaf is preserved under isomorphism of\npresheaves.\n\nSee the discussion before Equation (3) of [MM92], Chapter III, Section 4. See also C2.1.4 of\n[Elephant]. This is also a direct reformulation of <https://stacks.math.columbia.edu/tag/00Z8>.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L450-L451","name":"CategoryTheory.Presieve.IsSheafFor","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheafFor","doc":"We define `P` to be a sheaf for the presieve `R` if every compatible family has a unique\namalgamation.\n\nThis is the definition of a sheaf for the given presieve given in C2.1.2 of [Elephant], and\nhttps://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents.\nUsing `compatible_iff_sieveCompatible`,\nthis is equivalent to the definition of a sheaf in [MM92], Chapter III, Section 4.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L434-L439","name":"CategoryTheory.Presieve.isSeparatedFor_top","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSeparatedFor_top","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L421-L431","name":"CategoryTheory.Presieve.isSeparatedFor_iff_generate","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isSeparatedFor_iff_generate","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L416-L418","name":"CategoryTheory.Presieve.IsSeparatedFor.ext","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSeparatedFor.ext","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L412-L413","name":"CategoryTheory.Presieve.IsSeparatedFor","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSeparatedFor","doc":"A presheaf is separated for a presieve if there is at most one amalgamation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L404-L408","name":"CategoryTheory.Presieve.isAmalgamation_sieveExtend","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isAmalgamation_sieveExtend","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L399-L401","name":"CategoryTheory.Presieve.isAmalgamation_restrict","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.isAmalgamation_restrict","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L391-L396","name":"CategoryTheory.Presieve.is_compatible_of_exists_amalgamation","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.is_compatible_of_exists_amalgamation","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L383-L388","name":"CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.compPresheafMap","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.compPresheafMap","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L379-L380","name":"CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation","doc":"The given element `t` of `P.obj (op X)` is an *amalgamation* for the family of elements `x` if every\nrestriction `P.map f.op t = x_f` for every arrow `f` in the presieve `R`.\n\nThis is the definition given in  https://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents,\nand https://ncatlab.org/nlab/show/matching+family, as well as [MM92], Chapter III, Section 4,\nequation (2).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L364-L368","name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.compPresheafMap","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.Compatible.compPresheafMap","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L359-L361","name":"CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_comp","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L353-L355","name":"CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_id","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_id","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L348-L349","name":"CategoryTheory.Presieve.FamilyOfElements.compPresheafMap","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.compPresheafMap","doc":"Given a morphism of presheaves `f : P ⟶ Q`, we can take a family of elements valued in `P` to a\nfamily of elements valued in `Q` by composing with `f`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L333-L340","name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.pullback","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.Compatible.pullback","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L329-L330","name":"CategoryTheory.Presieve.FamilyOfElements.pullback","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.pullback","doc":"Given a family of elements of a sieve `S` on `X`, and a map `Y ⟶ X`, we can obtain a\nfamily of elements of `S.pullback f` by taking the same elements.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L317-L321","name":"CategoryTheory.Presieve.FamilyOfElements.functorPushforward","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.functorPushforward","doc":"Given a family of elements of a sieve `S` on `X` whose values factors through `F`, we can\nrealize it as a family of elements of `S.functorPushforward F`. Since the preimage is obtained by\nchoice, this is not well-defined generally.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L305-L308","name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.functorPullback","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.Compatible.functorPullback","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L301-L302","name":"CategoryTheory.Presieve.FamilyOfElements.functorPullback","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.functorPullback","doc":"Given a family of elements of a sieve `S` on `F(X)`, we can realize it as a family of elements of\n`S.functorPullback F`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L285-L288","name":"CategoryTheory.Presieve.FamilyOfElements.comp_of_compatible","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.comp_of_compatible","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L276-L282","name":"CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible","doc":"Compatible families of elements for a presheaf of types `P` and a presieve `R`\nare in 1-1 correspondence with compatible families for the same presheaf and\nthe sieve generated by `R`, through extension and restriction. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L275-L275","name":"CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible_apply_coe","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible_apply_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L275-L275","name":"CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible_symm_apply_coe","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible_symm_apply_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L263-L269","name":"CategoryTheory.Presieve.restrict_inj","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.restrict_inj","doc":"Two compatible families on the sieve generated by a presieve `R` are equal if and only if they are\nequal when restricted to `R`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L250-L256","name":"CategoryTheory.Presieve.extend_restrict","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.extend_restrict","doc":"Given a family of elements `x` for the sieve `S` generated by a presieve `R`, if `x` is restricted\nto `R` and then extended back up to `S`, the resulting extension equals `x`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L240-L242","name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.to_sieveCompatible","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.Compatible.to_sieveCompatible","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L230-L237","name":"CategoryTheory.Presieve.compatible_iff_sieveCompatible","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.compatible_iff_sieveCompatible","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L226-L227","name":"CategoryTheory.Presieve.FamilyOfElements.SieveCompatible","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.SieveCompatible","doc":"If the arrow set for a family of elements is actually a sieve (i.e. it is downward closed) then the\nconsistency condition can be simplified.\nThis is an equivalent condition, see `compatible_iff_sieveCompatible`.\n\nThis is the notion of \"matching\" given for families on sieves given in [MM92], Chapter III,\nSection 4, Equation 1, and nlab: https://ncatlab.org/nlab/show/matching+family.\nSee also the discussion before Lemma C2.1.4 of [Elephant].\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L211-L214","name":"CategoryTheory.Presieve.restrict_extend","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.restrict_extend","doc":"The restriction of an extension is the original. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L199-L206","name":"CategoryTheory.Presieve.extend_agrees","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.extend_agrees","doc":"The extension of a family agrees with the original family. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L190-L195","name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.sieveExtend","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.Compatible.sieveExtend","doc":"The extension of a compatible family to the generated sieve is compatible. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L184-L186","name":"CategoryTheory.Presieve.FamilyOfElements.sieveExtend","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.sieveExtend","doc":"Extend a family of elements to the sieve generated by an arrow set.\nThis is the construction described as \"easy\" in Lemma C2.1.3 of [Elephant].\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L176-L178","name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.restrict","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.Compatible.restrict","doc":"The restriction of a compatible family is compatible. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L164-L172","name":"CategoryTheory.Presieve.pullbackCompatible_iff","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.pullbackCompatible_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L159-L161","name":"CategoryTheory.Presieve.FamilyOfElements.PullbackCompatible","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.PullbackCompatible","doc":"If the category `C` has pullbacks, this is an alternative condition for a family of elements to be\ncompatible: For any `f : Y ⟶ X` and `g : Z ⟶ X` in the presieve `R`, the restriction of the\ngiven elements for `f` and `g` to the pullback agree.\nThis is equivalent to being compatible (provided `C` has pullbacks), shown in\n`pullbackCompatible_iff`.\n\nThis is the definition for a \"matching\" family given in [MM92], Chapter III, Section 4,\nEquation (5). Viewing the type `FamilyOfElements` as the middle object of the fork in\nhttps://stacks.math.columbia.edu/tag/00VM, this condition expresses that `pr₀* (x) = pr₁* (x)`,\nusing the notation defined there.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L142-L144","name":"CategoryTheory.Presieve.FamilyOfElements.Compatible","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.Compatible","doc":"A family of elements for the arrow set `R` is *compatible* if for any `f₁ : Y₁ ⟶ X` and\n`f₂ : Y₂ ⟶ X` in `R`, and any `g₁ : Z ⟶ Y₁` and `g₂ : Z ⟶ Y₂`, if the square `g₁ ≫ f₁ = g₂ ≫ f₂`\ncommutes then the elements of `P Z` obtained by restricting the element of `P Y₁` along `g₁` and\nrestricting the element of `P Y₂` along `g₂` are the same.\n\nIn special cases, this condition can be simplified, see `pullbackCompatible_iff` and\n`compatible_iff_sieveCompatible`.\n\nThis is referred to as a \"compatible family\" in Definition C2.1.2 of [Elephant], and on nlab:\nhttps://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L127-L128","name":"CategoryTheory.Presieve.FamilyOfElements.restrict","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements.restrict","doc":"A family of elements for a presheaf on the presieve `R₂` can be restricted to a smaller presieve\n`R₁`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L121-L122","name":"CategoryTheory.Presieve.instInhabitedFamilyOfElementsBotPresieveToBotInstCompleteLatticePresieve","kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.instInhabitedFamilyOfElementsBotPresieveToBotInstCompleteLatticePresieve","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Sites/SheafOfTypes.lean#L117-L118","name":"CategoryTheory.Presieve.FamilyOfElements","kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.FamilyOfElements","doc":"A family of elements for a presheaf `P` given a collection of arrows `R` with fixed codomain `X`\nconsists of an element of `P Y` for every `f : Y ⟶ X` in `R`.\nA presheaf is a sheaf (resp, separated) if every *compatible* family of elements has exactly one\n(resp, at most one) amalgamation.\n\nThis data is referred to as a `family` in [MM92], Chapter III, Section 4. It is also a concrete\nversion of the elements of the middle object in https://stacks.math.columbia.edu/tag/00VM which is\nmore useful for direct calculations. It is also used implicitly in Definition C2.1.2 in [Elephant].\n"}]}