{"name":"Mathlib.Combinatorics.SimpleGraph.Regularity.Equitabilise","instances":[],"imports":["Init","Mathlib.Order.Partition.Equipartition"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean#L206-L216","name":"Finpartition.exists_equipartition_card_eq","kind":"theorem","docLink":"./Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.html#Finpartition.exists_equipartition_card_eq","doc":"We can find equipartitions of arbitrary size. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean#L198-L200","name":"Finpartition.card_parts_equitabilise_subset_le","kind":"theorem","docLink":"./Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.html#Finpartition.card_parts_equitabilise_subset_le","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean#L191-L195","name":"Finpartition.card_parts_equitabilise","kind":"theorem","docLink":"./Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.html#Finpartition.card_parts_equitabilise","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean#L172-L188","name":"Finpartition.card_filter_equitabilise_small","kind":"theorem","docLink":"./Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.html#Finpartition.card_filter_equitabilise_small","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean#L167-L169","name":"Finpartition.card_filter_equitabilise_big","kind":"theorem","docLink":"./Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.html#Finpartition.card_filter_equitabilise_big","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean#L161-L162","name":"Finpartition.equitabilise_isEquipartition","kind":"theorem","docLink":"./Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.html#Finpartition.equitabilise_isEquipartition","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean#L156-L158","name":"Finpartition.card_eq_of_mem_parts_equitabilise","kind":"theorem","docLink":"./Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.html#Finpartition.card_eq_of_mem_parts_equitabilise","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean#L150-L151","name":"Finpartition.equitabilise","kind":"def","docLink":"./Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.html#Finpartition.equitabilise","doc":"Given a partition `P` of `s`, as well as a proof that `a * m + b * (m + 1) = s.card`, build a\nnew partition `Q` of `s` where each part has size `m` or `m + 1`, every part of `P` is the union of\nparts of `Q` plus at most `m` extra elements, there are `b` parts of size `m + 1` and (provided\n`m > 0`, because a partition does not have parts of size `0`) there are `a` parts of size `m` and\nhence `a + b` parts in total. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean#L45-L140","name":"Finpartition.equitabilise_aux","kind":"theorem","docLink":"./Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.html#Finpartition.equitabilise_aux","doc":"Given a partition `P` of `s`, as well as a proof that `a * m + b * (m + 1) = s.card`, we can\nfind a new partition `Q` of `s` where each part has size `m` or `m + 1`, every part of `P` is the\nunion of parts of `Q` plus at most `m` extra elements, there are `b` parts of size `m + 1` and\n(provided `m > 0`, because a partition does not have parts of size `0`) there are `a` parts of size\n`m` and hence `a + b` parts in total. "}]}