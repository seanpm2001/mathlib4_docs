{"name":"Mathlib.Tactic.Ring.Basic","instances":[{"typeNames":["Sigma","Qq.QQ","Mathlib.Tactic.Ring.ExBase"],"name":"Mathlib.Tactic.Ring.instInhabitedSigmaQQExBase","className":"Inhabited"},{"typeNames":["Sigma","Qq.QQ","Mathlib.Tactic.Ring.ExSum"],"name":"Mathlib.Tactic.Ring.instInhabitedSigmaQQExSum","className":"Inhabited"},{"typeNames":["Sigma","Qq.QQ","Mathlib.Tactic.Ring.ExProd"],"name":"Mathlib.Tactic.Ring.instInhabitedSigmaQQExProd","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.Ring.Result"],"name":"Mathlib.Tactic.Ring.instInhabitedResult","className":"Inhabited"}],"imports":["Init","Lean.Elab.Tactic.Basic","Mathlib.Algebra.GroupPower.Basic","Mathlib.Algebra.Ring.Basic","Mathlib.Tactic.NormNum","Mathlib.Tactic.Clear!","Mathlib.Util.AtomM"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L1126-L1126","name":"Mathlib.Tactic.Ring.tacticRing1!","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.tacticRing1!","doc":"Tactic for solving equations of *commutative* (semi)rings,\nallowing variables in the exponent.\n\n* This version of `ring` fails if the target is not an equality.\n* The variant `ring1!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L1115-L1124","name":"Mathlib.Tactic.Ring.ring1","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1","doc":"Tactic for solving equations of *commutative* (semi)rings,\nallowing variables in the exponent.\n\n* This version of `ring` fails if the target is not an equality.\n* The variant `ring1!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L1097-L1113","name":"Mathlib.Tactic.Ring.proveEq","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq","doc":"Frontend of `ring1`: attempt to close a goal `g`, assuming it is an equation of semirings. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L1089-L1094","name":"Mathlib.Tactic.Ring.ringCleanupRef","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ringCleanupRef","doc":"This is a routine which is used to clean up the unsolved subgoal\nof a failed `ring1` application. It is overridden in `Mathlib.Tactic.Ring.RingNF`\nto apply the `ring_nf` simp set to the goal.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L1087-L1087","name":"Mathlib.Tactic.Ring.of_eq","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L1024-L1083","name":"Mathlib.Tactic.Ring.eval","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval","doc":"Evaluates expression `e` of type `α` into a normalized representation as a polynomial.\nThis is the main driver of `ring`, which calls out to `evalAdd`, `evalMul` etc.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L1003-L1018","name":"Mathlib.Tactic.Ring.isAtomOrDerivable","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.isAtomOrDerivable","doc":"Checks whether `e` would be processed by `eval` as a ring expression,\nor otherwise if it is an atom or something simplifiable via `norm_num`.\n\nWe use this in `ring_nf` to avoid rewriting atoms unnecessarily.\n\nReturns:\n* `none` if `eval` would process `e` as an algebraic ring expression\n* `some none` if `eval` would treat `e` as an atom.\n* `some (some r)` if `eval` would not process `e` as an algebraic ring expression,\n  but `NormNum.derive` can nevertheless simplify `e`, with result `r`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L989-L989","name":"Mathlib.Tactic.Ring.Cache.nat","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.nat","doc":"A precomputed `Cache` for `ℕ`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L985-L986","name":"Mathlib.Tactic.Ring.div_congr","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_congr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L982-L983","name":"Mathlib.Tactic.Ring.inv_congr","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_congr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L979-L980","name":"Mathlib.Tactic.Ring.sub_congr","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_congr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L976-L977","name":"Mathlib.Tactic.Ring.neg_congr","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_congr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L973-L974","name":"Mathlib.Tactic.Ring.pow_congr","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_congr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L970-L971","name":"Mathlib.Tactic.Ring.nsmul_congr","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.nsmul_congr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L967-L968","name":"Mathlib.Tactic.Ring.mul_congr","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_congr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L964-L965","name":"Mathlib.Tactic.Ring.add_congr","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_congr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L958-L962","name":"Mathlib.Tactic.Ring.evalDiv","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalDiv","doc":"Divides two polynomials `va, vb` to get a normalized result polynomial.\n\n* `a / b = a * b⁻¹`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L951-L952","name":"Mathlib.Tactic.Ring.div_pf","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L938-L947","name":"Mathlib.Tactic.Ring.ExSum.evalInv","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalInv","doc":"Inverts a polynomial `va` to get a normalized result polynomial.\n\n* `0⁻¹ = 0`\n* `a⁻¹ = (a⁻¹)` if `a` is a nontrivial sum\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L913-L931","name":"Mathlib.Tactic.Ring.ExProd.evalInv","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalInv","doc":"Inverts a polynomial `va` to get a normalized result polynomial.\n\n* `c⁻¹ = (c⁻¹)` if `c` is a constant\n* `(a ^ b * c)⁻¹ = a⁻¹ ^ b * c⁻¹`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L903-L906","name":"Mathlib.Tactic.Ring.evalInvAtom","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalInvAtom","doc":"Applies `⁻¹` to a polynomial to get an atom. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L896-L897","name":"Mathlib.Tactic.Ring.inv_add","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_add","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L893-L894","name":"Mathlib.Tactic.Ring.inv_single","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_single","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L891-L891","name":"Mathlib.Tactic.Ring.inv_zero","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L886-L889","name":"Mathlib.Tactic.Ring.inv_mul","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_mul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L877-L884","name":"Mathlib.Tactic.Ring.evalAtom","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAtom","doc":"Evaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L869-L870","name":"Mathlib.Tactic.Ring.atom_pf'","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L868-L868","name":"Mathlib.Tactic.Ring.atom_pf","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L866-L867","name":"Mathlib.Tactic.Ring.toProd_pf","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.toProd_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L853-L864","name":"Mathlib.Tactic.Ring.evalCast","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalCast","doc":"Converts a proof by `norm_num` that `e` is a numeral, into a normalization as a monomial:\n\n* `e = 0` if `norm_num` returns `IsNat e 0`\n* `e = Nat.rawCast n + 0` if `norm_num` returns `IsNat e n`\n* `e = Int.rawCast n + 0` if `norm_num` returns `IsInt e n`\n* `e = Rat.rawCast n d + 0` if `norm_num` returns `IsRat e n d`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L843-L844","name":"Mathlib.Tactic.Ring.cast_rat","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_rat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L840-L841","name":"Mathlib.Tactic.Ring.cast_neg","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_neg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L837-L838","name":"Mathlib.Tactic.Ring.cast_zero","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L834-L835","name":"Mathlib.Tactic.Ring.cast_pos","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_pos","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L828-L832","name":"Mathlib.Tactic.Ring.mkCache","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mkCache","doc":"Create a new cache for `α` by doing the necessary instance searches. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L825-L825","name":"Mathlib.Tactic.Ring.Cache.czα","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.czα","doc":"A characteristic zero ring instance on `α`, if available. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L823-L823","name":"Mathlib.Tactic.Ring.Cache.dα","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.dα","doc":"A division ring instance on `α`, if available. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L821-L821","name":"Mathlib.Tactic.Ring.Cache.rα","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.rα","doc":"A ring instance on `α`, if available. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L819-L819","name":"Mathlib.Tactic.Ring.Cache.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L819-L825","name":"Mathlib.Tactic.Ring.Cache","kind":"structure","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache","doc":"This cache contains data required by the `ring` tactic during execution. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L809-L816","name":"Mathlib.Tactic.Ring.evalPow","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow","doc":"Exponentiates two polynomials `va, vb`.\n\n* `a ^ 0 = 1`\n* `a ^ (b₁ + b₂) = a ^ b₁ * a ^ b₂`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L801-L802","name":"Mathlib.Tactic.Ring.pow_add","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_add","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L799-L799","name":"Mathlib.Tactic.Ring.pow_zero","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L782-L797","name":"Mathlib.Tactic.Ring.evalPow₁","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow₁","doc":"Exponentiates a polynomial `va` by a monomial `vb`, including several special cases.\n\n* `a ^ 1 = a`\n* `0 ^ e = 0` if `0 < e`\n* `(a + 0) ^ b = a ^ b` computed using `evalPowProd`\n* `a ^ b = (a ^ b') ^ k` if `b = b' * k` and `k > 1`\n\nOtherwise `a ^ b` is just encoded as `a ^ b * 1 + 0` using `evalPowAtom`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L770-L771","name":"Mathlib.Tactic.Ring.pow_nat","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_nat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L768-L768","name":"Mathlib.Tactic.Ring.single_pow","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.single_pow","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L766-L766","name":"Mathlib.Tactic.Ring.zero_pow","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_pow","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L764-L764","name":"Mathlib.Tactic.Ring.pow_one_cast","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one_cast","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L755-L762","name":"Mathlib.Tactic.Ring.extractCoeff","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.extractCoeff","doc":"Given a monomial expression `va`, splits off the leading coefficient `k` and the remainder\n`e'`, stored in the `ExtractCoeff` structure.\n\n* `c = 1 * c` (if `c` is a constant)\n* `a * b = (a * b') * k` if `b = b' * k`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L746-L747","name":"Mathlib.Tactic.Ring.coeff_mul","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_mul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L744-L744","name":"Mathlib.Tactic.Ring.coeff_one","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_one","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L742-L742","name":"Mathlib.Tactic.Ring.ExtractCoeff.p","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.p","doc":"The proof that `e` splits into the coefficient `k` and the monic monomial `e'`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L740-L740","name":"Mathlib.Tactic.Ring.ExtractCoeff.ve'","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.ve'","doc":"`e'` is a monomial. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L738-L738","name":"Mathlib.Tactic.Ring.ExtractCoeff.e'","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'","doc":"The result of extracting the coefficient is a monic monomial. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L736-L736","name":"Mathlib.Tactic.Ring.ExtractCoeff.k","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k","doc":"A raw natural number literal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L734-L734","name":"Mathlib.Tactic.Ring.ExtractCoeff.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L734-L742","name":"Mathlib.Tactic.Ring.ExtractCoeff","kind":"structure","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff","doc":"The result of `extractCoeff` is a numeral and a proof that the original expression\nfactors by this numeral.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L710-L728","name":"Mathlib.Tactic.Ring.evalPowProd","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProd","doc":"There are several special cases when exponentiating monomials:\n\n* `1 ^ n = 1`\n* `x ^ y = (x ^ y)` when `x` and `y` are constants\n* `(a * b) ^ e = a ^ e * b ^ e`\n\nIn all other cases we use `evalPowProdAtom`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L699-L700","name":"Mathlib.Tactic.Ring.mul_pow","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pow","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L697-L697","name":"Mathlib.Tactic.Ring.one_pow","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_pow","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L680-L695","name":"Mathlib.Tactic.Ring.evalPowNat","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowNat","doc":"The main case of exponentiation of ring expressions is when `va` is a polynomial and `n` is a\nnonzero literal expression, like `(x + y)^5`. In this case we work out the polynomial completely\ninto a sum of monomials.\n\n* `x ^ 1 = x`\n* `x ^ (2*n) = x ^ n * x ^ n`\n* `x ^ (2*n+1) = x ^ n * x ^ n * x`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L667-L669","name":"Mathlib.Tactic.Ring.pow_bit1","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit1","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L664-L665","name":"Mathlib.Tactic.Ring.pow_bit0","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit0","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L662-L662","name":"Mathlib.Tactic.Ring.pow_one","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L652-L658","name":"Mathlib.Tactic.Ring.ExSum.evalPos","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalPos","doc":"Attempts to prove that a polynomial expression in `ℕ` is positive.\n\n* `0 < 0` fails\n* `0 < a + b` if `0 < a` or `0 < b`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L635-L645","name":"Mathlib.Tactic.Ring.ExProd.evalPos","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalPos","doc":"Attempts to prove that a monomial expression in `ℕ` is positive.\n\n* `0 < c` (where `c` is a numeral) is true by the normalization invariant (`c` is not zero)\n* `0 < x ^ e * b` if `0 < x` and `0 < b`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L625-L628","name":"Mathlib.Tactic.Ring.ExBase.evalPos","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalPos","doc":"Attempts to prove that a polynomial expression in `ℕ` is positive.\n\n* Atoms are not (necessarily) positive\n* Sums defer to `ExSum.evalPos`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L616-L616","name":"Mathlib.Tactic.Ring.add_pos_right","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L614-L614","name":"Mathlib.Tactic.Ring.add_pos_left","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L611-L612","name":"Mathlib.Tactic.Ring.mul_exp_pos","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_exp_pos","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L609-L609","name":"Mathlib.Tactic.Ring.const_pos","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.const_pos","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L606-L607","name":"Mathlib.Tactic.Ring.evalPowAtom","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom","doc":"The fallback case for exponentiating polynomials is to use `ExBase.toProd` to just build an\nexponent expression.\n\n* `x ^ e = x ^ e * 1 + 0`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L598-L598","name":"Mathlib.Tactic.Ring.pow_atom","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_atom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L595-L596","name":"Mathlib.Tactic.Ring.evalPowProdAtom","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom","doc":"The fallback case for exponentiating polynomials is to use `ExBase.toProd` to just build an\nexponent expression. (This has a slightly different normalization than `evalPowAtom` because\nthe input types are different.)\n\n* `x ^ e = (x + 0) ^ e * 1`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L586-L586","name":"Mathlib.Tactic.Ring.pow_prod_atom","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_prod_atom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L581-L584","name":"Mathlib.Tactic.Ring.evalSub","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalSub","doc":"Subtracts two polynomials `va, vb` to get a normalized result polynomial.\n\n* `a - b = a + -b`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L574-L575","name":"Mathlib.Tactic.Ring.sub_pf","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L566-L572","name":"Mathlib.Tactic.Ring.evalNeg","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNeg","doc":"Negates a polynomial `va` to get another polynomial.\n\n* `-0 = 0` (for `c` coefficient)\n* `-(a₁ + a₂) = -a₁ + -a₂`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L558-L559","name":"Mathlib.Tactic.Ring.neg_add","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_add","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L556-L556","name":"Mathlib.Tactic.Ring.neg_zero","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L540-L554","name":"Mathlib.Tactic.Ring.evalNegProd","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNegProd","doc":"Negates a monomial `va` to get another monomial.\n\n* `-c = (-c)` (for `c` coefficient)\n* `-(a₁ * a₂) = a₁ * -a₂`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L532-L533","name":"Mathlib.Tactic.Ring.neg_mul","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_mul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L529-L530","name":"Mathlib.Tactic.Ring.neg_one_mul","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_one_mul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L518-L527","name":"Mathlib.Tactic.Ring.evalNSMul","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNSMul","doc":"Constructs the scalar multiplication `n • a`, where both `n : ℕ` and `a : α` are normalized\npolynomial expressions.\n\n* `a • b = a * b` if `α = ℕ`\n* `a • b = ↑a * b` otherwise\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L510-L510","name":"Mathlib.Tactic.Ring.smul_eq_cast","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_cast","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L508-L508","name":"Mathlib.Tactic.Ring.smul_nat","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_nat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L498-L504","name":"Mathlib.Tactic.Ring.ExSum.evalNatCast","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalNatCast","doc":"Applies `Nat.cast` to a nat polynomial to produce a polynomial in `α`.\n\n* `↑0 = 0`\n* `↑(a + b) = ↑a + ↑b`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L483-L491","name":"Mathlib.Tactic.Ring.ExProd.evalNatCast","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalNatCast","doc":"Applies `Nat.cast` to a nat monomial to produce a monomial in `α`.\n\n* `↑c = c` if `c` is a numeric literal\n* `↑(a ^ n * b) = ↑a ^ n * ↑b`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L468-L476","name":"Mathlib.Tactic.Ring.ExBase.evalNatCast","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalNatCast","doc":"Applies `Nat.cast` to a nat polynomial to produce a polynomial in `α`.\n\n* An atom `e` causes `↑e` to be allocated as a new atom.\n* A sum delegates to `ExSum.evalNatCast`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L458-L459","name":"Mathlib.Tactic.Ring.natCast_add","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_add","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L456-L456","name":"Mathlib.Tactic.Ring.natCast_zero","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L453-L454","name":"Mathlib.Tactic.Ring.natCast_mul","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_mul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L451-L451","name":"Mathlib.Tactic.Ring.natCast_nat","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_nat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L442-L449","name":"Mathlib.Tactic.Ring.evalMul","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul","doc":"Multiplies two polynomials `va, vb` together to get a normalized result polynomial.\n\n* `0 * b = 0`\n* `(a₁ + a₂) * b = (a₁ * b) + (a₂ * b)`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L434-L435","name":"Mathlib.Tactic.Ring.add_mul","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_mul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L432-L432","name":"Mathlib.Tactic.Ring.zero_mul","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_mul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L423-L430","name":"Mathlib.Tactic.Ring.evalMul₁","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul₁","doc":"Multiplies a monomial `va` to a polynomial `vb` to get a normalized result polynomial.\n\n* `a * 0 = 0`\n* `a * (b₁ + b₂) = (a * b₁) + (a * b₂)`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L415-L416","name":"Mathlib.Tactic.Ring.mul_add","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_add","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L413-L413","name":"Mathlib.Tactic.Ring.mul_zero","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L381-L411","name":"Mathlib.Tactic.Ring.evalMulProd","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMulProd","doc":"Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L367-L369","name":"Mathlib.Tactic.Ring.mul_pp_pf_overlap","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pp_pf_overlap","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L364-L365","name":"Mathlib.Tactic.Ring.mul_pf_right","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L361-L362","name":"Mathlib.Tactic.Ring.mul_pf_left","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L359-L359","name":"Mathlib.Tactic.Ring.mul_one","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_one","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L357-L357","name":"Mathlib.Tactic.Ring.one_mul","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_mul","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L337-L355","name":"Mathlib.Tactic.Ring.evalAdd","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAdd","doc":"Adds two polynomials `va, vb` together to get a normalized result polynomial.\n\n* `0 + b = 0`\n* `a + 0 = 0`\n* `a * x + a * y = a * (x + y)` (for `x`, `y` coefficients; uses `evalAddOverlap`)\n* `(a₁ + a₂) + (b₁ + b₂) = a₁ + (a₂ + (b₁ + b₂))` (if `a₁.lt b₁`)\n* `(a₁ + a₂) + (b₁ + b₂) = b₁ + ((a₁ + a₂) + b₂)` (if not `a₁.lt b₁`)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L326-L327","name":"Mathlib.Tactic.Ring.add_pf_add_gt","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_gt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L324-L324","name":"Mathlib.Tactic.Ring.add_pf_add_lt","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_lt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L320-L322","name":"Mathlib.Tactic.Ring.add_pf_add_overlap_zero","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L316-L318","name":"Mathlib.Tactic.Ring.add_pf_add_overlap","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L314-L314","name":"Mathlib.Tactic.Ring.add_pf_add_zero","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L312-L312","name":"Mathlib.Tactic.Ring.add_pf_zero_add","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_zero_add","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L293-L310","name":"Mathlib.Tactic.Ring.evalAddOverlap","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAddOverlap","doc":"Given monomials `va, vb`, attempts to add them together to get another monomial.\nIf the monomials are not compatible, returns `none`.\nFor example, `xy + 2xy = 3xy` is a `.nonzero` overlap, while `xy + xz` returns `none`\nand `xy + -xy = 0` is a `.zero` overlap.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L283-L285","name":"Mathlib.Tactic.Ring.add_overlap_pf_zero","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L280-L281","name":"Mathlib.Tactic.Ring.add_overlap_pf","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L276-L278","name":"Mathlib.Tactic.Ring.Overlap.nonzero","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.nonzero","doc":"The expression `e` (the sum of monomials) is equal to another monomial\n(with nonzero leading coefficient). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L274-L275","name":"Mathlib.Tactic.Ring.Overlap.zero","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.zero","doc":"The expression `e` (the sum of monomials) is equal to `0`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L273-L278","name":"Mathlib.Tactic.Ring.Overlap","kind":"inductive","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap","doc":"Two monomials are said to \"overlap\" if they differ by a constant factor, in which case the\nconstants just add. When this happens, the constant may be either zero (if the monomials cancel)\nor nonzero (if they add up); the zero case is handled specially.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L263-L265","name":"Mathlib.Tactic.Ring.ExProd.coeff","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.coeff","doc":"Get the leading coefficient of an `ExProd`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L260-L260","name":"Mathlib.Tactic.Ring.ExProd.toSum","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum","doc":"Embed `ExProd` in `ExSum` by adding 0. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L256-L257","name":"Mathlib.Tactic.Ring.ExBase.toProd","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd","doc":"Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L248-L250","name":"Mathlib.Tactic.Ring.ExProd.mkRat","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkRat","doc":"Constructs the expression corresponding to `.const (-n)`.\n(The `.const` constructor does not check that the expression is correct.)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L240-L242","name":"Mathlib.Tactic.Ring.ExProd.mkNegNat","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNat","doc":"Constructs the expression corresponding to `.const (-n)`.\n(The `.const` constructor does not check that the expression is correct.)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L232-L234","name":"Mathlib.Tactic.Ring.ExProd.mkNat","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNat","doc":"Constructs the expression corresponding to `.const n`.\n(The `.const` constructor does not check that the expression is correct.)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L223-L224","name":"Mathlib.Tactic.Ring.instInhabitedResult","kind":"instance","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedResult","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L221-L221","name":"Mathlib.Tactic.Ring.Result.proof","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.proof","doc":"A proof that the original expression is equal to the normalized result. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L219-L219","name":"Mathlib.Tactic.Ring.Result.val","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.val","doc":"The data associated to the normalization. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L217-L217","name":"Mathlib.Tactic.Ring.Result.expr","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.expr","doc":"The normalized result. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L215-L215","name":"Mathlib.Tactic.Ring.Result.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L215-L221","name":"Mathlib.Tactic.Ring.Result","kind":"structure","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result","doc":"The result of evaluating an (unnormalized) expression `e` into the type family `E`\n(one of `ExSum`, `ExProd`, `ExBase`) is a (normalized) element `e'`\nand a representation `E e'` for it, and a proof of `e = e'`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L204-L206","name":"Mathlib.Tactic.Ring.ExSum.cast","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cast","doc":"Converts `ExSum sα` to `ExSum sβ`, assuming `sα` and `sβ` are defeq. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L199-L201","name":"Mathlib.Tactic.Ring.ExProd.cast","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cast","doc":"Converts `ExProd sα` to `ExProd sβ`, assuming `sα` and `sβ` are defeq. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L194-L196","name":"Mathlib.Tactic.Ring.ExBase.cast","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cast","doc":"Converts `ExBase sα` to `ExBase sβ`, assuming `sα` and `sβ` are defeq. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L189-L189","name":"Mathlib.Tactic.Ring.instInhabitedSigmaQQExProd","kind":"instance","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQQExProd","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L188-L188","name":"Mathlib.Tactic.Ring.instInhabitedSigmaQQExSum","kind":"instance","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQQExSum","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L187-L187","name":"Mathlib.Tactic.Ring.instInhabitedSigmaQQExBase","kind":"instance","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQQExBase","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L180-L184","name":"Mathlib.Tactic.Ring.ExSum.cmp","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cmp","doc":"A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L173-L177","name":"Mathlib.Tactic.Ring.ExProd.cmp","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cmp","doc":"A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L166-L170","name":"Mathlib.Tactic.Ring.ExBase.cmp","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cmp","doc":"A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L155-L158","name":"Mathlib.Tactic.Ring.ExSum.eq","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.eq","doc":"Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L149-L152","name":"Mathlib.Tactic.Ring.ExProd.eq","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.eq","doc":"Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L143-L146","name":"Mathlib.Tactic.Ring.ExBase.eq","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.eq","doc":"Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L135-L137","name":"Mathlib.Tactic.Ring.ExSum.add","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.add","doc":"A sum `a + b` is a polynomial if `a` is a monomial and `b` is another polynomial. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L133-L134","name":"Mathlib.Tactic.Ring.ExSum.zero","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero","doc":"Zero is a polynomial. `e` is the expression `0`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L132-L137","name":"Mathlib.Tactic.Ring.ExSum","kind":"inductive","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum","doc":"A polynomial expression, which is a sum of monomials. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L125-L129","name":"Mathlib.Tactic.Ring.ExProd.mul","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mul","doc":"A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\nand `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\na polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L122-L124","name":"Mathlib.Tactic.Ring.ExProd.const","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const","doc":"A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\nIf `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L121-L129","name":"Mathlib.Tactic.Ring.ExProd","kind":"inductive","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd","doc":"A monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L114-L115","name":"Mathlib.Tactic.Ring.ExBase.sum","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.sum","doc":"A sum of monomials.  "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L101-L113","name":"Mathlib.Tactic.Ring.ExBase.atom","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.atom","doc":"An atomic expression `e` with id `id`.\n\nAtomic expressions are those which `ring` cannot parse any further.\nFor instance, `a + (a % b)` has `a` and `(a % b)` as atoms.\nThe `ring1` tactic does not normalize the subexpressions in atoms, but `ring_nf` does.\n\nAtoms in fact represent equivalence classes of expressions, modulo definitional equality.\nThe field `index : ℕ` should be a unique number for each class,\nwhile `value : expr` contains a representative of this class.\nThe function `resolve_atom` determines the appropriate atom for a given expression.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L100-L115","name":"Mathlib.Tactic.Ring.ExBase","kind":"inductive","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase","doc":"The base `e` of a normalized exponent expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L92-L92","name":"Mathlib.Tactic.Ring.sℕ","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ","doc":"A typed expression of type `CommSemiring ℕ` used when we are working on\nring subexpressions of type `ℕ`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/Basic.lean#L86-L86","name":"Mathlib.Tactic.Ring.instCommSemiringNat","kind":"def","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat","doc":"A shortcut instance for `CommSemiring ℕ` used by ring. "}]}