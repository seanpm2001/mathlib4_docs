{"name":"Std.Tactic.SqueezeScope","instances":[],"imports":["Init","Lean.Elab.Tactic.Simp","Std.Tactic.SimpTrace"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/SqueezeScope.lean#L66-L74","name":"Std.Tactic.squeezeScopes","kind":"opaque","docLink":"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeScopes","doc":"We implement `squeeze_scope` using a global variable that tracks all `squeeze_scope` invocations\nin flight. It is a map `a ↦ (x ↦ (stx, simps))` where `a` is a unique identifier for\nthe `squeeze_scope` invocation which is shared with all contained simps, and `x` is a unique\nidentifier for a particular piece of simp syntax (which can be called multiple times).\nWithin that, `stx` is the simp syntax itself, and `simps` is the aggregated list of simps used\nso far.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/SqueezeScope.lean#L55-L62","name":"Std.Tactic.squeezeScope","kind":"def","docLink":"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeScope","doc":"The `squeeze_scope` tactic allows aggregating multiple calls to `simp` coming from the same syntax\nbut in different branches of execution, such as in `cases x <;> simp`.\nThe reported `simp` call covers all simp lemmas used by this syntax.\n```\n@[simp] def bar (z : Nat) := 1 + z\n@[simp] def baz (z : Nat) := 1 + z\n\n@[simp] def foo : Nat → Nat → Nat\n  | 0, z => bar z\n  | _+1, z => baz z\n\nexample : foo x y = 1 + y := by\n  cases x <;> simp? -- two printouts:\n  -- \"Try this: simp only [foo, bar]\"\n  -- \"Try this: simp only [foo, baz]\"\n\nexample : foo x y = 1 + y := by\n  squeeze_scope\n    cases x <;> simp -- only one printout: \"Try this: simp only [foo, baz, bar]\"\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/SqueezeScope.lean#L25-L30","name":"Std.Tactic.squeezeWrap","kind":"def","docLink":"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeWrap","doc":"`squeeze_wrap a x => tac` is part of the implementation of `squeeze_scope`.\nHere `tac` will be a `simp` or `dsimp` syntax, and `squeeze_wrap` will run the tactic\nand contribute the generated `usedSimps` to the `squeezeScopes[a][x]` variable.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/SqueezeScope.lean#L19-L24","name":"Std.Tactic.squeezeScopeIn","kind":"def","docLink":"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeScopeIn","doc":"`squeeze_scope a => tacs` is part of the implementation of `squeeze_scope`.\nInside `tacs`, invocations of `simp` wrapped with `squeeze_wrap a _ => ...` will contribute\nto the accounting associated to scope `a`.\n"}]}