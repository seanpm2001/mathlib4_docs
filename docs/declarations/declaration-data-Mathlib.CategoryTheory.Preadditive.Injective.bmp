{"name":"Mathlib.CategoryTheory.Preadditive.Injective","instances":[{"typeNames":["OfNat.ofNat","Zero.toOfNat0","CategoryTheory.Limits.HasZeroObject.zero'"],"name":"CategoryTheory.Injective.zero_injective","className":"CategoryTheory.Injective"},{"typeNames":["_builtin_typeu","CategoryTheory.types"],"name":"CategoryTheory.Injective.instInjectiveTypeTypes","className":"CategoryTheory.Injective"},{"typeNames":["_builtin_typeu","CategoryTheory.types"],"name":"CategoryTheory.Injective.Type.enoughInjectives","className":"CategoryTheory.EnoughInjectives"},{"typeNames":["CategoryTheory.Limits.prod"],"name":"CategoryTheory.Injective.instInjectiveProd","className":"CategoryTheory.Injective"},{"typeNames":["CategoryTheory.Limits.piObj"],"name":"CategoryTheory.Injective.instInjectivePiObj","className":"CategoryTheory.Injective"},{"typeNames":["CategoryTheory.Limits.biprod"],"name":"CategoryTheory.Injective.instInjectiveBiprod","className":"CategoryTheory.Injective"},{"typeNames":["CategoryTheory.Limits.biproduct"],"name":"CategoryTheory.Injective.instInjectiveBiproduct","className":"CategoryTheory.Injective"},{"typeNames":["Opposite.unop"],"name":"CategoryTheory.Injective.instInjectiveUnop","className":"CategoryTheory.Injective"},{"typeNames":["Opposite.unop"],"name":"CategoryTheory.Injective.instProjectiveUnop","className":"CategoryTheory.Projective"},{"typeNames":["Opposite","CategoryTheory.Category.opposite","Opposite.op"],"name":"CategoryTheory.Injective.instProjectiveOppositeOppositeOp","className":"CategoryTheory.Projective"},{"typeNames":["Opposite","CategoryTheory.Category.opposite","Opposite.op"],"name":"CategoryTheory.Injective.instInjectiveOppositeOppositeOp","className":"CategoryTheory.Injective"},{"typeNames":["CategoryTheory.Injective.under"],"name":"CategoryTheory.Injective.injective_under","className":"CategoryTheory.Injective"},{"typeNames":["CategoryTheory.Injective.under","CategoryTheory.Injective.ι"],"name":"CategoryTheory.Injective.ι_mono","className":"CategoryTheory.Mono"},{"typeNames":["CategoryTheory.Injective.syzygies"],"name":"CategoryTheory.Injective.instInjectiveSyzygies","className":"CategoryTheory.Injective"},{"typeNames":["Opposite","CategoryTheory.Category.opposite"],"name":"CategoryTheory.Injective.instEnoughProjectivesOppositeOpposite","className":"CategoryTheory.EnoughProjectives"},{"typeNames":["Opposite","CategoryTheory.Category.opposite"],"name":"CategoryTheory.Injective.instEnoughInjectivesOppositeOpposite","className":"CategoryTheory.EnoughInjectives"}],"imports":["Init","Mathlib.CategoryTheory.Preadditive.Projective"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L365-L375","name":"CategoryTheory.Equivalence.enoughInjectives_iff","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Equivalence.enoughInjectives_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L357-L362","name":"CategoryTheory.Equivalence.injectivePresentationOfMapInjectivePresentation","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Equivalence.injectivePresentationOfMapInjectivePresentation","doc":"Given an equivalence of categories `F`, an injective presentation of `F(X)` induces an\ninjective presentation of `X.` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L340-L346","name":"CategoryTheory.Adjunction.mapInjectivePresentation","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Adjunction.mapInjectivePresentation","doc":"Given an adjunction `F ⊣ G` such that `F` preserves monos, `G` maps an injective presentation\nof `X` to an injective presentation of `G(X)`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L327-L335","name":"CategoryTheory.Adjunction.injective_of_map_injective","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Adjunction.injective_of_map_injective","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L317-L324","name":"CategoryTheory.Adjunction.map_injective","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Adjunction.map_injective","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L304-L306","name":"CategoryTheory.Injective.Exact.comp_desc","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.Exact.comp_desc","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L298-L300","name":"CategoryTheory.Injective.Exact.desc","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.Exact.desc","doc":"Given a pair of exact morphism `f : Q ⟶ R` and `g : R ⟶ S` and a map `h : R ⟶ J` to an injective\nobject `J` such that `f ≫ h = 0`, then `g` descents to a map `S ⟶ J`. See below:\n\n```\nQ --- f --> R --- g --> S\n            |\n            | h\n            v\n            J\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L277-L278","name":"CategoryTheory.Injective.enoughInjectives_of_enoughProjectives_op","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.enoughInjectives_of_enoughProjectives_op","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L273-L274","name":"CategoryTheory.Injective.enoughProjectives_of_enoughInjectives_op","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.enoughProjectives_of_enoughInjectives_op","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L270-L271","name":"CategoryTheory.Injective.instEnoughInjectivesOppositeOpposite","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instEnoughInjectivesOppositeOpposite","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L267-L268","name":"CategoryTheory.Injective.instEnoughProjectivesOppositeOpposite","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instEnoughProjectivesOppositeOpposite","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L259-L260","name":"CategoryTheory.Injective.d","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.d","doc":"When `C` has enough injective,\n`injective.d f : Y ⟶ syzygies f` is the composition\n`cokernel.π f ≫ ι (cokernel f)`.\n\n(When `C` is abelian, we have `exact f (injective.d f)`.)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L251-L251","name":"CategoryTheory.Injective.instInjectiveSyzygies","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instInjectiveSyzygies","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L247-L248","name":"CategoryTheory.Injective.syzygies","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.syzygies","doc":"When `C` has enough injectives, the object `Injective.syzygies f` is\nan arbitrarily chosen injective object under `cokernel f`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L236-L237","name":"CategoryTheory.Injective.ι_mono","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.ι_mono","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L232-L233","name":"CategoryTheory.Injective.ι","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.ι","doc":"The monomorphism `Injective.ι : X ⟶  Injective.under X`\nfrom the arbitrarily chosen injective object under `X`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L225-L226","name":"CategoryTheory.Injective.injective_under","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.injective_under","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L221-L222","name":"CategoryTheory.Injective.under","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.under","doc":"`Injective.under X` provides an arbitrarily chosen injective object equipped with\na monomorphism `Injective.ι : X ⟶  Injective.under X`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L206-L209","name":"CategoryTheory.Injective.injective_of_adjoint","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.injective_of_adjoint","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L192-L195","name":"CategoryTheory.Injective.injective_iff_preservesEpimorphisms_yoneda_obj","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.injective_iff_preservesEpimorphisms_yoneda_obj","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L188-L189","name":"CategoryTheory.Injective.projective_iff_injective_op","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.projective_iff_injective_op","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L184-L185","name":"CategoryTheory.Injective.injective_iff_projective_op","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.injective_iff_projective_op","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L180-L182","name":"CategoryTheory.Injective.instInjectiveOppositeOppositeOp","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instInjectiveOppositeOppositeOp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L176-L178","name":"CategoryTheory.Injective.instProjectiveOppositeOppositeOp","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instProjectiveOppositeOppositeOp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L172-L174","name":"CategoryTheory.Injective.instProjectiveUnop","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instProjectiveUnop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L168-L170","name":"CategoryTheory.Injective.instInjectiveUnop","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instInjectiveUnop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L160-L166","name":"CategoryTheory.Injective.instInjectiveBiproduct","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instInjectiveBiproduct","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L151-L158","name":"CategoryTheory.Injective.instInjectiveBiprod","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instInjectiveBiprod","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L144-L149","name":"CategoryTheory.Injective.instInjectivePiObj","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instInjectivePiObj","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L135-L142","name":"CategoryTheory.Injective.instInjectiveProd","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instInjectiveProd","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L124-L132","name":"CategoryTheory.Injective.Type.enoughInjectives","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.Type.enoughInjectives","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L110-L122","name":"CategoryTheory.Injective.instInjectiveTypeTypes","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.instInjectiveTypeTypes","doc":"The axiom of choice says that every nonempty type is an injective object in `Type`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L105-L106","name":"CategoryTheory.Injective.iso_iff","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.iso_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L97-L102","name":"CategoryTheory.Injective.of_iso","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.of_iso","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L91-L92","name":"CategoryTheory.Injective.zero_injective","kind":"instance","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.zero_injective","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L82-L84","name":"CategoryTheory.Injective.comp_factorThru","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.comp_factorThru","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L77-L78","name":"CategoryTheory.Injective.factorThru","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.factorThru","doc":"Let `J` be injective and `g` a morphism into `J`, then `g` can be factored through any monomorphism.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L65-L65","name":"CategoryTheory.EnoughInjectives.presentation","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.EnoughInjectives.presentation","doc":"A category \"has enough injectives\" if every object has an injective presentation,\ni.e. if for every object `X` there is an injective object `J` and a monomorphism `X ↪ J`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L64-L65","name":"CategoryTheory.EnoughInjectives","kind":"class","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.EnoughInjectives","doc":"A category \"has enough injectives\" if every object has an injective presentation,\ni.e. if for every object `X` there is an injective object `J` and a monomorphism `X ↪ J`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L52-L52","name":"CategoryTheory.InjectivePresentation.mono","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.InjectivePresentation.mono","doc":"An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J`\nto some injective object `J`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L51-L51","name":"CategoryTheory.InjectivePresentation.f","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.InjectivePresentation.f","doc":"An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J`\nto some injective object `J`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L50-L50","name":"CategoryTheory.InjectivePresentation.injective","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.InjectivePresentation.injective","doc":"An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J`\nto some injective object `J`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L49-L49","name":"CategoryTheory.InjectivePresentation.J","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.InjectivePresentation.J","doc":"An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J`\nto some injective object `J`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L48-L48","name":"CategoryTheory.InjectivePresentation.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.InjectivePresentation.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L48-L52","name":"CategoryTheory.InjectivePresentation","kind":"structure","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.InjectivePresentation","doc":"An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J`\nto some injective object `J`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L38-L38","name":"CategoryTheory.Injective.factors","kind":"def","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.factors","doc":"An object `J` is injective iff every morphism into `J` can be obtained by extending a monomorphism.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L37-L37","name":"CategoryTheory.Injective.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L37-L38","name":"CategoryTheory.Injective","kind":"class","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.Injective","doc":"An object `J` is injective iff every morphism into `J` can be obtained by extending a monomorphism.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Preadditive/Injective.lean#L1-L1","name":"CategoryTheory.EnoughInjectives.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Preadditive/Injective.html#CategoryTheory.EnoughInjectives.mk","doc":""}]}