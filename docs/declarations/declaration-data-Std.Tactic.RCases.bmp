{"name":"Std.Tactic.RCases","instances":[{"typeNames":["Lean.Syntax.Ident","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr1","List.nil"],"name":"Std.Tactic.RCases.instCoeIdentTSyntaxConsSyntaxNodeKindMkStr1Nil","className":"Coe"},{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr1","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1NilMkStr4","className":"Coe"},{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","className":"Coe"},{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr1","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr1","List.nil"],"name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1Nil","className":"Coe"},{"typeNames":["Std.Tactic.RCases.RCasesPatt"],"name":"Std.Tactic.RCases.instReprRCasesPatt","className":"Repr"},{"typeNames":["Std.Tactic.RCases.RCasesPatt"],"name":"Std.Tactic.RCases.RCasesPatt.instInhabitedRCasesPatt","className":"Inhabited"},{"typeNames":["Std.Tactic.RCases.RCasesPatt"],"name":"Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt","className":"Lean.ToMessageData"}],"imports":["Init","Lean.Elab.Tactic.Induction"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L738-L751","name":"Std.Tactic.rintro","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.rintro","doc":"The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L693-L725","name":"Std.Tactic.obtain","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.obtain","doc":"The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L640-L691","name":"Std.Tactic.rcases","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.rcases","doc":"`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alteration pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L621-L623","name":"Std.Tactic.RCases.rintro","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintro","doc":"The implementation of the `rintro` tactic. It takes a list of patterns `pats` and\nan optional type ascription `ty?` and introduces the patterns, resulting in zero or more goals.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L610-L613","name":"Std.Tactic.RCases.rintroContinue.loop","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroContinue.loop","doc":"Runs `rintroContinue` on `pats[i:]` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L604-L613","name":"Std.Tactic.RCases.rintroContinue","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroContinue","doc":"This introduces the list of patterns `pats`. It has the same arguments as `rcasesCore`, plus:\n* `ty?`: the nearest enclosing type ascription on the current pattern\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L587-L598","name":"Std.Tactic.RCases.rintroCore","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroCore","doc":"This introduces the pattern `pat`. It has the same arguments as `rcasesCore`, plus:\n* `ty?`: the nearest enclosing type ascription on the current pattern\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L574-L577","name":"Std.Tactic.RCases.expandRIntroPats","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.expandRIntroPats","doc":"Expand a list of `rintroPat` into an equivalent list of `rcasesPat` patterns. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L563-L571","name":"Std.Tactic.RCases.expandRIntroPat","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.expandRIntroPat","doc":"Expand a `rintroPat` into an equivalent list of `rcasesPat` patterns. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L552-L557","name":"Std.Tactic.RCases.obtainNone","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.obtainNone","doc":"The `obtain` tactic in the no-target case. Given a type `T`, create a goal `|- T` and\nand pattern match `T` against the given pattern. Returns the list of goals, with the assumed goal\nfirst followed by the goals produced by the pattern match.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L529-L545","name":"Std.Tactic.RCases.rcases","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcases","doc":"Given a list of targets of the form `e` or `h : e`, and a pattern, match all the targets\nagainst the pattern. Returns the list of produced subgoals.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L511-L523","name":"Std.Tactic.RCases.generalizeExceptFVar","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.generalizeExceptFVar","doc":"Generalize all the arguments as specified in `args` to fvars if they aren't already "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L496-L507","name":"Std.Tactic.RCases.RCasesPatt.parse","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.parse","doc":"Parses a `Syntax` into the `RCasesPatt` type used by the `RCases` tactic. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L488-L491","name":"Std.Tactic.RCases.finish","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.finish","doc":"The terminating continuation used in `rcasesCore` and `rcasesContinue`. We specialize the type\n`α` to `Array MVarId` to collect the list of goals, and given the list of `clears`, it attempts to\nclear them from the goal and adds the goal to the list.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L476-L481","name":"Std.Tactic.RCases.tryClearMany'","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.tryClearMany'","doc":"Like `tryClearMany`, but also clears dependent hypotheses if possible "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L464-L471","name":"Std.Tactic.RCases.rcasesContinue","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesContinue","doc":"This will match a list of patterns against a list of hypotheses `e`. The arguments are similar\nto `rcasesCore`, but the patterns and local variables are in `pats`. Because the calls are all\nnested in continuations, later arguments can be matched many times, once per goal produced by\nearlier arguments. For example `⟨a | b, ⟨c, d⟩⟩` performs the `⟨c, d⟩` match twice, once on the\n`a` branch and once on `b`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L447-L454","name":"Std.Tactic.RCases.rcasesCore.align","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesCore.align","doc":"Runs `rcasesContinue` on the first pattern in `r` with a matching `ctorName`.\nThe unprocessed patterns (subsequent to the matching pattern) are returned. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L382-L455","name":"Std.Tactic.RCases.rcasesCore","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesCore","doc":"This will match a pattern `pat` against a local hypothesis `e`.\n* `g`: The initial subgoal\n* `fs`: A running variable substitution, the result of `cases` operations upstream.\n  The variable `e` must be run through this map before locating it in the context of `g`,\n  and the output variable substitutions will be end extensions of this one.\n* `clears`: The list of variables to clear in all subgoals generated from this point on.\n  We defer clear operations because clearing too early can cause `cases` to fail.\n  The actual clearing happens in `RCases.finish`.\n* `e`: a local hypothesis, the scrutinee to match against.\n* `a`: opaque \"user data\" which is passed through all the goal calls at the end.\n* `pat`: the pattern to match against\n* `cont`: A continuation. This is called on every goal generated by the result of the pattern\n  match, with updated values for `g` , `fs`, `clears`, and `a`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L339-L363","name":"Std.Tactic.RCases.subst'","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.subst'","doc":"Like `Lean.Meta.subst`, but preserves the `FVarSubst`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L321-L333","name":"Std.Tactic.RCases.processConstructors","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.processConstructors","doc":"Takes a list of constructor names, and an (alternation) list of patterns, and matches each\npattern against its constructor. It returns the list of names that will be passed to `cases`,\nand the list of `(constructor name, patterns)` for each constructor, where `patterns` is the\n(conjunctive) list of patterns to apply to each constructor argument.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L298-L313","name":"Std.Tactic.RCases.processConstructor","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.processConstructor","doc":"Takes the number of fields of a single constructor and patterns to match its fields against\n(not necessarily the same number). The returned lists each contain one element per field of the\nconstructor. The `name` is the name which will be used in the top-level `cases` tactic, and the\n`rcases_patt` is the pattern which the field will be matched against by subsequent `cases`\ntactics.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L280-L287","name":"Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt.fmt","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt.fmt","doc":"format an `RCasesPatt` with the given precedence: 0 = lo, 1 = med, 2 = hi "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L277-L278","name":"Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt.parenAbove","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt.parenAbove","doc":"parenthesize the message if the precedence is above `tgt` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L275-L287","name":"Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt","kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L269-L272","name":"Std.Tactic.RCases.RCasesPatt.alts₁","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts₁","doc":"This function is used for producing rcases patterns based on a case tree. This is like\n`alts₁Core`, but it produces a cases pattern directly instead of a list of alternatives. We\nspecially translate the empty alternation to `⟨⟩`, and translate `|(a | b)` to `⟨a | b⟩` (because we\ndon't have any syntax for unary alternation). Otherwise we can use the regular merging of\nalternations at the last argument so that `a | b | (c | d)` becomes `a | b | c | d`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L257-L260","name":"Std.Tactic.RCases.RCasesPatt.alts₁Core","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts₁Core","doc":"This function is used for producing rcases patterns based on a case tree. Here we are given\nthe list of patterns to apply to each argument of each constructor after the main case, and must\nproduce a list of alternatives with the same effect. This function calls `tuple₁` to make the\nindividual alternatives, and handles merging `[a, b, c | d]` to `a | b | c | d` instead of\n`a | b | (c | d)`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L245-L248","name":"Std.Tactic.RCases.RCasesPatt.tuple₁","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple₁","doc":"This function is used for producing rcases patterns based on a case tree. This is like\n`tuple₁Core` but it produces a pattern instead of a tuple pattern list, converting `[n]` to `n`\ninstead of `⟨n⟩` and `[]` to `_`, and otherwise just converting `[a, b, c]` to `⟨a, b, c⟩`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L234-L238","name":"Std.Tactic.RCases.RCasesPatt.tuple₁Core","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple₁Core","doc":"This function is used for producing rcases patterns based on a case tree. Suppose that we have\na list of patterns `ps` that will match correctly against the branches of the case tree for one\nconstructor. This function will merge tuples at the end of the list, so that `[a, b, ⟨c, d⟩]`\nbecomes `⟨a, b, c, d⟩` instead of `⟨a, b, ⟨c, d⟩⟩`.\n\nWe must be careful to turn `[a, ⟨⟩]` into `⟨a, ⟨⟩⟩` instead of `⟨a⟩` (which will not perform the\nnested match).\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L221-L223","name":"Std.Tactic.RCases.RCasesPatt.alts'","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts'","doc":"Convert a list of patterns to an alternation pattern, but mapping `[p]` to `p` instead of\na unary alternation `|p`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L213-L215","name":"Std.Tactic.RCases.RCasesPatt.tuple'","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple'","doc":"Convert a list of patterns to a tuple pattern, but mapping `[p]` to `p` instead of `⟨p⟩`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L208-L210","name":"Std.Tactic.RCases.RCasesPatt.typed?","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.typed?","doc":"Convert a list of patterns to a tuple pattern, but mapping `[p]` to `p` instead of `⟨p⟩`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L202-L205","name":"Std.Tactic.RCases.RCasesPatt.asAlts","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.asAlts","doc":"Interpret an rcases pattern as an alternation, where non-alternations are treated as one\nalternative.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L192-L196","name":"Std.Tactic.RCases.RCasesPatt.asTuple","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.asTuple","doc":"Interpret an rcases pattern as a tuple, where `p` becomes `⟨p⟩` if `p` is not already a tuple.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L180-L187","name":"Std.Tactic.RCases.RCasesPatt.ref","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.ref","doc":"Get the syntax node from which this pattern was parsed. Used for error messages "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L170-L177","name":"Std.Tactic.RCases.RCasesPatt.name?","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.name?","doc":"Get the name from a pattern, if provided "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L167-L167","name":"Std.Tactic.RCases.RCasesPatt.instInhabitedRCasesPatt","kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instInhabitedRCasesPatt","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L163-L163","name":"Std.Tactic.RCases.instReprRCasesPatt","kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.instReprRCasesPatt","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L161-L162","name":"Std.Tactic.RCases.RCasesPatt.alts","kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts","doc":"An alternation / variant pattern `p1 | p2 | p3` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L159-L160","name":"Std.Tactic.RCases.RCasesPatt.tuple","kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple","doc":"A tuple constructor like `⟨p1, p2, p3⟩` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L157-L158","name":"Std.Tactic.RCases.RCasesPatt.typed","kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.typed","doc":"A type ascription like `pat : ty` (parentheses are optional) "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L155-L156","name":"Std.Tactic.RCases.RCasesPatt.explicit","kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.explicit","doc":"An explicit pattern `@pat`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L153-L154","name":"Std.Tactic.RCases.RCasesPatt.clear","kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.clear","doc":"A hyphen `-`, which clears the active hypothesis and any dependents. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L151-L152","name":"Std.Tactic.RCases.RCasesPatt.one","kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.one","doc":"A named pattern like `foo` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L149-L150","name":"Std.Tactic.RCases.RCasesPatt.paren","kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.paren","doc":"A parenthesized expression, used for hovers "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L148-L163","name":"Std.Tactic.RCases.RCasesPatt","kind":"inductive","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt","doc":"An `rcases` pattern can be one of the following, in a nested combination:\n\n* A name like `foo`\n* The special keyword `rfl` (for pattern matching on equality using `subst`)\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* A type ascription like `pat : ty` (parentheses are optional)\n* A tuple constructor like `⟨p1, p2, p3⟩`\n* An alternation / variant pattern `p1 | p2 | p3`\n\nParentheses can be used for grouping; alternation is higher precedence than type ascription, so\n`p1 | p2 | p3 : ty` means `(p1 | p2 | p3) : ty`.\n\nN-ary alternations are treated as a group, so `p1 | p2 | p3` is not the same as `p1 | (p2 | p3)`,\nand similarly for tuples. However, note that an n-ary alternation or tuple can match an n-ary\nconjunction or disjunction, because if the number of patterns exceeds the number of constructors in\nthe type being destructed, the extra patterns will match on the last element, meaning that\n`p1 | p2 | p3` will act like `p1 | (p2 | p3)` when matching `a1 ∨ a2 ∨ a3`. If matching against a\ntype with 3 constructors,  `p1 | (p2 | p3)` will act like `p1 | (p2 | p3) | _` instead.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L119-L120","name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1Nil","kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1Nil","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L117-L118","name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L115-L116","name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1NilMkStr4","kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1NilMkStr4","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L113-L114","name":"Std.Tactic.RCases.instCoeIdentTSyntaxConsSyntaxNodeKindMkStr1Nil","kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeIdentTSyntaxConsSyntaxNodeKindMkStr1Nil","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L107-L111","name":"Std.Tactic.RCases.rintroPat.binder","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroPat.binder","doc":"A multi argument binder `(pat1 pat2 : ty)` binds a list of patterns and gives them all type `ty`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L105-L106","name":"Std.Tactic.RCases.rintroPat.one","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroPat.one","doc":"An `rcases` pattern is an `rintro` pattern "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L103-L104","name":"Lean.Parser.Category.rintroPat","kind":"def","docLink":"./Std/Tactic/RCases.html#Lean.Parser.Category.rintroPat","doc":"The syntax category of `rintro` patterns. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L103-L104","name":"Std.Tactic.RCases.rintroPat.quot","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroPat.quot","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L100-L101","name":"Std.Tactic.RCases.rcasesPat.paren","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.paren","doc":"`(pat)` is a pattern which resets the precedence to low "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L95-L99","name":"Std.Tactic.RCases.rcasesPat.tuple","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.tuple","doc":"`⟨pat, ...⟩` is a pattern which matches on a tuple-like constructor\nor multi-argument inductive constructor\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L90-L94","name":"Std.Tactic.RCases.rcasesPat.explicit","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.explicit","doc":"A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\nwhile leaving the `@` off will only use the patterns on the explicit arguments.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L88-L89","name":"Std.Tactic.RCases.rcasesPat.clear","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.clear","doc":"`-` is a pattern which removes the value from the context "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L86-L87","name":"Std.Tactic.RCases.rcasesPat.ignore","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.ignore","doc":"`_` is a pattern which ignores the value and gives it an inaccessible name "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L84-L85","name":"Std.Tactic.RCases.rcasesPat.one","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.one","doc":"`x` is a pattern which binds `x` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L82-L83","name":"Std.Tactic.RCases.rcasesPatLo","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPatLo","doc":"A low precedence `rcases` pattern is a `rcasesPatMed` optionally followed by `: ty` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L80-L81","name":"Std.Tactic.RCases.rcasesPatMed","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPatMed","doc":"A medium precedence `rcases` pattern is a list of `rcasesPat` separated by `|` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L78-L79","name":"Lean.Parser.Category.rcasesPat","kind":"def","docLink":"./Std/Tactic/RCases.html#Lean.Parser.Category.rcasesPat","doc":"The syntax category of `rcases` patterns. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L78-L79","name":"Std.Tactic.RCases.rcasesPat.quot","kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.quot","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L69-L76","name":"Std.Tactic.RCases.linter.unusedRCasesPattern","kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.linter.unusedRCasesPattern","doc":"Enables the 'unused rcases pattern' linter. This will warn when a pattern is ignored by\n`rcases`, `rintro`, `ext` and similar tactics.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/RCases.lean#L63-L64","name":"Lean.Meta.FVarSubst.append","kind":"def","docLink":"./Std/Tactic/RCases.html#Lean.Meta.FVarSubst.append","doc":"Constructs a substitution consisting of `s` followed by `t`.\nThis satisfies `(s.append t).apply e = t.apply (s.apply e)`\n"}]}