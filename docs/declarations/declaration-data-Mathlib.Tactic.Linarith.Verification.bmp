{"name":"Mathlib.Tactic.Linarith.Verification","instances":[],"imports":["Init","Mathlib.Tactic.Linarith.Elimination","Mathlib.Tactic.Linarith.Parsing","Mathlib.Util.Qq"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L191-L229","name":"Linarith.proveFalseByLinarith","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.proveFalseByLinarith","doc":"`proveFalseByLinarith` is the main workhorse of `linarith`.\nGiven a list `l` of proofs of `tᵢ Rᵢ 0`,\nit tries to derive a contradiction from `l` and use this to produce a proof of `False`.\n\nAn oracle is used to search for a certificate of unsatisfiability.\nIn the current implementation, this is the Fourier Motzkin elimination routine in\n`Elimination.lean`, but other oracles could easily be swapped in.\n\nThe returned certificate is a map `m` from hypothesis indices to natural number coefficients.\nIf our set of hypotheses has the form  `{tᵢ Rᵢ 0}`,\nthen the elimination process should have guaranteed that\n1.\\ `∑ (m i)*tᵢ = 0`,\nwith at least one `i` such that `m i > 0` and `Rᵢ` is `<`.\n\nWe have also that\n2.\\ `∑ (m i)*tᵢ < 0`,\nsince for each `i`, `(m i)*tᵢ ≤ 0` and at least one is strictly negative.\nSo we conclude a contradiction `0 < 0`.\n\nIt remains to produce proofs of (1) and (2). (1) is verified by calling the `discharger` tactic\nof the `LinarithConfig` object, which is typically `ring`. We prove (2) by folding over the\nset of hypotheses.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L160-L163","name":"Linarith.proveEqZeroUsing","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.proveEqZeroUsing","doc":"`proveEqZeroUsing tac e` tries to use `tac` to construct a proof of `e = 0`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L146-L155","name":"Linarith.addNegEqProofs","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.addNegEqProofs","doc":"`addNegEqProofs l` inspects the list of proofs `l` for proofs of the form `t = 0`. For each such\nproof, it adds a proof of `-t = 0` to the list.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L138-L140","name":"Linarith.mkNegOneLtZeroProof","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.mkNegOneLtZeroProof","doc":"`mkNegOneLtZeroProof tp` returns a proof of `-1 < 0`,\nwhere the numerals are natively of type `tp`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L131-L132","name":"Linarith.typeOfIneqProof","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.typeOfIneqProof","doc":"If `prf` is a proof of `t R s`, `typeOfIneqProof prf` returns the type of `t`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L126-L128","name":"Linarith.leftOfIneqProof","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.leftOfIneqProof","doc":"If `prf` is a proof of `t R s`, `leftOfIneqProof prf` returns `t`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L120-L123","name":"Linarith.mkLTZeroProof.step","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.mkLTZeroProof.step","doc":"`step c pf npf coeff` assumes that `pf` is a proof of `t1 R1 0` and `npf` is a proof\nof `t2 R2 0`. It uses `mkSingleCompZeroOf` to prove `t1 + coeff*t2 R 0`, and returns `R`\nalong with this proof.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L105-L123","name":"Linarith.mkLTZeroProof","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.mkLTZeroProof","doc":"`mkLTZeroProof coeffs pfs` takes a list of proofs of the form `tᵢ Rᵢ 0`,\npaired with coefficients `cᵢ`.\nIt produces a proof that `∑cᵢ * tᵢ R 0`, where `R` is as strong as possible.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L89-L98","name":"Linarith.addIneq","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.addIneq","doc":"If our goal is to add together two inequalities `t1 R1 0` and `t2 R2 0`,\n`addIneq R1 R2` produces the strength of the inequality in the sum `R`,\nalong with the name of a lemma to apply in order to conclude `t1 + t2 R 0`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L76-L82","name":"Linarith.addExprs","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.addExprs","doc":"`addExprs L` creates an `Expr` representing the sum of the elements of `L`, associated left. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L70-L73","name":"Linarith.addExprs'.go","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.addExprs'.go","doc":"Inner loop for `addExprs'`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L65-L73","name":"Linarith.addExprs'","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.addExprs'","doc":"A type-safe analogue of `addExprs`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L59-L62","name":"Linarith.mulExpr","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.mulExpr","doc":"`mulExpr n e` creates an `Expr` representing `n*e`.\nWhen elaborated, the coefficient will be a native numeral of the same type as `e`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L50-L53","name":"Linarith.mulExpr'","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Linarith.mulExpr'","doc":"A typesafe version of `mulExpr`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Verification.lean#L29-L38","name":"Qq.ofNatQ","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Qq.ofNatQ","doc":"Typesafe conversion of `n : ℕ` to `Q($α)`. "}]}