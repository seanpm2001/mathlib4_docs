{"name":"Mathlib.Logic.Equiv.Basic","instances":[{"typeNames":["Equiv","FunLike.coe","Equiv","Equiv.instFunLikeEquiv","Function.Bijective"],"name":"Equiv.instCanLiftForAllEquivCoeInstFunLikeEquivBijective","className":"CanLift"},{"typeNames":["FunLike.coe","Equiv","Equiv.instFunLikeEquiv","Equiv.arrowCongr"],"name":"Equiv.instIsAssociativeCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","className":"IsAssociative"},{"typeNames":["FunLike.coe","Equiv","Equiv.instFunLikeEquiv","Equiv.arrowCongr"],"name":"Equiv.instIsIdempotentCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","className":"IsIdempotent"},{"typeNames":["FunLike.coe","Equiv","Equiv.instFunLikeEquiv","Equiv.arrowCongr"],"name":"Equiv.instIsLeftCancelCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","className":"IsLeftCancel"},{"typeNames":["FunLike.coe","Equiv","Equiv.instFunLikeEquiv","Equiv.arrowCongr"],"name":"Equiv.instIsRightCancelCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","className":"IsRightCancel"}],"imports":["Init","Mathlib.Data.Bool.Basic","Mathlib.Data.Prod.Basic","Mathlib.Data.Sigma.Basic","Mathlib.Data.Subtype","Mathlib.Data.Sum.Basic","Mathlib.Init.Data.Sigma.Basic","Mathlib.Logic.Equiv.Defs","Mathlib.Logic.Function.Conjugate"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1946-L1949","name":"Function.piCongrLeft'_symm_update","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.piCongrLeft'_symm_update","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1930-L1943","name":"Function.piCongrLeft'_update","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.piCongrLeft'_update","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1924-L1926","name":"Function.update_apply_equiv_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.update_apply_equiv_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1918-L1921","name":"Function.update_comp_equiv","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.update_comp_equiv","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1911-L1913","name":"uniqueUniqueEquiv","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#uniqueUniqueEquiv","doc":"`Unique (Unique α)` is equivalent to `Unique α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1905-L1907","name":"Equiv.punitOfNonemptyOfSubsingleton","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.punitOfNonemptyOfSubsingleton","doc":"A nonempty subsingleton type is (noncomputably) equivalent to `PUnit`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1896-L1901","name":"equivOfSubsingletonOfSubsingleton","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#equivOfSubsingletonOfSubsingleton","doc":"To give an equivalence between two subsingleton types, it is sufficient to give any two\nfunctions between them. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1887-L1891","name":"subsingletonProdSelfEquiv","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#subsingletonProdSelfEquiv","doc":"If `α` is a subsingleton, then it is equivalent to `α × α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1880-L1883","name":"Function.Injective.swap_comp","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.Injective.swap_comp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1868-L1877","name":"Function.Injective.swap_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.Injective.swap_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1861-L1862","name":"Equiv.instIsRightCancelCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","kind":"instance","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.instIsRightCancelCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1858-L1859","name":"Equiv.instIsLeftCancelCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","kind":"instance","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.instIsLeftCancelCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1855-L1856","name":"Equiv.instIsIdempotentCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","kind":"instance","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.instIsIdempotentCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1852-L1853","name":"Equiv.instIsAssociativeCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","kind":"instance","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.instIsAssociativeCoeEquivForAllForAllInstFunLikeEquivArrowCongrForAllForAll","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1849-L1849","name":"Equiv.semiconj₂_conj","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.semiconj₂_conj","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1846-L1846","name":"Equiv.semiconj_conj","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.semiconj_conj","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1829-L1837","name":"Equiv.piCongr'_symm_apply_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongr'_symm_apply_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1824-L1825","name":"Equiv.piCongr'_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongr'_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1819-L1821","name":"Equiv.coe_piCongr'","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.coe_piCongr'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1814-L1815","name":"Equiv.piCongr'","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongr'","doc":"Transport dependent functions through\nan equivalence of the base spaces and a family\nof equivalences of the matching fibres.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1796-L1801","name":"Equiv.piCongr_apply_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongr_apply_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1790-L1792","name":"Equiv.piCongr_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongr_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1785-L1787","name":"Equiv.coe_piCongr_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.coe_piCongr_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1780-L1781","name":"Equiv.piCongr","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongr","doc":"Transport dependent functions through\nan equivalence of the base spaces and a family\nof equivalences of the matching fibers.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1766-L1767","name":"Equiv.piCongrLeft","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongrLeft","doc":"Transporting dependent functions through an equivalence of the base,\nexpressed as a \"simplification\".\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1745-L1752","name":"Equiv.piCongrLeft'","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongrLeft'","doc":"Transport dependent functions through an equivalence of the base space.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1744-L1744","name":"Equiv.piCongrLeft'_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongrLeft'_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1744-L1744","name":"Equiv.piCongrLeft'_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongrLeft'_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1726-L1733","name":"Function.Injective.map_swap","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.Injective.map_swap","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1722-L1723","name":"PLift.eq_up_iff_down_eq","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#PLift.eq_up_iff_down_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1716-L1717","name":"Function.Involutive.toPerm_involutive","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.Involutive.toPerm_involutive","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1712-L1713","name":"Function.Involutive.toPerm_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.Involutive.toPerm_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1707-L1708","name":"Function.Involutive.coe_toPerm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.Involutive.coe_toPerm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1702-L1703","name":"Function.Involutive.toPerm","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Function.Involutive.toPerm","doc":"Convert an involutive function `f` to a permutation with `toFun = invFun = f`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1691-L1692","name":"Equiv.setValue_eq","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.setValue_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1686-L1687","name":"Equiv.setValue","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.setValue","doc":"Augment an equivalence with a prescribed mapping `f a = b` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1672-L1680","name":"Equiv.Perm.sumCongr_refl_swap","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.sumCongr_refl_swap","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1661-L1668","name":"Equiv.Perm.sumCongr_swap_refl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.sumCongr_swap_refl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1645-L1655","name":"Equiv.swap_apply_ne_self_iff","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_apply_ne_self_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1641-L1642","name":"Equiv.swap_apply_eq_iff","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_apply_eq_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1630-L1638","name":"Equiv.apply_swap_eq_self","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.apply_swap_eq_self","doc":"A function is invariant to a swap if it is equal at both elements "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1625-L1626","name":"Equiv.swap_apply_self","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_apply_self","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1619-L1621","name":"Equiv.trans_swap_trans_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.trans_swap_trans_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1608-L1615","name":"Equiv.symm_trans_swap_trans","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.symm_trans_swap_trans","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1602-L1604","name":"Equiv.comp_swap_eq_update","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.comp_swap_eq_update","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1598-L1599","name":"Equiv.swap_eq_update","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_eq_update","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1592-L1595","name":"Equiv.swap_comp_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_comp_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1587-L1589","name":"Equiv.swap_eq_refl_iff","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_eq_refl_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1582-L1583","name":"Equiv.symm_swap","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.symm_swap","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1577-L1578","name":"Equiv.swap_swap","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_swap","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1572-L1573","name":"Equiv.swap_apply_of_ne_of_ne","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_apply_of_ne_of_ne","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1568-L1569","name":"Equiv.swap_apply_right","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_apply_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1563-L1564","name":"Equiv.swap_apply_left","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_apply_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1558-L1559","name":"Equiv.swap_apply_def","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_apply_def","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1554-L1555","name":"Equiv.swap_comm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_comm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1550-L1551","name":"Equiv.swap_self","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap_self","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1544-L1546","name":"Equiv.swap","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swap","doc":"`swap a b` is the permutation that swaps `a` and `b` and\nleaves other values as is. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1535-L1539","name":"Equiv.swapCore_comm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swapCore_comm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1520-L1532","name":"Equiv.swapCore_swapCore","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swapCore_swapCore","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1515-L1517","name":"Equiv.swapCore_self","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swapCore_self","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1511-L1512","name":"Equiv.swapCore","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.swapCore","doc":"A helper function for `Equiv.swap`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1499-L1503","name":"Equiv.subtypeQuotientEquivQuotientSubtype_symm_mk","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeQuotientEquivQuotientSubtype_symm_mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1491-L1495","name":"Equiv.subtypeQuotientEquivQuotientSubtype_mk","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeQuotientEquivQuotientSubtype_mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1474-L1487","name":"Equiv.subtypeQuotientEquivQuotientSubtype","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeQuotientEquivQuotientSubtype","doc":"Subtype of the quotient is equivalent to the quotient of the subtype. Let `α` be a setoid with\nequivalence relation `~`. Let `p₂` be a predicate on the quotient type `α/~`, and `p₁` be the lift\nof this predicate to `α`: `p₁ a ↔ p₂ ⟦a⟧`. Let `~₂` be the restriction of `~` to `{x // p₁ x}`.\nThen `{x // p₂ x}` is equivalent to the quotient of `{x // p₁ x}` by `~₂`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1463-L1465","name":"Equiv.Perm.extendDomain_trans","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.extendDomain_trans","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1459-L1460","name":"Equiv.Perm.extendDomain_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.extendDomain_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1454-L1455","name":"Equiv.Perm.extendDomain_refl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.extendDomain_refl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1449-L1450","name":"Equiv.Perm.extendDomain_apply_not_subtype","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.extendDomain_apply_not_subtype","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1444-L1446","name":"Equiv.Perm.extendDomain_apply_subtype","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.extendDomain_apply_subtype","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1440-L1441","name":"Equiv.Perm.extendDomain_apply_image","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.extendDomain_apply_image","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1435-L1436","name":"Equiv.Perm.extendDomain","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.extendDomain","doc":"Extend the domain of `e : Equiv.Perm α` to one that is over `β` via `f : α → Subtype p`,\nwhere `p : β → Prop`, permuting only the `b : β` that satisfy `p b`.\nThis can be used to extend the domain across a function `f : α → β`,\nkeeping everything outside of `Set.range f` fixed. For this use-case `Equiv` given by `f` can\nbe constructed by `Equiv.of_leftInverse'` or `Equiv.of_leftInverse` when there is a known\ninverse, or `Equiv.ofInjective` in the general case.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1422-L1422","name":"Equiv.instCanLiftForAllEquivCoeInstFunLikeEquivBijective","kind":"instance","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.instCanLiftForAllEquivCoeInstFunLikeEquivBijective","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1417-L1419","name":"Equiv.ofBijective_symm_apply_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.ofBijective_symm_apply_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1411-L1413","name":"Equiv.ofBijective_apply_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.ofBijective_apply_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1403-L1407","name":"Equiv.ofBijective","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.ofBijective","doc":"If `f` is a bijective function, then its domain is equivalent to its codomain. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1402-L1402","name":"Equiv.ofBijective_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.ofBijective_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1393-L1396","name":"Equiv.subtypeEquivCodomain_symm_apply_ne","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivCodomain_symm_apply_ne","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1388-L1390","name":"Equiv.subtypeEquivCodomain_symm_apply_eq","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivCodomain_symm_apply_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1383-L1385","name":"Equiv.subtypeEquivCodomain_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivCodomain_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1371-L1379","name":"Equiv.coe_subtypeEquivCodomain_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.coe_subtypeEquivCodomain_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1366-L1368","name":"Equiv.subtypeEquivCodomain_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivCodomain_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1359-L1362","name":"Equiv.coe_subtypeEquivCodomain","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.coe_subtypeEquivCodomain","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1347-L1355","name":"Equiv.subtypeEquivCodomain","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivCodomain","doc":"The type of all functions `X → Y` with prescribed values for all `x' ≠ x`\nis equivalent to the codomain `Y`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1332-L1334","name":"Equiv.funSplitAt","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.funSplitAt","doc":"A product of copies of a type can be split as the binary product of one copy and the product\nof all the remaining copies. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1331-L1331","name":"Equiv.funSplitAt_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.funSplitAt_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1331-L1331","name":"Equiv.funSplitAt_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.funSplitAt_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1312-L1324","name":"Equiv.piSplitAt","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piSplitAt","doc":"A product of types can be split as the binary product of one of the types and the product\nof all the remaining types. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1311-L1311","name":"Equiv.piSplitAt_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piSplitAt_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1311-L1311","name":"Equiv.piSplitAt_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piSplitAt_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1291-L1304","name":"Equiv.piEquivPiSubtypeProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piEquivPiSubtypeProd","doc":"The type `∀ (i : α), β i` can be split as a product by separating the indices in `α`\ndepending on whether they satisfy a predicate `p` or not. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1290-L1290","name":"Equiv.piEquivPiSubtypeProd_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piEquivPiSubtypeProd_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1290-L1290","name":"Equiv.piEquivPiSubtypeProd_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piEquivPiSubtypeProd_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1280-L1285","name":"Equiv.subtypeProdEquivSigmaSubtype","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeProdEquivSigmaSubtype","doc":"A subtype of a `Prod` is equivalent to a sigma type whose fibers are subtypes. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1271-L1276","name":"Equiv.subtypeProdEquivProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeProdEquivProd","doc":"A subtype of a product defined by componentwise conditions\nis equivalent to a product of subtypes. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1256-L1266","name":"Equiv.subtypePiEquivPi","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypePiEquivPi","doc":"The type of functions `f : ∀ a, β a` such that for all `a` we have `p a (f a)` is equivalent\nto the type of functions `∀ a, {b : β a // p a b}`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1244-L1251","name":"Equiv.piEquivSubtypeSigma","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piEquivSubtypeSigma","doc":"The `Pi`-type `∀ i, π i` is equivalent to the type of sections `f : ι → Σ i, π i` of the\n`Sigma` type such that for all `i` we have `(f i).fst = i`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1229-L1239","name":"Equiv.sigmaOptionEquivOfSome","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaOptionEquivOfSome","doc":"A sigma type over an `Option` is equivalent to the sigma set over the original type,\nif the fiber is empty at none. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1212-L1224","name":"Equiv.sigmaSubtypeFiberEquivSubtype","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaSubtypeFiberEquivSubtype","doc":"If for each `x` we have `p x ↔ q (f x)`, then `Σ y : {y // q y}, f ⁻¹' {y}` is equivalent\nto `{x // p x}`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1203-L1207","name":"Equiv.sigmaSubtypeFiberEquiv","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaSubtypeFiberEquiv","doc":"If a predicate `p : β → Prop` is true on the range of a map `f : α → β`, then\n`Σ y : {y // p y}, {x // f x = y}` is equivalent to `α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1196-L1198","name":"Equiv.sigmaSubtypeEquivOfSubset","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaSubtypeEquivOfSubset","doc":"A sigma type over a subtype is equivalent to the sigma set over the original type,\nif the fiber is empty outside of the subset "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1188-L1191","name":"Equiv.subtypeSigmaEquiv","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeSigmaEquiv","doc":"A subtype of a sigma-type is a sigma-type over a subtype. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1181-L1182","name":"Equiv.subtypeUnivEquiv","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeUnivEquiv","doc":"If a proposition holds for all elements, then the subtype is\nequivalent to the original type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1180-L1180","name":"Equiv.subtypeUnivEquiv_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeUnivEquiv_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1180-L1180","name":"Equiv.subtypeUnivEquiv_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeUnivEquiv_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1171-L1173","name":"Equiv.subtypeSubtypeEquivSubtype","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeSubtypeEquivSubtype","doc":"If the outer subtype has more restrictive predicate than the inner one,\nthen we can drop the latter. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1170-L1170","name":"Equiv.subtypeSubtypeEquivSubtype_symm_apply_coe_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeSubtypeEquivSubtype_symm_apply_coe_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1170-L1170","name":"Equiv.subtypeSubtypeEquivSubtype_apply_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeSubtypeEquivSubtype_apply_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1160-L1163","name":"Equiv.subtypeSubtypeEquivSubtypeInter","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeSubtypeEquivSubtypeInter","doc":"A subtype of a subtype is equivalent to the subtype of elements satisfying both predicates. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1159-L1159","name":"Equiv.subtypeSubtypeEquivSubtypeInter_symm_apply_coe_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeSubtypeEquivSubtypeInter_symm_apply_coe_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1159-L1159","name":"Equiv.subtypeSubtypeEquivSubtypeInter_apply_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeSubtypeEquivSubtypeInter_apply_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1147-L1153","name":"Equiv.subtypeSubtypeEquivSubtypeExists","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeSubtypeEquivSubtypeExists","doc":"A subtype of a subtype is equivalent to the subtype of elements satisfying both predicates. This\nversion allows the “inner” predicate to depend on `h : p a`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1146-L1146","name":"Equiv.subtypeSubtypeEquivSubtypeExists_symm_apply_coe_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeSubtypeEquivSubtypeExists_symm_apply_coe_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1146-L1146","name":"Equiv.subtypeSubtypeEquivSubtypeExists_apply_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeSubtypeEquivSubtypeExists_apply_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1140-L1141","name":"Equiv.subtypeEquivProp","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivProp","doc":"If two predicates are equal, then the corresponding subtypes are equivalent. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1134-L1136","name":"Equiv.subtypeEquivOfSubtype'","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivOfSubtype'","doc":"If `α ≃ β`, then for any predicate `p : α → Prop` the subtype `{a // p a}` is equivalent\nto the subtype `{b // p (e.symm b)}`. This version is used by `equiv_rw`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1128-L1129","name":"Equiv.subtypeEquivOfSubtype","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivOfSubtype","doc":"If `α ≃ β`, then for any predicate `p : β → Prop` the subtype `{a // p (e a)}` is equivalent\nto the subtype `{b // p b}`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1120-L1121","name":"Equiv.subtypeEquivRight","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivRight","doc":"If two predicates `p` and `q` are pointwise equivalent, then `{x // p x}` is equivalent to\n`{x // q x}`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1119-L1119","name":"Equiv.subtypeEquivRight_symm_apply_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivRight_symm_apply_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1119-L1119","name":"Equiv.subtypeEquivRight_apply_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquivRight_apply_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1111-L1114","name":"Equiv.subtypeEquiv_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquiv_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1103-L1107","name":"Equiv.subtypeEquiv_trans","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquiv_trans","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1094-L1099","name":"Equiv.subtypeEquiv_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquiv_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1087-L1090","name":"Equiv.subtypeEquiv_refl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquiv_refl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1078-L1083","name":"Equiv.subtypeEquiv","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeEquiv","doc":"If `α` is equivalent to `β` and the predicates `p : α → Prop` and `q : β → Prop` are equivalent\nat corresponding points, then `{a // p a}` is equivalent to `{b // q b}`.\nFor the statement where `α = β`, that is, `e : perm α`, see `Perm.subtypePerm`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1067-L1068","name":"Equiv.isEmpty","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.isEmpty","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1063-L1064","name":"Equiv.isEmpty_congr","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.isEmpty_congr","doc":"If `α` is equivalent to `β`, then `IsEmpty α` is equivalent to `IsEmpty β`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1055-L1059","name":"Equiv.uniqueCongr","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.uniqueCongr","doc":"If `α` is equivalent to `β`, then `Unique α` is equivalent to `Unique β`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1047-L1051","name":"Equiv.listEquivOfEquiv","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.listEquivOfEquiv","doc":"An equivalence between `α` and `β` generates an equivalence between `List α` and `List β`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1037-L1041","name":"Equiv.intEquivNatSumNat","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.intEquivNatSumNat","doc":"The type of integer numbers is equivalent to `ℕ ⊕ ℕ`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1032-L1033","name":"Equiv.natSumPUnitEquivNat","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.natSumPUnitEquivNat","doc":"`ℕ ⊕ PUnit` is equivalent to `ℕ`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1024-L1028","name":"Equiv.natEquivNatSumPUnit","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.natEquivNatSumPUnit","doc":"The set of natural numbers is equivalent to `ℕ ⊕ PUnit`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1008-L1012","name":"Equiv.boolArrowEquivProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.boolArrowEquivProd","doc":"The function type `Bool → α` is equivalent to `α × α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1007-L1007","name":"Equiv.boolArrowEquivProd_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.boolArrowEquivProd_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L1007-L1007","name":"Equiv.boolArrowEquivProd_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.boolArrowEquivProd_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L997-L1001","name":"Equiv.boolProdEquivSum","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.boolProdEquivSum","doc":"The product `Bool × α` is equivalent to `α ⊕ α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L996-L996","name":"Equiv.boolProdEquivSum_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.boolProdEquivSum_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L996-L996","name":"Equiv.boolProdEquivSum_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.boolProdEquivSum_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L986-L992","name":"Equiv.sigmaNatSucc","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaNatSucc","doc":"An equivalence that separates out the 0th fiber of `(Σ (n : ℕ), f n)`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L977-L982","name":"Equiv.sigmaProdDistrib","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaProdDistrib","doc":"The product of an indexed sum of types (formally, a `Sigma`-type `Σ i, α i`) by a type `β` is\nequivalent to the sum of products `Σ i, (α i × β)`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L966-L970","name":"Equiv.sigmaSumDistrib","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaSumDistrib","doc":"An indexed sum of disjoint sums of types is equivalent to the sum of the indexed sums. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L965-L965","name":"Equiv.sigmaSumDistrib_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaSumDistrib_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L965-L965","name":"Equiv.sigmaSumDistrib_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaSumDistrib_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L959-L961","name":"Equiv.prodSumDistrib_symm_apply_right","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodSumDistrib_symm_apply_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L953-L955","name":"Equiv.prodSumDistrib_symm_apply_left","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodSumDistrib_symm_apply_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L947-L949","name":"Equiv.prodSumDistrib_apply_right","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodSumDistrib_apply_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L941-L943","name":"Equiv.prodSumDistrib_apply_left","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodSumDistrib_apply_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L933-L937","name":"Equiv.prodSumDistrib","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodSumDistrib","doc":"Type product is left distributive with respect to type sum up to an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L927-L929","name":"Equiv.sumProdDistrib_symm_apply_right","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumProdDistrib_symm_apply_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L921-L923","name":"Equiv.sumProdDistrib_symm_apply_left","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumProdDistrib_symm_apply_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L915-L917","name":"Equiv.sumProdDistrib_apply_right","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumProdDistrib_apply_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L909-L911","name":"Equiv.sumProdDistrib_apply_left","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumProdDistrib_apply_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L902-L905","name":"Equiv.sumProdDistrib","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumProdDistrib","doc":"Type product is right distributive with respect to type sum up to an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L896-L898","name":"Equiv.sumArrowEquivProdArrow_symm_apply_inr","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumArrowEquivProdArrow_symm_apply_inr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L890-L892","name":"Equiv.sumArrowEquivProdArrow_symm_apply_inl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumArrowEquivProdArrow_symm_apply_inl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L884-L886","name":"Equiv.sumArrowEquivProdArrow_apply_snd","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumArrowEquivProdArrow_apply_snd","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L878-L880","name":"Equiv.sumArrowEquivProdArrow_apply_fst","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumArrowEquivProdArrow_apply_fst","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L871-L874","name":"Equiv.sumArrowEquivProdArrow","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumArrowEquivProdArrow","doc":"The type of functions on a sum type `α ⊕ β` is equivalent to the type of pairs of functions\non `α` and on `β`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L860-L864","name":"Equiv.arrowProdEquivProdArrow","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.arrowProdEquivProdArrow","doc":"The type of functions to a product `α × β` is equivalent to the type of pairs of functions\n`γ → α` and `γ → β`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L846-L851","name":"Equiv.Perm.fst_prodExtendRight","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.fst_prodExtendRight","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L839-L842","name":"Equiv.Perm.eq_of_prodExtendRight_ne","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.eq_of_prodExtendRight_ne","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L834-L836","name":"Equiv.Perm.prodExtendRight_apply_ne","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.prodExtendRight_apply_ne","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L830-L831","name":"Equiv.Perm.prodExtendRight_apply_eq","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.prodExtendRight_apply_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L810-L826","name":"Equiv.Perm.prodExtendRight","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.prodExtendRight","doc":"`prodExtendRight a e` extends `e : Perm β` to `Perm (α × β)` by sending `(a, b)` to\n`(a, e b)` and keeping the other `(a', b)` fixed. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L789-L797","name":"Equiv.prodShear","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodShear","doc":"A variation on `Equiv.prodCongr` where the equivalence in the second component can depend\non the first component. A typical example is a shear mapping, explaining the name of this\ndeclaration. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L788-L788","name":"Equiv.prodShear_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodShear_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L788-L788","name":"Equiv.prodShear_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodShear_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L780-L782","name":"Equiv.ofFiberEquiv_map","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.ofFiberEquiv_map","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L774-L775","name":"Equiv.ofFiberEquiv","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.ofFiberEquiv","doc":"A family of equivalences between fibers gives an equivalence between domains. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L773-L773","name":"Equiv.ofFiberEquiv_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.ofFiberEquiv_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L773-L773","name":"Equiv.ofFiberEquiv_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.ofFiberEquiv_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L763-L768","name":"Equiv.sigmaEquivProd_sigmaCongrRight","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaEquivProd_sigmaCongrRight","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L756-L760","name":"Equiv.sigmaCongrRight_sigmaEquivProd","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaCongrRight_sigmaEquivProd","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L750-L753","name":"Equiv.prodCongrRight_trans_prodComm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongrRight_trans_prodComm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L743-L746","name":"Equiv.prodCongrLeft_trans_prodComm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongrLeft_trans_prodComm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L736-L739","name":"Equiv.prodCongr_refl_left","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongr_refl_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L732-L733","name":"Equiv.prodCongrRight_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongrRight_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L720-L728","name":"Equiv.prodCongrRight","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongrRight","doc":"A family of equivalences `∀ (a : α₁), β₁ ≃ β₂` generates an equivalence\nbetween `α₁ × β₁` and `α₁ × β₂`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L712-L715","name":"Equiv.prodCongr_refl_right","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongr_refl_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L708-L709","name":"Equiv.prodCongrLeft_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongrLeft_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L696-L704","name":"Equiv.prodCongrLeft","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongrLeft","doc":"A family of equivalences `∀ (a : α₁), β₁ ≃ β₂` generates an equivalence\nbetween `β₁ × α₁` and `β₂ × α₁`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L680-L685","name":"Equiv.piCurry","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCurry","doc":"Dependent `curry` equivalence: the type of dependent functions on `Σ i, β i` is equivalent\nto the type of dependent functions of two arguments (i.e., functions to the space of functions).\n\nThis is `Sigma.curry` and `Sigma.uncurry` together as an equiv. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L672-L673","name":"Equiv.piComm_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piComm_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L666-L667","name":"Equiv.piComm","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piComm","doc":"Given `φ : α → β → Sort*`, we have an equivalence between `∀ a b, φ a b` and `∀ b a, φ a b`.\nThis is `Function.swap` as an `Equiv`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L665-L665","name":"Equiv.piComm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piComm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L658-L660","name":"Equiv.piCongrRight","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piCongrRight","doc":"A family of equivalences `∀ a, β₁ a ≃ β₂ a` generates an equivalence between `∀ a, β₁ a` and\n`∀ a, β₂ a`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L647-L649","name":"Equiv.subtypePreimage_symm_apply_coe_neg","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypePreimage_symm_apply_coe_neg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L642-L644","name":"Equiv.subtypePreimage_symm_apply_coe_pos","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypePreimage_symm_apply_coe_pos","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L623-L637","name":"Equiv.subtypePreimage","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypePreimage","doc":"For a fixed function `x₀ : {a // p a} → β` defined on a subtype of `α`,\nthe subtype of functions `x : α → β` that agree with `x₀` on the subtype `{a // p a}`\nis naturally equivalent to the type of functions `{a // ¬ p a} → β`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L622-L622","name":"Equiv.subtypePreimage_symm_apply_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypePreimage_symm_apply_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L622-L622","name":"Equiv.subtypePreimage_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypePreimage_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L602-L610","name":"Equiv.Perm.subtypeCongr.trans","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.subtypeCongr.trans","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L592-L598","name":"Equiv.Perm.subtypeCongr.symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.subtypeCongr.symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L585-L588","name":"Equiv.Perm.subtypeCongr.refl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.subtypeCongr.refl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L580-L581","name":"Equiv.Perm.subtypeCongr.right_apply_subtype","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.subtypeCongr.right_apply_subtype","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L575-L576","name":"Equiv.Perm.subtypeCongr.right_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.subtypeCongr.right_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L570-L571","name":"Equiv.Perm.subtypeCongr.left_apply_subtype","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.subtypeCongr.left_apply_subtype","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L565-L566","name":"Equiv.Perm.subtypeCongr.left_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.subtypeCongr.left_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L559-L561","name":"Equiv.Perm.subtypeCongr.apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.subtypeCongr.apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L555-L556","name":"Equiv.Perm.subtypeCongr","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.subtypeCongr","doc":"Combining permutations on `ε` that permute only inside or outside the subtype\nsplit induced by `p : ε → Prop` constructs a permutation on `ε`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L544-L546","name":"Equiv.subtypeCongr","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.subtypeCongr","doc":"Combines an `Equiv` between two subtypes with an `Equiv` between their complements to form a\npermutation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L537-L539","name":"Equiv.sumCompl_apply_symm_of_neg","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumCompl_apply_symm_of_neg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L531-L533","name":"Equiv.sumCompl_apply_symm_of_pos","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumCompl_apply_symm_of_pos","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L525-L527","name":"Equiv.sumCompl_apply_inr","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumCompl_apply_inr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L519-L521","name":"Equiv.sumCompl_apply_inl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumCompl_apply_inl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L505-L515","name":"Equiv.sumCompl","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumCompl","doc":"For any predicate `p` on `α`,\nthe sum of the two subtypes `{a // p a}` and its complement `{a // ¬ p a}`\nis naturally equivalent to `α`.\n\nSee `subtypeOrEquiv` for sum types over subtypes `{x // p x}` and `{x // q x}`\nthat are not necessarily `IsCompl p q`.  "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L488-L489","name":"Equiv.sigmaFiberEquiv","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaFiberEquiv","doc":"`sigmaFiberEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all fibres of `f` and the total space `α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L487-L487","name":"Equiv.sigmaFiberEquiv_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaFiberEquiv_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L487-L487","name":"Equiv.sigmaFiberEquiv_symm_apply_snd_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaFiberEquiv_symm_apply_snd_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L487-L487","name":"Equiv.sigmaFiberEquiv_symm_apply_fst","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sigmaFiberEquiv_symm_apply_fst","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L476-L481","name":"Equiv.sumEquivSigmaBool","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumEquivSigmaBool","doc":"`α ⊕ β` is equivalent to a `Sigma`-type over `Bool`. Note that this definition assumes `α` and\n`β` to be types from the same universe, so it cannot by used directly to transfer theorems about\nsigma types to theorems about sum types. In many cases one can use `ULift` to work around this\ndifficulty. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L462-L467","name":"Equiv.piOptionEquivProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piOptionEquivProd","doc":"The product over `Option α` of `β a` is the binary product of the\nproduct over `α` of `β (some α)` and `β none` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L461-L461","name":"Equiv.piOptionEquivProd_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piOptionEquivProd_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L461-L461","name":"Equiv.piOptionEquivProd_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.piOptionEquivProd_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L450-L454","name":"Equiv.optionIsSomeEquiv","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.optionIsSomeEquiv","doc":"The set of `x : Option α` such that `isSome x` is equivalent to `α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L449-L449","name":"Equiv.optionIsSomeEquiv_symm_apply_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.optionIsSomeEquiv_symm_apply_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L449-L449","name":"Equiv.optionIsSomeEquiv_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.optionIsSomeEquiv_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L444-L445","name":"Equiv.optionEquivSumPUnit_symm_inr","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.optionEquivSumPUnit_symm_inr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L439-L440","name":"Equiv.optionEquivSumPUnit_symm_inl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.optionEquivSumPUnit_symm_inl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L434-L435","name":"Equiv.optionEquivSumPUnit_coe","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.optionEquivSumPUnit_coe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L429-L430","name":"Equiv.optionEquivSumPUnit_some","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.optionEquivSumPUnit_some","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L424-L425","name":"Equiv.optionEquivSumPUnit_none","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.optionEquivSumPUnit_none","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L417-L420","name":"Equiv.optionEquivSumPUnit","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.optionEquivSumPUnit","doc":"`Option α` is equivalent to `α ⊕ PUnit` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L412-L413","name":"Equiv.emptySum_apply_inr","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.emptySum_apply_inr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L406-L407","name":"Equiv.emptySum","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.emptySum","doc":"The sum of `IsEmpty` with any type is equivalent to that type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L405-L405","name":"Equiv.emptySum_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.emptySum_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L400-L401","name":"Equiv.sumEmpty_apply_inl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumEmpty_apply_inl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L388-L395","name":"Equiv.sumEmpty","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumEmpty","doc":"Sum with `IsEmpty` is equivalent to the original type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L387-L387","name":"Equiv.sumEmpty_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumEmpty_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L382-L383","name":"Equiv.sumAssoc_symm_apply_inr_inr","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumAssoc_symm_apply_inr_inr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L376-L378","name":"Equiv.sumAssoc_symm_apply_inr_inl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumAssoc_symm_apply_inr_inl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L371-L372","name":"Equiv.sumAssoc_symm_apply_inl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumAssoc_symm_apply_inl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L366-L367","name":"Equiv.sumAssoc_apply_inr","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumAssoc_apply_inr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L361-L362","name":"Equiv.sumAssoc_apply_inl_inr","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumAssoc_apply_inl_inr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L356-L357","name":"Equiv.sumAssoc_apply_inl_inl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumAssoc_apply_inl_inl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L348-L352","name":"Equiv.sumAssoc","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumAssoc","doc":"Sum of types is associative up to an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L343-L344","name":"Equiv.sumComm_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumComm_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L337-L338","name":"Equiv.sumComm","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumComm","doc":"Sum of types is commutative up to an equivalence. This is `Sum.swap` as an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L336-L336","name":"Equiv.sumComm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumComm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L330-L332","name":"Equiv.boolEquivPUnitSumPUnit","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.boolEquivPUnitSumPUnit","doc":"`Bool` is equivalent the sum of two `PUnit`s. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L323-L324","name":"Equiv.Perm.sumCongr_refl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.sumCongr_refl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L318-L320","name":"Equiv.Perm.sumCongr_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.sumCongr_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L313-L315","name":"Equiv.Perm.sumCongr_trans","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.sumCongr_trans","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L306-L308","name":"Equiv.Perm.sumCongr_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.sumCongr_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L301-L302","name":"Equiv.Perm.sumCongr","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.Perm.sumCongr","doc":"Combine a permutation of `α` and of `β` into a permutation of `α ⊕ β`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L292-L294","name":"Equiv.sumCongr_refl","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumCongr_refl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L286-L288","name":"Equiv.sumCongr_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumCongr_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L279-L282","name":"Equiv.sumCongr_trans","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumCongr_trans","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L273-L275","name":"Equiv.sumPSum","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumPSum","doc":"Combine two `Equiv`s using `Sum` in the domain and `PSum` in the codomain. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L267-L269","name":"Equiv.psumSum","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.psumSum","doc":"Combine two `Equiv`s using `PSum` in the domain and `Sum` in the codomain. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L259-L263","name":"Equiv.psumCongr","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.psumCongr","doc":"If `α ≃ α'` and `β ≃ β'`, then `PSum α β ≃ PSum α' β'`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L253-L254","name":"Equiv.sumCongr","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumCongr","doc":"If `α ≃ α'` and `β ≃ β'`, then `α ⊕ β ≃ α' ⊕ β'`. This is `Sum.map` as an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L252-L252","name":"Equiv.sumCongr_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.sumCongr_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L244-L248","name":"Equiv.psumEquivSum","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.psumEquivSum","doc":"`PSum` is equivalent to `Sum`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L233-L234","name":"Equiv.pemptyProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pemptyProd","doc":"`PEmpty` type is a left absorbing element for type product up to an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L228-L229","name":"Equiv.prodPEmpty","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodPEmpty","doc":"`PEmpty` type is a right absorbing element for type product up to an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L223-L224","name":"Equiv.emptyProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.emptyProd","doc":"`Empty` type is a left absorbing element for type product up to an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L218-L219","name":"Equiv.prodEmpty","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodEmpty","doc":"`Empty` type is a right absorbing element for type product up to an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L212-L214","name":"Equiv.uniqueProd_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.uniqueProd_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L207-L208","name":"Equiv.uniqueProd_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.uniqueProd_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L203-L204","name":"Equiv.coe_uniqueProd","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.coe_uniqueProd","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L198-L199","name":"Equiv.uniqueProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.uniqueProd","doc":"Any `Unique` type is a left identity for type product up to equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L192-L194","name":"Equiv.prodUnique_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodUnique_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L187-L188","name":"Equiv.prodUnique_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodUnique_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L183-L184","name":"Equiv.coe_prodUnique","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.coe_prodUnique","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L178-L179","name":"Equiv.prodUnique","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodUnique","doc":"Any `Unique` type is a right identity for type product up to equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L169-L172","name":"Equiv.punitProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.punitProd","doc":"`PUnit` is a left identity for type product up to an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L168-L168","name":"Equiv.punitProd_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.punitProd_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L168-L168","name":"Equiv.punitProd_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.punitProd_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L161-L162","name":"Equiv.prodPUnit","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodPUnit","doc":"`PUnit` is a right identity for type product up to an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L160-L160","name":"Equiv.prodPUnit_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodPUnit_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L160-L160","name":"Equiv.prodPUnit_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodPUnit_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L148-L152","name":"Equiv.curry","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.curry","doc":"`γ`-valued functions on `α × β` are equivalent to functions `α → β → γ`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L147-L147","name":"Equiv.curry_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.curry_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L147-L147","name":"Equiv.curry_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.curry_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L139-L141","name":"Equiv.prodAssoc","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodAssoc","doc":"Type product is associative up to an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L138-L138","name":"Equiv.prodAssoc_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodAssoc_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L138-L138","name":"Equiv.prodAssoc_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodAssoc_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L133-L134","name":"Equiv.prodComm_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodComm_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L128-L129","name":"Equiv.prodComm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodComm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L123-L124","name":"Equiv.coe_prodComm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.coe_prodComm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L118-L119","name":"Equiv.prodComm","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodComm","doc":"Type product is commutative up to an equivalence: `α × β ≃ β × α`. This is `Prod.swap` as an\nequivalence."},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L111-L113","name":"Equiv.prodCongr_symm","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongr_symm","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L105-L106","name":"Equiv.prodCongr","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongr","doc":"Product of two equivalences. If `α₁ ≃ α₂` and `β₁ ≃ β₂`, then `α₁ × β₁ ≃ α₂ × β₂`. This is\n`Prod.map` as an equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L104-L104","name":"Equiv.prodCongr_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodCongr_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L95-L96","name":"Equiv.pprodEquivProdPLift","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodEquivProdPLift","doc":"`PProd α β` is equivalent to `PLift α × PLift β` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L94-L94","name":"Equiv.pprodEquivProdPLift_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodEquivProdPLift_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L94-L94","name":"Equiv.pprodEquivProdPLift_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodEquivProdPLift_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L86-L88","name":"Equiv.prodPProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodPProd","doc":"Combine two equivalences using `PProd` in the codomain and `Prod` in the domain. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L85-L85","name":"Equiv.prodPProd_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodPProd_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L85-L85","name":"Equiv.prodPProd_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.prodPProd_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L77-L79","name":"Equiv.pprodProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodProd","doc":"Combine two equivalences using `PProd` in the domain and `Prod` in the codomain. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L76-L76","name":"Equiv.pprodProd_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodProd_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L76-L76","name":"Equiv.pprodProd_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodProd_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L67-L71","name":"Equiv.pprodCongr","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodCongr","doc":"Product of two equivalences, in terms of `PProd`. If `α ≃ β` and `γ ≃ δ`, then\n`PProd α γ ≃ PProd β δ`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L66-L66","name":"Equiv.pprodCongr_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodCongr_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L54-L58","name":"Equiv.pprodEquivProd","kind":"def","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodEquivProd","doc":"`PProd α β` is equivalent to `α × β` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L53-L53","name":"Equiv.pprodEquivProd_symm_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodEquivProd_symm_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Basic.lean#L53-L53","name":"Equiv.pprodEquivProd_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Basic.html#Equiv.pprodEquivProd_apply","doc":""}]}