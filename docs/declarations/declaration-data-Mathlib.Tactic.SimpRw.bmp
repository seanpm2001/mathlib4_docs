{"name":"Mathlib.Tactic.SimpRw","instances":[],"imports":["Init","Lean"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/SimpRw.lean#L34-L64","name":"Mathlib.Tactic.tacticSimp_rw__","kind":"def","docLink":"./Mathlib/Tactic/SimpRw.html#Mathlib.Tactic.tacticSimp_rw__","doc":"`simp_rw` functions as a mix of `simp` and `rw`. Like `rw`, it applies each\nrewrite rule in the given order, but like `simp` it repeatedly applies these\nrules and also under binders like `∀ x, ...`, `∃ x, ...` and `λ x, ...`.\nUsage:\n\n- `simp_rw [lemma_1, ..., lemma_n]` will rewrite the goal by applying the\n  lemmas in that order. A lemma preceded by `←` is applied in the reverse direction.\n- `simp_rw [lemma_1, ..., lemma_n] at h₁ ... hₙ` will rewrite the given hypotheses.\n- `simp_rw [...] at *` rewrites in the whole context: all hypotheses and the goal.\n\nLemmas passed to `simp_rw` must be expressions that are valid arguments to `simp`.\nFor example, neither `simp` nor `rw` can solve the following, but `simp_rw` can:\n\n```lean\nexample {a : ℕ}\n  (h1 : ∀ a b : ℕ, a - 1 ≤ b ↔ a ≤ b + 1)\n  (h2 : ∀ a b : ℕ, a ≤ b ↔ ∀ c, c < a → c < b) :\n  (∀ b, a - 1 ≤ b) = ∀ b c : ℕ, c < a → c < b + 1 :=\nby simp_rw [h1, h2]\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/SimpRw.lean#L15-L32","name":"Mathlib.Tactic.withSimpRWRulesSeq","kind":"def","docLink":"./Mathlib/Tactic/SimpRw.html#Mathlib.Tactic.withSimpRWRulesSeq","doc":"A version of `withRWRulesSeq` (in core) that doesn't attempt to find equation lemmas, and simply\npasses the rw rules on to `x`. "}]}