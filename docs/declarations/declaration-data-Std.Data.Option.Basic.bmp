{"name":"Std.Data.Option.Basic","instances":[{"typeNames":["Option"],"name":"Option.instMembershipOption","className":"Membership"},{"typeNames":["Membership.mem","Option","Option.instMembershipOption"],"name":"Option.instForAllOptionDecidableForAllMemInstMembershipOption","className":"Decidable"},{"typeNames":["Exists","And","Membership.mem","Option","Option.instMembershipOption"],"name":"Option.instForAllOptionDecidableExistsAndMemInstMembershipOption","className":"Decidable"},{"typeNames":["Option"],"name":"Option.instForMOption","className":"ForM"},{"typeNames":["Option","inferInstance","Membership","Option","Option.instMembershipOption"],"name":"Option.instForIn'OptionInferInstanceMembershipInstMembershipOption","className":"ForIn'"}],"imports":["Init","Std.Classes.SetNotation","Std.Classes.LawfulMonad","Std.Tactic.NoMatch"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L143-L146","name":"Option.getDM","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.getDM","doc":"A monadic analogue of `Option.getD`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L139-L140","name":"Option.elimM","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.elimM","doc":"A monadic analogue of `Option.elim`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L134-L136","name":"Option.sequence","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.sequence","doc":"If you maybe have a monadic computation in a `[Monad m]` which produces a term of type `α`, then\nthere is a naturally associated way to always perform a computation in `m` which maybe produces a\nresult.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L125-L127","name":"Option.mapA","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.mapA","doc":"Like `Option.mapM` but for applicative functors. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L116-L122","name":"Option.instForIn'OptionInferInstanceMembershipInstMembershipOption","kind":"instance","docLink":"./Std/Data/Option/Basic.html#Option.instForIn'OptionInferInstanceMembershipInstMembershipOption","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L113-L114","name":"Option.instForMOption","kind":"instance","docLink":"./Std/Data/Option/Basic.html#Option.instForMOption","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L109-L111","name":"Option.forM","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.forM","doc":"Map a monadic function which returns `Unit` over an `Option`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L106-L106","name":"Option.join","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.join","doc":"Flatten an `Option` of `Option`, a specialization of `joinM`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L100-L103","name":"Option.pmap","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.pmap","doc":"Partial map. If `f : Π a, p a → β` is a partial function defined on `a : α` satisfying `p`,\nthen `pmap f x h` is essentially the same as `map f x` but is defined only when all members of `x`\nsatisfy `p`, using the proof to apply `f`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L91-L93","name":"Option.pbind","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.pbind","doc":"Partial bind. If for some `x : Option α`, `f : Π (a : α), a ∈ x → Option β` is a\npartial function defined on `a : α` giving an `Option β`, where `some a = x`,\nthen `pbind x f h` is essentially the same as `bind x f`\nbut is defined only when all `x = some a`, using the proof to apply `f`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L81-L82","name":"Option.Rel.none","kind":"ctor","docLink":"./Std/Data/Option/Basic.html#Option.Rel.none","doc":"`none ~ none` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L79-L80","name":"Option.Rel.some","kind":"ctor","docLink":"./Std/Data/Option/Basic.html#Option.Rel.some","doc":"If `a ~ b`, then `some a ~ some b` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L78-L82","name":"Option.Rel","kind":"inductive","docLink":"./Std/Data/Option/Basic.html#Option.Rel","doc":"Lifts a relation `α → β → Prop` to a relation `Option α → Option β → Prop` by just adding\n`none ~ none`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L70-L74","name":"Option.liftOrGet","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.liftOrGet","doc":"Two arguments failsafe function. Returns `f a b` if the inputs are `some a` and `some b`, and\n\"does nothing\" otherwise.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L62-L64","name":"Option.toArray","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.toArray","doc":"Cast of `Option` to `Array`. Returns `[a]` if the input is `some a`, and `[]` if it is `none`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L55-L57","name":"Option.toList","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.toList","doc":"Cast of `Option` to `List`. Returns `[a]` if the input is `some a`, and `[]` if it is `none`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L49-L50","name":"Option.guard","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.guard","doc":"`guard p a` returns `some a` if `p a` holds, otherwise `none`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L45-L46","name":"Option.get","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.get","doc":"Extracts the value `a` from an option that is known to be `some a` for some `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L40-L42","name":"Option.instForAllOptionDecidableExistsAndMemInstMembershipOption","kind":"instance","docLink":"./Std/Data/Option/Basic.html#Option.instForAllOptionDecidableExistsAndMemInstMembershipOption","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L34-L38","name":"Option.instForAllOptionDecidableForAllMemInstMembershipOption","kind":"instance","docLink":"./Std/Data/Option/Basic.html#Option.instForAllOptionDecidableForAllMemInstMembershipOption","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L31-L32","name":"Option.decidable_eq_none","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.decidable_eq_none","doc":"`o = none` is decidable even if the wrapped type does not have decidable equality.\nThis is not an instance because it is not definitionally equal to `instance : DecidableEq Option`.\nTry to use `o.isNone` or `o.isSome` instead.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L24-L24","name":"Option.some_inj","kind":"theorem","docLink":"./Std/Data/Option/Basic.html#Option.some_inj","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L21-L22","name":"Option.isNone_iff_eq_none","kind":"theorem","docLink":"./Std/Data/Option/Basic.html#Option.isNone_iff_eq_none","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L19-L19","name":"Option.mem_def","kind":"theorem","docLink":"./Std/Data/Option/Basic.html#Option.mem_def","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L17-L17","name":"Option.instMembershipOption","kind":"instance","docLink":"./Std/Data/Option/Basic.html#Option.instMembershipOption","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Option/Basic.lean#L13-L15","name":"Option.elim","kind":"def","docLink":"./Std/Data/Option/Basic.html#Option.elim","doc":"An elimination principle for `Option`. It is a nondependent version of `Option.recOn`. "}]}