{"name":"Mathlib.CategoryTheory.Limits.Final","instances":[{"typeNames":["Opposite","CategoryTheory.Category.opposite","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.op"],"name":"CategoryTheory.Functor.final_op_of_initial","className":"CategoryTheory.Functor.Final"},{"typeNames":["Opposite","CategoryTheory.Category.opposite","Opposite","CategoryTheory.Category.opposite","CategoryTheory.Functor.op"],"name":"CategoryTheory.Functor.initial_op_of_final","className":"CategoryTheory.Functor.Initial"},{"typeNames":[],"name":"CategoryTheory.Functor.final_of_isRightAdjoint","className":"CategoryTheory.Functor.Final"},{"typeNames":[],"name":"CategoryTheory.Functor.initial_of_isLeftAdjoint","className":"CategoryTheory.Functor.Initial"},{"typeNames":["CategoryTheory.StructuredArrow"],"name":"CategoryTheory.Functor.Final.instNonemptyStructuredArrow","className":"Nonempty"},{"typeNames":["CategoryTheory.Functor.comp"],"name":"CategoryTheory.Functor.Final.comp_hasColimit","className":"CategoryTheory.Limits.HasColimit"},{"typeNames":["CategoryTheory.Limits.colimit","CategoryTheory.Functor.comp","CategoryTheory.Functor.Final.comp_hasColimit","CategoryTheory.Limits.colimit","CategoryTheory.Limits.colimit.pre","CategoryTheory.Functor.Final.comp_hasColimit"],"name":"CategoryTheory.Functor.Final.colimit_pre_isIso","className":"CategoryTheory.IsIso"},{"typeNames":["CategoryTheory.CostructuredArrow"],"name":"CategoryTheory.Functor.Initial.instNonemptyCostructuredArrow","className":"Nonempty"},{"typeNames":["CategoryTheory.Functor.comp"],"name":"CategoryTheory.Functor.Initial.comp_hasLimit","className":"CategoryTheory.Limits.HasLimit"},{"typeNames":["CategoryTheory.Limits.limit","CategoryTheory.Limits.limit","CategoryTheory.Functor.comp","CategoryTheory.Functor.Initial.comp_hasLimit","CategoryTheory.Limits.limit.pre","CategoryTheory.Functor.Initial.comp_hasLimit"],"name":"CategoryTheory.Functor.Initial.limit_pre_isIso","className":"CategoryTheory.IsIso"}],"imports":["Init","Mathlib.CategoryTheory.PUnit","Mathlib.CategoryTheory.StructuredArrow","Mathlib.CategoryTheory.IsConnected","Mathlib.CategoryTheory.Limits.Yoneda","Mathlib.CategoryTheory.Limits.Types"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L708-L710","name":"CategoryTheory.IsCofiltered.of_initial","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.IsCofiltered.of_initial","doc":"Initial functors preserve cofilteredness.\n\nThis can be seen as a generalization of `IsCofiltered.of_left_adjoint` (which states that left\nadjoints preserve cofilteredness), as right adjoints are always initial, see `intial_of_adjunction`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L698-L701","name":"CategoryTheory.IsCofilteredOrEmpty.of_initial","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.IsCofilteredOrEmpty.of_initial","doc":"Initial functors preserve cofilteredness.\n\nThis can be seen as a generalization of `IsCofiltered.of_left_adjoint` (which states that left\nadjoints preserve cofilteredness), as right adjoints are always initial, see `intial_of_adjunction`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L689-L691","name":"CategoryTheory.IsFiltered.of_final","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.IsFiltered.of_final","doc":"Final functors preserve filteredness.\n\nThis can be seen as a generalization of `IsFiltered.of_right_adjoint` (which states that right\nadjoints preserve filteredness), as right adjoints are always final, see `final_of_adjunction`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L662-L682","name":"CategoryTheory.IsFilteredOrEmpty.of_final","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.IsFilteredOrEmpty.of_final","doc":"Final functors preserve filteredness.\n\nThis can be seen as a generalization of `IsFiltered.of_right_adjoint` (which states that right\nadjoints preserve filteredness), as right adjoints are always final, see `final_of_adjunction`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L637-L641","name":"CategoryTheory.Functor.Initial.limitIso'","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limitIso'","doc":"When `F` is initial, and `F ⋙ G` has a limit, then `G` has a limit also and\n`limit (F ⋙ G) ≅ limit G`\n\nhttps://stacks.math.columbia.edu/tag/04E7\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L623-L624","name":"CategoryTheory.Functor.Initial.hasLimit_of_comp","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.hasLimit_of_comp","doc":"When `F` is initial, and `F ⋙ G` has a limit, then `G` has a limit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_hasLimit`.)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L612-L615","name":"CategoryTheory.Functor.Initial.limitConeOfComp","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limitConeOfComp","doc":"Given a limit cone over `F ⋙ G` we can construct a limit cone over `G`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L611-L611","name":"CategoryTheory.Functor.Initial.limitConeOfComp_isLimit","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limitConeOfComp_isLimit","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L611-L611","name":"CategoryTheory.Functor.Initial.limitConeOfComp_cone","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limitConeOfComp_cone","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L604-L605","name":"CategoryTheory.Functor.Initial.limitIso","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limitIso","doc":"When `F : C ⥤ D` is initial, and `G : D ⥤ E` has a limit, then `F ⋙ G` has a limit also and\n`limit (F ⋙ G) ≅ limit G`\n\nhttps://stacks.math.columbia.edu/tag/04E7\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L588-L592","name":"CategoryTheory.Functor.Initial.limit_pre_isIso","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limit_pre_isIso","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L580-L585","name":"CategoryTheory.Functor.Initial.limit_pre_is_iso_aux","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limit_pre_is_iso_aux","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L576-L577","name":"CategoryTheory.Functor.Initial.comp_hasLimit","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.comp_hasLimit","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L570-L573","name":"CategoryTheory.Functor.Initial.limitConeComp","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limitConeComp","doc":"Given a limit cone over `G : D ⥤ E` we can construct a limit cone over `F ⋙ G`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L569-L569","name":"CategoryTheory.Functor.Initial.limitConeComp_cone","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limitConeComp_cone","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L569-L569","name":"CategoryTheory.Functor.Initial.limitConeComp_isLimit","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limitConeComp_isLimit","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L564-L565","name":"CategoryTheory.Functor.Initial.isLimitExtendConeEquiv","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.isLimitExtendConeEquiv","doc":"When `F` is initial, and `t : Cone (F ⋙ G)`,\n`extendCone.obj t` is a limit cone exactly when `t` is.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L557-L558","name":"CategoryTheory.Functor.Initial.isLimitWhiskerEquiv","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.isLimitWhiskerEquiv","doc":"When `F : C ⥤ D` is initial, and `t : Cone G` for some `G : D ⥤ E`,\n`t.whisker F` is a limit cone exactly when `t` is.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L544-L549","name":"CategoryTheory.Functor.Initial.conesEquiv","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.conesEquiv","doc":"If `F` is initial,\nthe category of cones on `F ⋙ G` is equivalent to the category of cones on `G`,\nfor any `G : D ⥤ E`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L543-L543","name":"CategoryTheory.Functor.Initial.conesEquiv_counitIso","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.conesEquiv_counitIso","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L543-L543","name":"CategoryTheory.Functor.Initial.conesEquiv_functor","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.conesEquiv_functor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L543-L543","name":"CategoryTheory.Functor.Initial.conesEquiv_unitIso","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.conesEquiv_unitIso","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L543-L543","name":"CategoryTheory.Functor.Initial.conesEquiv_inverse","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.conesEquiv_inverse","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L521-L534","name":"CategoryTheory.Functor.Initial.limit_cone_comp_aux","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.limit_cone_comp_aux","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L495-L517","name":"CategoryTheory.Functor.Initial.extendCone","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.extendCone","doc":"Given a cone over `F ⋙ G`, we can construct a `Cone G` with the same cocone point.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L494-L494","name":"CategoryTheory.Functor.Initial.extendCone_map_Hom","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.extendCone_map_Hom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L494-L494","name":"CategoryTheory.Functor.Initial.extendCone_obj_π_app","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.extendCone_obj_π_app","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L494-L494","name":"CategoryTheory.Functor.Initial.extendCone_obj_pt","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.extendCone_obj_pt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L466-L487","name":"CategoryTheory.Functor.Initial.induction","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.induction","doc":"We provide an induction principle for reasoning about `lift` and `homToLift`.\nWe want to perform some construction (usually just a proof) about\nthe particular choices `lift F d` and `homToLift F d`,\nit suffices to perform that construction for some other pair of choices\n(denoted `X₀ : C` and `k₀ : F.obj X₀ ⟶ d` below),\nand to show how to transport such a construction\n*both* directions along a morphism between such choices.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L454-L455","name":"CategoryTheory.Functor.Initial.homToLift","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.homToLift","doc":"When `F : C ⥤ D` is initial, we denote by `homToLift` an arbitrary choice of morphism\n`F.obj (lift F d) ⟶ d`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L447-L448","name":"CategoryTheory.Functor.Initial.lift","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.lift","doc":"When `F : C ⥤ D` is initial, we denote by `lift F d` an arbitrary choice of object in `C` such that\nthere exists a morphism `F.obj (lift F d) ⟶ d`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L438-L439","name":"CategoryTheory.Functor.Initial.instNonemptyCostructuredArrow","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.instNonemptyCostructuredArrow","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L412-L429","name":"CategoryTheory.Functor.Final.cofinal_of_colimit_comp_coyoneda_iso_pUnit","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.cofinal_of_colimit_comp_coyoneda_iso_pUnit","doc":"If `colimit (F ⋙ coyoneda.obj (op d)) ≅ PUnit` for all `d : D`, then `F` is cofinal.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L391-L407","name":"CategoryTheory.Functor.Final.zigzag_of_eqvGen_quot_rel","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.zigzag_of_eqvGen_quot_rel","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L386-L388","name":"CategoryTheory.Functor.Final.colimitCompCoyonedaIso","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimitCompCoyonedaIso","doc":"If the universal morphism `colimit (F ⋙ coyoneda.obj (op d)) ⟶ colimit (coyoneda.obj (op d))`\nis an isomorphism (as it always is when `F` is cofinal),\nthen `colimit (F ⋙ coyoneda.obj (op d)) ≅ PUnit`\n(simply because `colimit (coyoneda.obj (op d)) ≅ PUnit`).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L364-L368","name":"CategoryTheory.Functor.Final.colimitIso'","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimitIso'","doc":"When `F` is cofinal, and `F ⋙ G` has a colimit, then `G` has a colimit also and\n`colimit (F ⋙ G) ≅ colimit G`\n\nhttps://stacks.math.columbia.edu/tag/04E7\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L350-L351","name":"CategoryTheory.Functor.Final.hasColimit_of_comp","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.hasColimit_of_comp","doc":"When `F` is cofinal, and `F ⋙ G` has a colimit, then `G` has a colimit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_hasColimit`.)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L339-L342","name":"CategoryTheory.Functor.Final.colimitCoconeOfComp","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimitCoconeOfComp","doc":"Given a colimit cocone over `F ⋙ G` we can construct a colimit cocone over `G`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L338-L338","name":"CategoryTheory.Functor.Final.colimitCoconeOfComp_cocone","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimitCoconeOfComp_cocone","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L338-L338","name":"CategoryTheory.Functor.Final.colimitCoconeOfComp_isColimit","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimitCoconeOfComp_isColimit","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L331-L332","name":"CategoryTheory.Functor.Final.colimitIso","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimitIso","doc":"When `F : C ⥤ D` is cofinal, and `G : D ⥤ E` has a colimit, then `F ⋙ G` has a colimit also and\n`colimit (F ⋙ G) ≅ colimit G`\n\nhttps://stacks.math.columbia.edu/tag/04E7\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L315-L319","name":"CategoryTheory.Functor.Final.colimit_pre_isIso","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimit_pre_isIso","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L307-L312","name":"CategoryTheory.Functor.Final.colimit_pre_is_iso_aux","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimit_pre_is_iso_aux","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L303-L304","name":"CategoryTheory.Functor.Final.comp_hasColimit","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.comp_hasColimit","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L297-L300","name":"CategoryTheory.Functor.Final.colimitCoconeComp","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimitCoconeComp","doc":"Given a colimit cocone over `G : D ⥤ E` we can construct a colimit cocone over `F ⋙ G`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L296-L296","name":"CategoryTheory.Functor.Final.colimitCoconeComp_isColimit","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimitCoconeComp_isColimit","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L296-L296","name":"CategoryTheory.Functor.Final.colimitCoconeComp_cocone","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimitCoconeComp_cocone","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L290-L292","name":"CategoryTheory.Functor.Final.isColimitExtendCoconeEquiv","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.isColimitExtendCoconeEquiv","doc":"When `F` is cofinal, and `t : Cocone (F ⋙ G)`,\n`extendCocone.obj t` is a colimit cocone exactly when `t` is.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L283-L284","name":"CategoryTheory.Functor.Final.isColimitWhiskerEquiv","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.isColimitWhiskerEquiv","doc":"When `F : C ⥤ D` is cofinal, and `t : Cocone G` for some `G : D ⥤ E`,\n`t.whisker F` is a colimit cocone exactly when `t` is.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L270-L275","name":"CategoryTheory.Functor.Final.coconesEquiv","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.coconesEquiv","doc":"If `F` is cofinal,\nthe category of cocones on `F ⋙ G` is equivalent to the category of cocones on `G`,\nfor any `G : D ⥤ E`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L269-L269","name":"CategoryTheory.Functor.Final.coconesEquiv_inverse","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.coconesEquiv_inverse","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L269-L269","name":"CategoryTheory.Functor.Final.coconesEquiv_unitIso","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.coconesEquiv_unitIso","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L269-L269","name":"CategoryTheory.Functor.Final.coconesEquiv_counitIso","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.coconesEquiv_counitIso","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L269-L269","name":"CategoryTheory.Functor.Final.coconesEquiv_functor","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.coconesEquiv_functor","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L247-L260","name":"CategoryTheory.Functor.Final.colimit_cocone_comp_aux","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.colimit_cocone_comp_aux","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L224-L243","name":"CategoryTheory.Functor.Final.extendCocone","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.extendCocone","doc":"Given a cocone over `F ⋙ G`, we can construct a `Cocone G` with the same cocone point.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L223-L223","name":"CategoryTheory.Functor.Final.extendCocone_obj_ι_app","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.extendCocone_obj_ι_app","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L223-L223","name":"CategoryTheory.Functor.Final.extendCocone_obj_pt","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.extendCocone_obj_pt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L223-L223","name":"CategoryTheory.Functor.Final.extendCocone_map_Hom","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.extendCocone_map_Hom","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L195-L216","name":"CategoryTheory.Functor.Final.induction","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.induction","doc":"We provide an induction principle for reasoning about `lift` and `homToLift`.\nWe want to perform some construction (usually just a proof) about\nthe particular choices `lift F d` and `homToLift F d`,\nit suffices to perform that construction for some other pair of choices\n(denoted `X₀ : C` and `k₀ : d ⟶ F.obj X₀` below),\nand to show how to transport such a construction\n*both* directions along a morphism between such choices.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L183-L184","name":"CategoryTheory.Functor.Final.homToLift","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.homToLift","doc":"When `F : C ⥤ D` is cofinal, we denote by `homToLift` an arbitrary choice of morphism\n`d ⟶ F.obj (lift F d)`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L176-L177","name":"CategoryTheory.Functor.Final.lift","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.lift","doc":"When `F : C ⥤ D` is cofinal, we denote by `lift F d` an arbitrary choice of object in `C` such that\nthere exists a morphism `d ⟶ F.obj (lift F d)`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L167-L168","name":"CategoryTheory.Functor.Final.instNonemptyStructuredArrow","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.instNonemptyStructuredArrow","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L159-L160","name":"CategoryTheory.Functor.initial_of_isLeftAdjoint","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.initial_of_isLeftAdjoint","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L155-L156","name":"CategoryTheory.Functor.final_of_isRightAdjoint","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.final_of_isRightAdjoint","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L141-L152","name":"CategoryTheory.Functor.initial_of_adjunction","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.initial_of_adjunction","doc":"If a functor `L : C ⥤ D` is a left adjoint, it is initial. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L126-L137","name":"CategoryTheory.Functor.final_of_adjunction","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.final_of_adjunction","doc":"If a functor `R : D ⥤ C` is a right adjoint, it is final. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L118-L122","name":"CategoryTheory.Functor.initial_of_final_op","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.initial_of_final_op","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L111-L115","name":"CategoryTheory.Functor.final_of_initial_op","kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.final_of_initial_op","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L107-L108","name":"CategoryTheory.Functor.initial_op_of_final","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.initial_op_of_final","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L103-L104","name":"CategoryTheory.Functor.final_op_of_initial","kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.final_op_of_initial","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L98-L98","name":"CategoryTheory.Functor.Initial.out","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.out","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L97-L97","name":"CategoryTheory.Functor.Initial.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L97-L98","name":"CategoryTheory.Functor.Initial","kind":"class","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Initial","doc":"A functor `F : C ⥤ D` is initial if for every `d : D`, the comma category of morphisms\n`F.obj c ⟶ d` is connected.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L89-L89","name":"CategoryTheory.Functor.Final.out","kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.out","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L88-L88","name":"CategoryTheory.Functor.Final.mk","kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Limits/Final.lean#L88-L89","name":"CategoryTheory.Functor.Final","kind":"class","docLink":"./Mathlib/CategoryTheory/Limits/Final.html#CategoryTheory.Functor.Final","doc":"A functor `F : C ⥤ D` is final if for every `d : D`, the comma category of morphisms `d ⟶ F.obj c`\nis connected.\n\nSee <https://stacks.math.columbia.edu/tag/04E6>\n"}]}