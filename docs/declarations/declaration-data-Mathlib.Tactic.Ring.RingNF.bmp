{"name":"Mathlib.Tactic.Ring.RingNF","instances":[{"typeNames":["Mathlib.Tactic.RingNF.RingMode"],"name":"Mathlib.Tactic.RingNF.instInhabitedRingMode","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.RingNF.RingMode"],"name":"Mathlib.Tactic.RingNF.instBEqRingMode","className":"BEq"},{"typeNames":["Mathlib.Tactic.RingNF.RingMode"],"name":"Mathlib.Tactic.RingNF.instReprRingMode","className":"Repr"},{"typeNames":["Mathlib.Tactic.RingNF.Config"],"name":"Mathlib.Tactic.RingNF.instInhabitedConfig","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.RingNF.Config"],"name":"Mathlib.Tactic.RingNF.instBEqConfig","className":"BEq"},{"typeNames":["Mathlib.Tactic.RingNF.Config"],"name":"Mathlib.Tactic.RingNF.instReprConfig","className":"Repr"}],"imports":["Init","Mathlib.Tactic.Ring.Basic","Mathlib.Tactic.Conv","Mathlib.Util.Qq"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L265-L266","name":"Mathlib.Tactic.RingNF.convRing!","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.convRing!","doc":"The tactic `ring` evaluates expressions in *commutative* (semi)rings.\nThis is the conv tactic version, which rewrites a target which is a ring equality to `True`.\n\nSee also the `ring` tactic.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L263-L264","name":"Mathlib.Tactic.RingNF.ringConv","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringConv","doc":"The tactic `ring` evaluates expressions in *commutative* (semi)rings.\nThis is the conv tactic version, which rewrites a target which is a ring equality to `True`.\n\nSee also the `ring` tactic.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L254-L255","name":"Mathlib.Tactic.RingNF.tacticRing!","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing!","doc":"Tactic for evaluating expressions in *commutative* (semi)rings, allowing for variables in the\nexponent.\n\n* `ring!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `ring1` fails if the target is not an equality.\n\nFor example:\n```\nexample (n : ℕ) (m : ℤ) : 2^(n+1) * m = 2 * 2^n * m := by ring\nexample (a b : ℤ) (n : ℕ) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring\nexample (x y : ℕ) : x + id y = y + id x := by ring!\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L252-L253","name":"Mathlib.Tactic.RingNF.ring","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring","doc":"Tactic for evaluating expressions in *commutative* (semi)rings, allowing for variables in the\nexponent.\n\n* `ring!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `ring1` fails if the target is not an equality.\n\nFor example:\n```\nexample (n : ℕ) (m : ℤ) : 2^(n+1) * m = 2 * 2^n * m := by ring\nexample (a b : ℤ) (n : ℕ) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring\nexample (x y : ℕ) : x + id y = y + id x := by ring!\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L236-L236","name":"Mathlib.Tactic.RingNF.convRing_nf!_","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.convRing_nf!_","doc":"Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L228-L234","name":"Mathlib.Tactic.RingNF.elabRingNFConv","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.elabRingNFConv","doc":"Elaborator for the `ring_nf` tactic. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L225-L225","name":"Mathlib.Tactic.RingNF.tacticRing1_nf!_","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing1_nf!_","doc":"Tactic for solving equations of *commutative* (semi)rings, allowing variables in the exponent.\n\n* This version of `ring1` uses `ring_nf` to simplify in atoms.\n* The variant `ring1_nf!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L212-L223","name":"Mathlib.Tactic.RingNF.ring1NF","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring1NF","doc":"Tactic for solving equations of *commutative* (semi)rings, allowing variables in the exponent.\n\n* This version of `ring1` uses `ring_nf` to simplify in atoms.\n* The variant `ring1_nf!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L210-L210","name":"Mathlib.Tactic.RingNF.ringNFConv","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFConv","doc":"Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L207-L208","name":"Mathlib.Tactic.RingNF.tacticRing_nf!__","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing_nf!__","doc":"Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L189-L205","name":"Mathlib.Tactic.RingNF.ringNF","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNF","doc":"Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L180-L187","name":"Mathlib.Tactic.RingNF.ringNFLocalDecl","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFLocalDecl","doc":"Use `ring_nf` to rewrite hypothesis `h`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L169-L177","name":"Mathlib.Tactic.RingNF.ringNFTarget","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFTarget","doc":"Use `ring_nf` to rewrite the main goal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L157-L159","name":"Mathlib.Tactic.RingNF.M.run.evalAtom","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M.run.evalAtom","doc":"The atom evaluator calls either `RingNF.rewrite` recursively,\nor nothing depending on `cfg.recursive`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L154-L154","name":"Mathlib.Tactic.RingNF.M.run.rctx","kind":"opaque","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M.run.rctx","doc":"The recursive context. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L135-L160","name":"Mathlib.Tactic.RingNF.M.run","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M.run","doc":"Runs a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L125-L125","name":"Mathlib.Tactic.RingNF.rat_rawCast_2","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.rat_rawCast_2","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L122-L124","name":"Mathlib.Tactic.RingNF.int_rawCast_2","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.int_rawCast_2","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L120-L121","name":"Mathlib.Tactic.RingNF.int_rawCast_1","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.int_rawCast_1","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L119-L119","name":"Mathlib.Tactic.RingNF.nat_rawCast_2","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_2","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L118-L118","name":"Mathlib.Tactic.RingNF.nat_rawCast_1","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_1","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L117-L117","name":"Mathlib.Tactic.RingNF.nat_rawCast_0","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_0","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L116-L116","name":"Mathlib.Tactic.RingNF.add_neg","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.add_neg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L115-L115","name":"Mathlib.Tactic.RingNF.mul_neg","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.mul_neg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L114-L114","name":"Mathlib.Tactic.RingNF.mul_assoc_rev","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.mul_assoc_rev","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L113-L113","name":"Mathlib.Tactic.RingNF.add_assoc_rev","kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.add_assoc_rev","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L90-L109","name":"Mathlib.Tactic.RingNF.rewrite","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.rewrite","doc":"A tactic in the `RingNF.M` monad which will simplify expression `parent` to a normal form.\n* `root`: true if this is a direct call to the function.\n  `RingNF.M.run` sets this to `false` in recursive mode.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L83-L83","name":"Mathlib.Tactic.RingNF.M","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M","doc":"The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L78-L78","name":"Mathlib.Tactic.RingNF.Context.simp","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context.simp","doc":"A cleanup routine, which simplifies normalized polynomials to a more human-friendly\nformat. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L75-L75","name":"Mathlib.Tactic.RingNF.Context.ctx","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context.ctx","doc":"A basically empty simp context, passed to the `simp` traversal in `RingNF.rewrite`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L73-L78","name":"Mathlib.Tactic.RingNF.Context","kind":"structure","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context","doc":"The read-only state of the `RingNF` monad. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L69-L70","name":"Mathlib.Tactic.RingNF.elabConfig","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.elabConfig","doc":"Function elaborating `RingNF.Config`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L67-L67","name":"Mathlib.Tactic.RingNF.instReprConfig","kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprConfig","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L67-L67","name":"Mathlib.Tactic.RingNF.instBEqConfig","kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqConfig","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L67-L67","name":"Mathlib.Tactic.RingNF.instInhabitedConfig","kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedConfig","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L66-L66","name":"Mathlib.Tactic.RingNF.Config.mode","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.mode","doc":"The normalization style. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L64-L64","name":"Mathlib.Tactic.RingNF.Config.recursive","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.recursive","doc":"if true, atoms inside ring expressions will be reduced recursively "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L62-L62","name":"Mathlib.Tactic.RingNF.Config.red","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.red","doc":"the reducibility setting to use when comparing atoms for defeq "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L60-L67","name":"Mathlib.Tactic.RingNF.Config","kind":"structure","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config","doc":"Configuration for `ring_nf`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L57-L57","name":"Mathlib.Tactic.RingNF.instReprRingMode","kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprRingMode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L57-L57","name":"Mathlib.Tactic.RingNF.instBEqRingMode","kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqRingMode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L57-L57","name":"Mathlib.Tactic.RingNF.instInhabitedRingMode","kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedRingMode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L55-L56","name":"Mathlib.Tactic.RingNF.RingMode.raw","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode.raw","doc":"Raw form: the representation `ring` uses internally. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L53-L54","name":"Mathlib.Tactic.RingNF.RingMode.SOP","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode.SOP","doc":"Sum-of-products form, like `x + x * y * 2 + z ^ 2`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L52-L57","name":"Mathlib.Tactic.RingNF.RingMode","kind":"inductive","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode","doc":"The normalization style for `ring_nf`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L40-L44","name":"Mathlib.Tactic.Ring.ExSum.isAtom","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExSum.isAtom","doc":"True if this represents an atomic expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L35-L37","name":"Mathlib.Tactic.Ring.ExProd.isAtom","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExProd.isAtom","doc":"True if this represents an atomic expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L30-L32","name":"Mathlib.Tactic.Ring.ExBase.isAtom","kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExBase.isAtom","doc":"True if this represents an atomic expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L1-L1","name":"Mathlib.Tactic.RingNF.Context.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Ring/RingNF.lean#L1-L1","name":"Mathlib.Tactic.RingNF.Config.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.mk","doc":""}]}