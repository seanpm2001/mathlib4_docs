{"name":"Std.Data.Ord","instances":[{"typeNames":["Eq","Ordering"],"name":"Ordering.instDecidableEqOrdering","className":"Decidable"}],"imports":["Init"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L133-L134","name":"Ord.lex'","kind":"def","docLink":"./Std/Data/Ord.html#Ord.lex'","doc":"Create an order which compares elements first by `ord₁` and then, if this\nreturns 'equal', by `ord₂`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L126-L127","name":"Ord.lex","kind":"def","docLink":"./Std/Data/Ord.html#Ord.lex","doc":"Derive the lexicographic order on products `α × β` from orders for `α` and `β`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L120-L121","name":"Ord.on","kind":"def","docLink":"./Std/Data/Ord.html#Ord.on","doc":"`ord.on f` compares `x` and `y` by comparing `f x` and `f y` according to `ord`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L114-L115","name":"Ord.opposite","kind":"def","docLink":"./Std/Data/Ord.html#Ord.opposite","doc":"Invert the order of an `Ord` instance.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L108-L109","name":"Ord.toLE","kind":"def","docLink":"./Std/Data/Ord.html#Ord.toLE","doc":"Derive an `LE` instance from an `Ord` instance.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L102-L103","name":"Ord.toLT","kind":"def","docLink":"./Std/Data/Ord.html#Ord.toLT","doc":"Derive an `LT` instance from an `Ord` instance.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L96-L97","name":"Ord.toBEq","kind":"def","docLink":"./Std/Data/Ord.html#Ord.toBEq","doc":"Derive a `BEq` instance from an `Ord` instance.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L87-L88","name":"compareOn","kind":"def","docLink":"./Std/Data/Ord.html#compareOn","doc":"Compare `x` and `y` by comparing `f x` and `f y`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L81-L82","name":"compareLex","kind":"def","docLink":"./Std/Data/Ord.html#compareLex","doc":"Compare `a` and `b` lexicographically by `cmp₁` and `cmp₂`. `a` and `b` are\nfirst compared by `cmp₁`. If this returns 'equal', `a` and `b` are compared\nby `cmp₂` to break the tie.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L70-L72","name":"Ordering.isGE","kind":"def","docLink":"./Std/Data/Ord.html#Ordering.isGE","doc":"Check whether the ordering is 'greater than or equal'.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L63-L65","name":"Ordering.isGT","kind":"def","docLink":"./Std/Data/Ord.html#Ordering.isGT","doc":"Check whether the ordering is 'greater than'.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L56-L58","name":"Ordering.isLT","kind":"def","docLink":"./Std/Data/Ord.html#Ordering.isLT","doc":"Check whether the ordering is 'less than'.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L49-L51","name":"Ordering.isNe","kind":"def","docLink":"./Std/Data/Ord.html#Ordering.isNe","doc":"Check whether the ordering is 'not equal'.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L42-L44","name":"Ordering.isEq","kind":"def","docLink":"./Std/Data/Ord.html#Ordering.isEq","doc":"Check whether the ordering is 'equal'.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L35-L37","name":"Ordering.then","kind":"def","docLink":"./Std/Data/Ord.html#Ordering.then","doc":"If `o₁` and `o₂` are `Ordering`, then `o₁.then o₂` returns `o₁` unless it is `.eq`,\nin which case it returns `o₂`. Additionally, it has \"short-circuiting\" semantics similar to\nboolean `x && y`: if `o₁` is not `.eq` then the expression for `o₂` is not evaluated.\nThis is a useful primitive for constructing lexicographic comparator functions:\n```\nstructure Person where\n  name : String\n  age : Nat\n\ninstance : Ord Person where\n  compare a b := (compare a.name b.name).then (compare b.age a.age)\n```\nThis example will sort people first by name (in ascending order) and will sort people with\nthe same name by age (in descending order). (If all fields are sorted ascending and in the same\norder as they are listed in the structure, you can also use `deriving Ord` on the structure\ndefinition for the same effect.)\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L12-L15","name":"Ordering.swap","kind":"def","docLink":"./Std/Data/Ord.html#Ordering.swap","doc":"Swaps less and greater ordering results "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/Ord.lean#L9-L9","name":"Ordering.instDecidableEqOrdering","kind":"instance","docLink":"./Std/Data/Ord.html#Ordering.instDecidableEqOrdering","doc":""}]}