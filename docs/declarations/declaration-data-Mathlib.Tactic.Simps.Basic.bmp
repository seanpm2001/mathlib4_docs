{"name":"Mathlib.Tactic.Simps.Basic","instances":[{"typeNames":["Simps.ProjectionData"],"name":"Simps.instInhabitedProjectionData","className":"Inhabited"},{"typeNames":["Simps.ProjectionData"],"name":"Simps.instToMessageDataProjectionData","className":"Lean.ToMessageData"},{"typeNames":["Simps.ParsedProjectionData"],"name":"Simps.instToMessageDataParsedProjectionData","className":"Lean.ToMessageData"},{"typeNames":["Simps.ProjectionRule"],"name":"Simps.instToMessageDataProjectionRule","className":"Lean.ToMessageData"},{"typeNames":["Simps.Config"],"name":"Simps.instInhabitedConfig","className":"Inhabited"}],"imports":["Init","Mathlib.Init.Data.Nat.Notation","Mathlib.Lean.Message","Mathlib.Lean.Expr.Basic","Mathlib.Data.String.Defs","Mathlib.Data.KVMap","Mathlib.Tactic.Simps.NotationClass","Std.Classes.Dvd","Std.Util.LibraryNote","Mathlib.Tactic.RunCmd","Mathlib.Lean.Linter"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L1157-L1162","name":"simpsAttr","kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#simpsAttr","doc":"The `simps` attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L1148-L1155","name":"simpsTacFromSyntax","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#simpsTacFromSyntax","doc":"elaborate the syntax and run `simpsTac`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L1136-L1145","name":"simpsTac","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#simpsTac","doc":"`simpsTac` derives `simp` lemmas for all (nested) non-Prop projections of the declaration.\nIf `todo` is non-empty, it will generate exactly the names in `todo`.\nIf `shortNm` is true, the generated names will only use the last projection name.\nIf `trc` is true, trace as if `trace.simps.verbose` is true. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L995-L1127","name":"Simps.addProjections","kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.addProjections","doc":"Derive lemmas specifying the projections of the declaration.\n`nm`: name of the lemma\nIf `todo` is non-empty, it will generate exactly the names in `todo`.\n`toApply` is non-empty after a custom projection that is a composition of multiple projections\nwas just used. In that case we need to apply these projections before we continue changing `lhs`.\n`simpLemmas`: names of the simp lemmas added so far.(simpLemmas : Array Name)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L962-L986","name":"Simps.headStructureEtaReduce","kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.headStructureEtaReduce","doc":"Perform head-structure-eta-reduction on expression `e`. That is, if `e` is of the form\n`⟨f.1, f.2, ..., f.n⟩` with `f` definitionally equal to `e`, then\n`headStructureEtaReduce e = headStructureEtaReduce f` and `headStructureEtaReduce e = e` otherwise.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L910-L955","name":"Simps.addProjection","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.addProjection","doc":"Add a lemma with `nm` stating that `lhs = rhs`. `type` is the type of both `lhs` and `rhs`,\n`args` is the list of local constants occurring, and `univs` is the list of universe variables. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L889-L904","name":"Simps.getProjectionExprs","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.getProjectionExprs","doc":"Get the projections of a structure used by `@[simps]` applied to the appropriate arguments.\nReturns a list of tuples\n```\n(corresponding right-hand-side, given projection name, projection Expression,\n  future projection numbers, used by default, is prefix)\n```\n(where all fields except the first are packed in a `ProjectionData` structure)\none for each projection. The given projection name is the name for the projection used by the user\nused to generate (and parse) projection names. For example, in the structure\n\nExample 1: ``getProjectionExprs env `(α × β) `(⟨x, y⟩)`` will give the output\n```\n  [(`(x), `fst, `(@Prod.fst.{u v} α β), [], true, false),\n   (`(y), `snd, `(@Prod.snd.{u v} α β), [], true, false)]\n```\n\nExample 2: ``getProjectionExprs env `(α ≃ α) `(⟨id, id, fun _ ↦ rfl, fun _ ↦ rfl⟩)``\nwill give the output\n```\n  [(`(id), `apply, (Equiv.toFun), [], true, false),\n   (`(id), `symm_apply, (fun e ↦ e.symm.toFun), [], true, false),\n   ...,\n   ...]\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L861-L862","name":"Lean.Expr.instantiateLambdasOrApps","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Expr.instantiateLambdasOrApps","doc":"`instantiateLambdasOrApps es e` instantiates lambdas in `e` by expressions from `es`.\nIf the length of `es` is larger than the number of lambdas in `e`,\nthen the term is applied to the remaining terms.\nAlso reduces head let-expressions in `e`, including those after instantiating all lambdas.\n\nThis is very similar to `expr.substs`, but this also reduces head let-expressions. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L852-L853","name":"Simps.Config.lemmasOnly","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.lemmasOnly","doc":"A common configuration for `@[simps]`: don't tag the generated lemmas with `@[simp]`.\nUse this using `@[simps (config := .lemmasOnly)]`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L847-L848","name":"Simps.Config.asFn","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.asFn","doc":"A common configuration for `@[simps]`: generate equalities between functions instead equalities\nbetween fully applied Expressions. Use this using `@[simps (config := .asFn)]`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L842-L843","name":"Simps.elabSimpsConfig","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.elabSimpsConfig","doc":"Function elaborating `Config` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L840-L840","name":"Simps.instInhabitedConfig","kind":"instance","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.instInhabitedConfig","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L839-L839","name":"Simps.Config.debug","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.debug","doc":"Output debug messages. Not used much, use `set_option simps.debug true` instead. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L837-L837","name":"Simps.Config.notRecursive","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.notRecursive","doc":"List of types in which we are not recursing to generate simplification lemmas.\nE.g. if we write `@[simps] def e : α × β ≃ β × α := ...` we will generate `e_apply` and not\n`e_apply_fst`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L833-L833","name":"Simps.Config.fullyApplied","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.fullyApplied","doc":"Generated lemmas that are fully applied, i.e. generates equalities between applied functions.\nSet this to `false` to generate equalities between functions. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L830-L830","name":"Simps.Config.rhsMd","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.rhsMd","doc":"TransparencyMode used to reduce the right-hand side in order to detect whether it is a\nconstructor. Note: was `none` in Lean 3 "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L827-L827","name":"Simps.Config.typeMd","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.typeMd","doc":"TransparencyMode used to reduce the type in order to detect whether it is a structure. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L825-L825","name":"Simps.Config.simpRhs","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.simpRhs","doc":"simplify the right-hand side of generated simp-lemmas using `dsimp, simp`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L823-L823","name":"Simps.Config.attrs","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.attrs","doc":"Other simp-attributes to apply to generated lemmas.\nAttributes that are currently not simp-attributes are not supported. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L820-L820","name":"Simps.Config.isSimp","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.isSimp","doc":"Make generated lemmas simp lemmas "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L818-L840","name":"Simps.Config","kind":"structure","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config","doc":"Configuration options for `@[simps]` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L808-L815","name":"Simps.elabInitializeSimpsProjections","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.elabInitializeSimpsProjections","doc":"Function elaborating `initialize_simps_projections`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L800-L805","name":"Simps.elabSimpsRule","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.elabSimpsRule","doc":"Parse a rule for `initialize_simps_projections`. It is `<name>→<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`."},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L746-L777","name":"Simps.getRawProjections","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.getRawProjections","doc":"Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L687-L705","name":"Simps.findAutomaticProjections","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.findAutomaticProjections","doc":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `FunLike` and `SetLike` instances. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L648-L682","name":"Simps.findAutomaticProjectionsAux","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.findAutomaticProjectionsAux","doc":"If a structure has a field that corresponds to a coercion to functions or sets, or corresponds\n  to notation, find the custom projection that uses this coercion or notation.\n  Returns the custom projection and the name of the projection used.\n\nWe catch most errors this function causes, so that we don't fail if an unrelated projection has\nan applicable name. (e.g. `Iso.inv`)\n\nImplementation note: getting rid of TermElabM is tricky, since `Expr.mkAppOptM` doesn't allow to\nkeep metavariables around, which are necessary for `OutParam`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L628-L637","name":"Simps.checkForUnusedCustomProjs","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.checkForUnusedCustomProjs","doc":"Checks if there are declarations in the current file in the namespace `{str}.Simps` that are\nnot used. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L591-L624","name":"Simps.findProjection","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.findProjection","doc":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L543-L586","name":"Simps.applyProjectionRules","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.applyProjectionRules","doc":"Execute the projection renamings (and turning off projections) as specified by `rules`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L528-L540","name":"Simps.mkParsedProjectionData","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.mkParsedProjectionData","doc":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields."},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L517-L522","name":"Simps.getCompositeOfProjections","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.getCompositeOfProjections","doc":"Suppose we are given a structure `str` and a projection `proj`, that could be multiple nested\nprojections (separated by `_`), where each projection could be a projection of a parent structure.\nThis function returns an expression that is the composition of these projections and a\nlist of natural numbers, that are the projection numbers of the applied projections.\nNote that this function is similar to elaborating dot notation, but it can do a little more.\nExample: if we do\n```\nstructure gradedFun (A : ℕ → Type _) where\n  toFun := ∀ i j, A i →+ A j →+ A (i + j)\ninitialize_simps_projections (toFun_toFun_toFun → myMul)\n```\nwe will be able to generate the \"projection\"\n  `λ {A} (f : gradedFun A) (x : A i) (y : A j) ↦ ↑(↑(f.toFun i j) x) y`,\nwhich projection notation cannot do. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L483-L501","name":"Simps.getCompositeOfProjectionsAux","kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.getCompositeOfProjectionsAux","doc":"Auxiliary function of `getCompositeOfProjections`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L471-L480","name":"Simps.findProjectionIndices","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.findProjectionIndices","doc":"Find the indices of the projections that need to be applied to elaborate `$e.$projName`.\nExample: If `e : α ≃+ β` and ``projName = `invFun`` then this returns `[0, 1]`, because the first\nprojection of `MulEquiv` is `toEquiv` and the second projection of `Equiv` is `invFun`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L453-L466","name":"Simps.projectionsInfo","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.projectionsInfo","doc":"Returns the projection information of a structure. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L441-L450","name":"Simps.instToMessageDataProjectionRule","kind":"instance","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.instToMessageDataProjectionRule","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L438-L439","name":"Simps.ProjectionRule.prefix","kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.prefix","doc":"A prefix rule `prefix fieldName` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L436-L437","name":"Simps.ProjectionRule.erase","kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.erase","doc":"A hiding rule `-fieldName` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L434-L435","name":"Simps.ProjectionRule.add","kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.add","doc":"An adding rule `+fieldName` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L429-L433","name":"Simps.ProjectionRule.rename","kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.rename","doc":"A renaming rule `before→after` or\nEach name comes with the syntax used to write the rule,\nwhich is used to declare hover information. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L428-L439","name":"Simps.ProjectionRule","kind":"inductive","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule","doc":"The type of rules that specify how metadata for projections in changes.\nSee `initialize_simps_projections`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L420-L424","name":"Simps.instToMessageDataParsedProjectionData","kind":"instance","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.instToMessageDataParsedProjectionData","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L417-L418","name":"Simps.ParsedProjectionData.toProjectionData","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.toProjectionData","doc":"Turn `ParsedProjectionData` into `ProjectionData`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L414-L414","name":"Simps.ParsedProjectionData.isCustom","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.isCustom","doc":"is this a projection that is changed by the user? "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L412-L412","name":"Simps.ParsedProjectionData.projNrs","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.projNrs","doc":"the list of projection numbers this expression corresponds to "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L410-L410","name":"Simps.ParsedProjectionData.expr?","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.expr?","doc":"projection expression "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L408-L408","name":"Simps.ParsedProjectionData.isPrefix","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.isPrefix","doc":"is the projection name a prefix? "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L406-L406","name":"Simps.ParsedProjectionData.isDefault","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.isDefault","doc":"will simp lemmas be generated for with (without specifically naming this?) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L404-L404","name":"Simps.ParsedProjectionData.newStx","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.newStx","doc":"syntax that provided `newName` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L402-L402","name":"Simps.ParsedProjectionData.newName","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.newName","doc":"name for this projection used in the generated `simp` lemmas "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L400-L400","name":"Simps.ParsedProjectionData.strStx","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.strStx","doc":"syntax that might have provided `strName` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L398-L398","name":"Simps.ParsedProjectionData.strName","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.strName","doc":"name for this projection used in the structure definition "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L396-L414","name":"Simps.ParsedProjectionData","kind":"structure","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData","doc":"Projection data used internally in `getRawProjections`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L383-L393","name":"Simps.structureExt","kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.structureExt","doc":"The `Simps.structureExt` environment extension specifies the preferred projections of the given\nstructure, used by the `@[simps]` attribute.\n- You can generate this with the command `initialize_simps_projections`.\n- If not generated, the `@[simps]` attribute will generate this automatically.\n- To change the default value, see Note [custom simps projection].\n- The first argument is the list of names of the universe variables used in the structure\n- The second argument is an array that consists of the projection data for each projection.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L378-L381","name":"Simps.instToMessageDataProjectionData","kind":"instance","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.instToMessageDataProjectionData","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L376-L376","name":"Simps.instInhabitedProjectionData","kind":"instance","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.instInhabitedProjectionData","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L375-L375","name":"Simps.ProjectionData.isPrefix","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.isPrefix","doc":"A boolean specifying whether this projection is written as prefix. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L373-L373","name":"Simps.ProjectionData.isDefault","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.isDefault","doc":"A boolean specifying whether `simp` lemmas are generated for this projection by default. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L371-L371","name":"Simps.ProjectionData.projNrs","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.projNrs","doc":"A list of natural numbers, which is the projection number(s) that have to be applied to the\nExpression. For example the list `[0, 1]` corresponds to applying the first projection of the\nstructure, and then the second projection of the resulting structure (this assumes that the\ntarget of the first projection is a structure with at least two projections).\nThe composition of these projections is required to be definitionally equal to the provided\nExpression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L364-L364","name":"Simps.ProjectionData.expr","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.expr","doc":"An Expression used by simps for the projection. It must be definitionally equal to an original\nprojection (or a composition of multiple projections).\nThese Expressions can contain the universe parameters specified in the first argument of\n`structureExt`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L359-L359","name":"Simps.ProjectionData.name","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.name","doc":"The name used in the generated `simp` lemmas "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L357-L376","name":"Simps.ProjectionData","kind":"structure","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData","doc":"Projection data for a single projection of a structure "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L345-L346","name":"Lean.Parser.Command.commandInitialize_simps_projections?_","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.commandInitialize_simps_projections?_","doc":"This command specifies custom names and custom projections for the simp attribute `simpsAttr`.\n* You can specify custom names by writing e.g.\n  `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n* See Note [custom simps projection] and the examples below for information how to declare custom\n  projections.\n* For algebraic structures, we will automatically use the notation (like `Mul`)\n  for the projections if such an instance is available.\n* By default, the projections to parent structures are not default projections,\n  but all the data-carrying fields are (including those in parent structures).\n* You can disable a projection by default by running\n  `initialize_simps_projections Equiv (-invFun)`\n  This will ensure that no simp lemmas are generated for this projection,\n  unless this projection is explicitly specified by the user.\n* Conversely, you can enable a projection by default by running\n  `initialize_simps_projections Equiv (+toEquiv)`.\n* If you want the projection name added as a prefix in the generated lemma name, you can use\n  `as_prefix fieldName`:\n  `initialize_simps_projections Equiv (toFun → coe, as_prefix coe)`\n  Note that this does not influence the parsing of projection names: if you have a declaration\n  `foo` and you want to apply the projections `snd`, `coe` (which is a prefix) and `fst`, in that\n  order you can run `@[simps snd_coe_fst] def foo ...` and this will generate a lemma with the\n  name `coe_foo_snd_fst`.\n  * Run `initialize_simps_projections?` (or `set_option trace.simps.verbose true`)\n  to see the generated projections.\n* Running `initialize_simps_projections MyStruc` without arguments is not necessary, it has the\n  same effect if you just add `@[simps]` to a declaration.\n* It is recommended to call `@[simps]` or `initialize_simps_projections` in the same file as the\n  structure declaration. Otherwise, the projections could be generated multiple times in different\n  files.\n\nSome common uses:\n* If you define a new homomorphism-like structure (like `MulHom`) you can just run\n  `initialize_simps_projections` after defining the `FunLike` instance (or instance that implies\n  a `FunLike` instance).\n  ```\n    instance {mM : Mul M} {mN : Mul N} : FunLike (MulHom M N) M N := ...\n    initialize_simps_projections MulHom (toFun → apply)\n  ```\n  This will generate `foo_apply` lemmas for each declaration `foo`.\n* If you prefer `coe_foo` lemmas that state equalities between functions, use\n  `initialize_simps_projections MulHom (toFun → coe, as_prefix coe)`\n  In this case you have to use `@[simps (config := {fullyApplied := false})]` or equivalently\n  `@[simps (config := .asFn)]` whenever you call `@[simps]`.\n* You can also initialize to use both, in which case you have to choose which one to use by default,\n  by using either of the following\n  ```\n    initialize_simps_projections MulHom (toFun → apply, toFun → coe, as_prefix coe, -coe)\n    initialize_simps_projections MulHom (toFun → apply, toFun → coe, as_prefix coe, -apply)\n  ```\n  In the first case, you can get both lemmas using `@[simps, simps (config := .asFn) coe]` and in\n  the second case you can get both lemmas using `@[simps (config := .asFn), simps apply]`.\n* If you declare a new homomorphism-like structure (like `RelEmbedding`),\n  then `initialize_simps_projections` will automatically find any `FunLike` coercions\n  that will be used as the default projection for the `toFun` field.\n  ```\n    initialize_simps_projections relEmbedding (toFun → apply)\n  ```\n* If you have an isomorphism-like structure (like `Equiv`) you often want to define a custom\n  projection for the inverse:\n  ```\n    def Equiv.Simps.symm_apply (e : α ≃ β) : β → α := e.symm\n    initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)\n  ```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L276-L342","name":"Lean.Parser.Command.initialize_simps_projections","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.initialize_simps_projections","doc":"This command specifies custom names and custom projections for the simp attribute `simpsAttr`.\n* You can specify custom names by writing e.g.\n  `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n* See Note [custom simps projection] and the examples below for information how to declare custom\n  projections.\n* For algebraic structures, we will automatically use the notation (like `Mul`)\n  for the projections if such an instance is available.\n* By default, the projections to parent structures are not default projections,\n  but all the data-carrying fields are (including those in parent structures).\n* You can disable a projection by default by running\n  `initialize_simps_projections Equiv (-invFun)`\n  This will ensure that no simp lemmas are generated for this projection,\n  unless this projection is explicitly specified by the user.\n* Conversely, you can enable a projection by default by running\n  `initialize_simps_projections Equiv (+toEquiv)`.\n* If you want the projection name added as a prefix in the generated lemma name, you can use\n  `as_prefix fieldName`:\n  `initialize_simps_projections Equiv (toFun → coe, as_prefix coe)`\n  Note that this does not influence the parsing of projection names: if you have a declaration\n  `foo` and you want to apply the projections `snd`, `coe` (which is a prefix) and `fst`, in that\n  order you can run `@[simps snd_coe_fst] def foo ...` and this will generate a lemma with the\n  name `coe_foo_snd_fst`.\n  * Run `initialize_simps_projections?` (or `set_option trace.simps.verbose true`)\n  to see the generated projections.\n* Running `initialize_simps_projections MyStruc` without arguments is not necessary, it has the\n  same effect if you just add `@[simps]` to a declaration.\n* It is recommended to call `@[simps]` or `initialize_simps_projections` in the same file as the\n  structure declaration. Otherwise, the projections could be generated multiple times in different\n  files.\n\nSome common uses:\n* If you define a new homomorphism-like structure (like `MulHom`) you can just run\n  `initialize_simps_projections` after defining the `FunLike` instance (or instance that implies\n  a `FunLike` instance).\n  ```\n    instance {mM : Mul M} {mN : Mul N} : FunLike (MulHom M N) M N := ...\n    initialize_simps_projections MulHom (toFun → apply)\n  ```\n  This will generate `foo_apply` lemmas for each declaration `foo`.\n* If you prefer `coe_foo` lemmas that state equalities between functions, use\n  `initialize_simps_projections MulHom (toFun → coe, as_prefix coe)`\n  In this case you have to use `@[simps (config := {fullyApplied := false})]` or equivalently\n  `@[simps (config := .asFn)]` whenever you call `@[simps]`.\n* You can also initialize to use both, in which case you have to choose which one to use by default,\n  by using either of the following\n  ```\n    initialize_simps_projections MulHom (toFun → apply, toFun → coe, as_prefix coe, -coe)\n    initialize_simps_projections MulHom (toFun → apply, toFun → coe, as_prefix coe, -apply)\n  ```\n  In the first case, you can get both lemmas using `@[simps, simps (config := .asFn) coe]` and in\n  the second case you can get both lemmas using `@[simps (config := .asFn), simps apply]`.\n* If you declare a new homomorphism-like structure (like `RelEmbedding`),\n  then `initialize_simps_projections` will automatically find any `FunLike` coercions\n  that will be used as the default projection for the `toFun` field.\n  ```\n    initialize_simps_projections relEmbedding (toFun → apply)\n  ```\n* If you have an isomorphism-like structure (like `Equiv`) you often want to define a custom\n  projection for the inverse:\n  ```\n    def Equiv.Simps.symm_apply (e : α ≃ β) : β → α := e.symm\n    initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)\n  ```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L273-L274","name":"Lean.Parser.Command.simpsProj","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsProj","doc":"Syntax for `initialize_simps_projections`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L271-L272","name":"Lean.Parser.Command.simpsRule","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule","doc":"Syntax for a single rule in `initialize_simps_projections`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L269-L270","name":"Lean.Parser.Command.simpsRule.prefix","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.prefix","doc":"Syntax for making a projection prefix. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L267-L268","name":"Lean.Parser.Command.simpsRule.add","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.add","doc":"Syntax for making a projection default in `initialize_simps_projections`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L265-L266","name":"Lean.Parser.Command.simpsRule.erase","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.erase","doc":"Syntax for making a  projection non-default in `initialize_simps_projections`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L263-L264","name":"Lean.Parser.Command.simpsRule.rename","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.rename","doc":"Syntax for renaming a projection in `initialize_simps_projections`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L256-L259","name":"Lean.Parser.linter.simpsUnusedCustomDeclarations","kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.linter.simpsUnusedCustomDeclarations","doc":"Linter to check that no unused custom declarations are declared for simps. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L251-L254","name":"Lean.Parser.linter.simpsNoConstructor","kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.linter.simpsNoConstructor","doc":"Linter to check that `simps!` is used when needed "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L247-L247","name":"Lean.Parser.Attr.attrSimps?!_","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps?!_","doc":"The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : ℕ × ℤ := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `Neg` or `Mul`,\n  then this notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{StructureName}.Simps.{projectionName}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def Equiv.Simps.invFun (e : α ≃ β) : β → α := e.symm\n  @[simps] def Equiv.trans (e₁ : α ≃ β) (e₂ : β ≃ γ) : α ≃ γ :=\n  ⟨e₂ ∘ e₁, e₁.symm ∘ e₂.symm⟩\n  ```\n  generates\n  ```\n  @[simp] lemma Equiv.trans_toFun : ∀ {α β γ} (e₁ e₂) (a : α), ⇑(e₁.trans e₂) a = (⇑e₂ ∘ ⇑e₁) a\n  @[simp] lemma Equiv.trans_invFun : ∀ {α β γ} (e₁ e₂) (a : γ),\n    ⇑((e₁.trans e₂).symm) a = (⇑(e₁.symm) ∘ ⇑(e₂.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n  See `initialize_simps_projections` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `Prod`, `PProd`, and `Opposite`. You can give explicit projection names or change the value of\n    `Simps.Config.notRecursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type _) := (fst : α) (snd : β)\n  @[simps] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type _) := (fst : α) (snd : β)\n  @[simps fst fst_fst snd] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure EquivPlusData (α β) extends α ≃ β where\n    data : Bool\n  @[simps] def EquivPlusData.rfl {α} : EquivPlusData α α := { Equiv.refl α with data := true }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_toEquiv : ∀ {α : Sort*}, bar.toEquiv = Equiv.refl α\n  @[simp] lemma bar_data : ∀ {α : Sort*}, bar.data = true\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `Equiv.refl α` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `Simps.Config`.\n* The precise syntax is `simps (config := e)? ident*`, where `e : Expr` is an expression of type\n  `Simps.Config` and `ident*` is a list of desired projection names.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`.\n* Use `@[to_additive (attr := simps)]` to apply both `to_additive` and `simps` to a definition\n  This will also generate the additive versions of all `simp` lemmas.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L246-L246","name":"Lean.Parser.Attr.attrSimps!?_","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps!?_","doc":"The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : ℕ × ℤ := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `Neg` or `Mul`,\n  then this notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{StructureName}.Simps.{projectionName}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def Equiv.Simps.invFun (e : α ≃ β) : β → α := e.symm\n  @[simps] def Equiv.trans (e₁ : α ≃ β) (e₂ : β ≃ γ) : α ≃ γ :=\n  ⟨e₂ ∘ e₁, e₁.symm ∘ e₂.symm⟩\n  ```\n  generates\n  ```\n  @[simp] lemma Equiv.trans_toFun : ∀ {α β γ} (e₁ e₂) (a : α), ⇑(e₁.trans e₂) a = (⇑e₂ ∘ ⇑e₁) a\n  @[simp] lemma Equiv.trans_invFun : ∀ {α β γ} (e₁ e₂) (a : γ),\n    ⇑((e₁.trans e₂).symm) a = (⇑(e₁.symm) ∘ ⇑(e₂.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n  See `initialize_simps_projections` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `Prod`, `PProd`, and `Opposite`. You can give explicit projection names or change the value of\n    `Simps.Config.notRecursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type _) := (fst : α) (snd : β)\n  @[simps] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type _) := (fst : α) (snd : β)\n  @[simps fst fst_fst snd] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure EquivPlusData (α β) extends α ≃ β where\n    data : Bool\n  @[simps] def EquivPlusData.rfl {α} : EquivPlusData α α := { Equiv.refl α with data := true }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_toEquiv : ∀ {α : Sort*}, bar.toEquiv = Equiv.refl α\n  @[simp] lemma bar_data : ∀ {α : Sort*}, bar.data = true\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `Equiv.refl α` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `Simps.Config`.\n* The precise syntax is `simps (config := e)? ident*`, where `e : Expr` is an expression of type\n  `Simps.Config` and `ident*` is a list of desired projection names.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`.\n* Use `@[to_additive (attr := simps)]` to apply both `to_additive` and `simps` to a definition\n  This will also generate the additive versions of all `simp` lemmas.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L245-L245","name":"Lean.Parser.Attr.attrSimps!_","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps!_","doc":"The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : ℕ × ℤ := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `Neg` or `Mul`,\n  then this notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{StructureName}.Simps.{projectionName}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def Equiv.Simps.invFun (e : α ≃ β) : β → α := e.symm\n  @[simps] def Equiv.trans (e₁ : α ≃ β) (e₂ : β ≃ γ) : α ≃ γ :=\n  ⟨e₂ ∘ e₁, e₁.symm ∘ e₂.symm⟩\n  ```\n  generates\n  ```\n  @[simp] lemma Equiv.trans_toFun : ∀ {α β γ} (e₁ e₂) (a : α), ⇑(e₁.trans e₂) a = (⇑e₂ ∘ ⇑e₁) a\n  @[simp] lemma Equiv.trans_invFun : ∀ {α β γ} (e₁ e₂) (a : γ),\n    ⇑((e₁.trans e₂).symm) a = (⇑(e₁.symm) ∘ ⇑(e₂.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n  See `initialize_simps_projections` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `Prod`, `PProd`, and `Opposite`. You can give explicit projection names or change the value of\n    `Simps.Config.notRecursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type _) := (fst : α) (snd : β)\n  @[simps] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type _) := (fst : α) (snd : β)\n  @[simps fst fst_fst snd] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure EquivPlusData (α β) extends α ≃ β where\n    data : Bool\n  @[simps] def EquivPlusData.rfl {α} : EquivPlusData α α := { Equiv.refl α with data := true }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_toEquiv : ∀ {α : Sort*}, bar.toEquiv = Equiv.refl α\n  @[simp] lemma bar_data : ∀ {α : Sort*}, bar.data = true\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `Equiv.refl α` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `Simps.Config`.\n* The precise syntax is `simps (config := e)? ident*`, where `e : Expr` is an expression of type\n  `Simps.Config` and `ident*` is a list of desired projection names.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`.\n* Use `@[to_additive (attr := simps)]` to apply both `to_additive` and `simps` to a definition\n  This will also generate the additive versions of all `simp` lemmas.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L244-L244","name":"Lean.Parser.Attr.attrSimps?_","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps?_","doc":"The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : ℕ × ℤ := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `Neg` or `Mul`,\n  then this notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{StructureName}.Simps.{projectionName}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def Equiv.Simps.invFun (e : α ≃ β) : β → α := e.symm\n  @[simps] def Equiv.trans (e₁ : α ≃ β) (e₂ : β ≃ γ) : α ≃ γ :=\n  ⟨e₂ ∘ e₁, e₁.symm ∘ e₂.symm⟩\n  ```\n  generates\n  ```\n  @[simp] lemma Equiv.trans_toFun : ∀ {α β γ} (e₁ e₂) (a : α), ⇑(e₁.trans e₂) a = (⇑e₂ ∘ ⇑e₁) a\n  @[simp] lemma Equiv.trans_invFun : ∀ {α β γ} (e₁ e₂) (a : γ),\n    ⇑((e₁.trans e₂).symm) a = (⇑(e₁.symm) ∘ ⇑(e₂.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n  See `initialize_simps_projections` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `Prod`, `PProd`, and `Opposite`. You can give explicit projection names or change the value of\n    `Simps.Config.notRecursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type _) := (fst : α) (snd : β)\n  @[simps] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type _) := (fst : α) (snd : β)\n  @[simps fst fst_fst snd] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure EquivPlusData (α β) extends α ≃ β where\n    data : Bool\n  @[simps] def EquivPlusData.rfl {α} : EquivPlusData α α := { Equiv.refl α with data := true }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_toEquiv : ∀ {α : Sort*}, bar.toEquiv = Equiv.refl α\n  @[simp] lemma bar_data : ∀ {α : Sort*}, bar.data = true\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `Equiv.refl α` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `Simps.Config`.\n* The precise syntax is `simps (config := e)? ident*`, where `e : Expr` is an expression of type\n  `Simps.Config` and `ident*` is a list of desired projection names.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`.\n* Use `@[to_additive (attr := simps)]` to apply both `to_additive` and `simps` to a definition\n  This will also generate the additive versions of all `simp` lemmas.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L142-L242","name":"Lean.Parser.Attr.simps","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.simps","doc":"The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : ℕ × ℤ := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `Neg` or `Mul`,\n  then this notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{StructureName}.Simps.{projectionName}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def Equiv.Simps.invFun (e : α ≃ β) : β → α := e.symm\n  @[simps] def Equiv.trans (e₁ : α ≃ β) (e₂ : β ≃ γ) : α ≃ γ :=\n  ⟨e₂ ∘ e₁, e₁.symm ∘ e₂.symm⟩\n  ```\n  generates\n  ```\n  @[simp] lemma Equiv.trans_toFun : ∀ {α β γ} (e₁ e₂) (a : α), ⇑(e₁.trans e₂) a = (⇑e₂ ∘ ⇑e₁) a\n  @[simp] lemma Equiv.trans_invFun : ∀ {α β γ} (e₁ e₂) (a : γ),\n    ⇑((e₁.trans e₂).symm) a = (⇑(e₁.symm) ∘ ⇑(e₂.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n  See `initialize_simps_projections` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `Prod`, `PProd`, and `Opposite`. You can give explicit projection names or change the value of\n    `Simps.Config.notRecursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type _) := (fst : α) (snd : β)\n  @[simps] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type _) := (fst : α) (snd : β)\n  @[simps fst fst_fst snd] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure EquivPlusData (α β) extends α ≃ β where\n    data : Bool\n  @[simps] def EquivPlusData.rfl {α} : EquivPlusData α α := { Equiv.refl α with data := true }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_toEquiv : ∀ {α : Sort*}, bar.toEquiv = Equiv.refl α\n  @[simp] lemma bar_data : ∀ {α : Sort*}, bar.data = true\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `Equiv.refl α` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `Simps.Config`.\n* The precise syntax is `simps (config := e)? ident*`, where `e : Expr` is an expression of type\n  `Simps.Config` and `ident*` is a list of desired projection names.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`.\n* Use `@[to_additive (attr := simps)]` to apply both `to_additive` and `simps` to a definition\n  This will also generate the additive versions of all `simp` lemmas.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L139-L140","name":"Lean.Parser.Attr.simpsArgsRest","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.simpsArgsRest","doc":"arguments to `@[simps]` attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L118-L119","name":"hasSimpAttribute","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#hasSimpAttribute","doc":"Tests whether `declName` has the `@[simp]` attribute in `env`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L109-L113","name":"Lean.Meta.mkSimpContext","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Meta.mkSimpContext","doc":"Make `Simp.Context` giving data instead of Syntax. Doesn't support arguments.\nIntended to be very similar to `Lean.Elab.Tactic.mkSimpContext`\nTodo: support arguments. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L76-L104","name":"Lean.Meta.mkSimpContextResult","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Meta.mkSimpContextResult","doc":"Make `MkSimpContextResult` giving data instead of Syntax. Doesn't support arguments.\nIntended to be very similar to `Lean.Elab.Tactic.mkSimpContext`\nTodo: support arguments. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L67-L68","name":"updateName","kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#updateName","doc":"`updateName nm s isPrefix` adds `s` to the last component of `nm`,\neither as prefix or as suffix (specified by `isPrefix`), separated by `_`.\nUsed by `simps_add_projections`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L1-L1","name":"Simps.ParsedProjectionData.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L1-L1","name":"Simps.ProjectionData.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Simps/Basic.lean#L1-L1","name":"Simps.Config.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.mk","doc":""}]}