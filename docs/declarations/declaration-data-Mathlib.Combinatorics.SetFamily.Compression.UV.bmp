{"name":"Mathlib.Combinatorics.SetFamily.Compression.UV","instances":[],"imports":["Init","Mathlib.Combinatorics.SetFamily.Shadow"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L432-L436","name":"UV.card_shadow_compression_le","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.card_shadow_compression_le","doc":"UV-compression reduces the size of the shadow of `ùíú` if, for all `x ‚àà u` there is `y ‚àà v`\nsuch that `ùíú` is `(u.erase x, v.erase y)`-compressed. This is the key UV-compression fact needed for\nKruskal-Katona. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L324-L426","name":"UV.shadow_compression_subset_compression_shadow","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.shadow_compression_subset_compression_shadow","doc":"UV-compression reduces the size of the shadow of `ùíú` if, for all `x ‚àà u` there is `y ‚àà v` such\nthat `ùíú` is `(u.erase x, v.erase y)`-compressed. This is the key fact about compression for\nKruskal-Katona. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L307-L312","name":"UV.card_compress","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.card_compress","doc":"Compressing a finset doesn't change its size. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L304-L304","name":"UV.instDecidableRelFinsetLeToLEToPreorderPartialOrder","kind":"def","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.instDecidableRelFinsetLeToLEToPreorderPartialOrder","doc":"TODO: Make a proper instance "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L282-L291","name":"UV.mem_of_mem_compression","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.mem_of_mem_compression","doc":"If `a` is in the `u, v`-compression but `v ‚â§ a`, then `a` must have been in the original\nfamily. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L261-L277","name":"UV.sup_sdiff_mem_of_mem_compression","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.sup_sdiff_mem_of_mem_compression","doc":"If `a` is in the family compression and can be compressed, then its compression is in the\noriginal family. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L247-L256","name":"UV.sup_sdiff_mem_of_mem_compression_of_not_mem","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.sup_sdiff_mem_of_mem_compression_of_not_mem","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L236-L244","name":"UV.disjoint_of_mem_compression_of_not_mem","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.disjoint_of_mem_compression_of_not_mem","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L225-L233","name":"UV.le_of_mem_compression_of_not_mem","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.le_of_mem_compression_of_not_mem","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L206-L222","name":"UV.card_compression","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.card_compression","doc":"Compressing a family doesn't change its size. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L195-L202","name":"UV.compression_idem","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compression_idem","doc":"Compressing a family is idempotent. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L184-L190","name":"UV.compress_mem_compression_of_mem_compression","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compress_mem_compression_of_mem_compression","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L175-L180","name":"UV.compress_mem_compression","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compress_mem_compression","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L169-L172","name":"UV.compress_idem","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compress_idem","doc":"Compressing an element is idempotent. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L161-L164","name":"UV.compress_disjoint","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compress_disjoint","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L155-L158","name":"UV.compress_sdiff_sdiff","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compress_sdiff_sdiff","doc":"An element can be compressed to any other element by removing/adding the differences. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L149-L150","name":"UV.is_compressed_self","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.is_compressed_self","doc":"Any family is compressed along two identical elements. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L137-L145","name":"UV.compression_self","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compression_self","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L129-L133","name":"UV.compress_self","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compress_self","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L125-L125","name":"UV.IsCompressed.eq","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.IsCompressed.eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L119-L122","name":"UV.mem_compression","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.mem_compression","doc":"`a` is in the UV-compressed family iff it's in the original and its compression is in the\noriginal, or it's not in the original but it's the compression of something in the original. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L110-L114","name":"UV.compress_of_disjoint_of_le'","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compress_of_disjoint_of_le'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L105-L107","name":"UV.compress_of_disjoint_of_le","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compress_of_disjoint_of_le","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L101-L102","name":"UV.IsCompressed","kind":"def","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.IsCompressed","doc":"`IsCompressed u v s` expresses that `s` is UV-compressed. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L96-L97","name":"FinsetFamily.termùìí","kind":"def","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#FinsetFamily.termùìí","doc":"To UV-compress a set family, we compress each of its elements, except that we don't want to\nreduce the cardinality, so we keep all elements whose compression is already present. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L92-L93","name":"UV.compression","kind":"def","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compression","doc":"To UV-compress a set family, we compress each of its elements, except that we don't want to\nreduce the cardinality, so we keep all elements whose compression is already present. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L86-L87","name":"UV.compress","kind":"def","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#UV.compress","doc":"UV-compressing `a` means removing `v` from it and adding `u` if `a` and `u` are disjoint and\n`v ‚â§ a` (it replaces the `v` part of `a` by the `u` part). Else, UV-compressing `a` doesn't do\nanything. This is most useful when `u` and `v` are disjoint finsets of the same size. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/SetFamily/Compression/UV.lean#L60-L67","name":"sup_sdiff_injOn","kind":"theorem","docLink":"./Mathlib/Combinatorics/SetFamily/Compression/UV.html#sup_sdiff_injOn","doc":"UV-compression is injective on the elements it moves. See `UV.compress`. "}]}