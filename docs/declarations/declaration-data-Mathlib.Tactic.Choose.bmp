{"name":"Mathlib.Tactic.Choose","instances":[],"imports":["Init","Mathlib.Util.Tactic","Mathlib.Logic.Function.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L219-L220","name":"Mathlib.Tactic.Choose.tacticChoose!___Using_","kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.tacticChoose!___Using_","doc":"* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b`\n  for some `P Q : X → Y → A → B → Prop` and outputs\n  into context a function `a : X → Y → A`, `b : X → Y → B` and two assumptions:\n  `h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X → A`, `b : X → B`, and the assumptions\n  `h : ∀ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be omitted,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nExamples:\n\n```\nexample (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ℕ → ℕ → ℕ\n  guard_hyp j : ℕ → ℕ → ℕ\n  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : ∀ i : ℕ, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ℕ → ℕ\n  guard_hyp h : ∀ (i : ℕ), i < 7 → i < f i\n  guard_hyp h' : ∀ (i : ℕ), i < 7 → f i < i + i\n  trivial\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L174-L212","name":"Mathlib.Tactic.Choose.choose","kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose","doc":"* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b`\n  for some `P Q : X → Y → A → B → Prop` and outputs\n  into context a function `a : X → Y → A`, `b : X → Y → B` and two assumptions:\n  `h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X → A`, `b : X → B`, and the assumptions\n  `h : ∀ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be omitted,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nExamples:\n\n```\nexample (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ℕ → ℕ → ℕ\n  guard_hyp j : ℕ → ℕ → ℕ\n  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : ∀ i : ℕ, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ℕ → ℕ\n  guard_hyp h : ∀ (i : ℕ), i < 7 → i < f i\n  guard_hyp h' : ∀ (i : ℕ), i < 7 → f i < i + i\n  trivial\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L154-L172","name":"Mathlib.Tactic.Choose.elabChoose","kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.elabChoose","doc":"A loop around `choose1`. The main entry point for the `choose` tactic. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L146-L151","name":"Mathlib.Tactic.Choose.choose1WithInfo","kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1WithInfo","doc":"A wrapper around `choose1` that parses identifiers and adds variable info to new variables. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L79-L143","name":"Mathlib.Tactic.Choose.choose1","kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1","doc":"Changes `(h : ∀xs, ∃a:α, p a) ⊢ g` to `(d : ∀xs, a) ⊢ (s : ∀xs, p (d xs)) → g` and\n`(h : ∀xs, p xs ∧ q xs) ⊢ g` to `(d : ∀xs, p xs) ⊢ (s : ∀xs, q xs) → g`.\n`choose1` returns a tuple of\n\n- the error result (see `ElimStatus`)\n- the data new free variable that was \"chosen\"\n- the new goal (which contains the spec of the data as domain of an arrow type)\n\nIf `nondep` is true and `α` is inhabited, then it will remove the dependency of `d` on\nall propositional assumptions in `xs`. For example if `ys` are propositions then\n`(h : ∀xs ys, ∃a:α, p a) ⊢ g` becomes `(d : ∀xs, a) (s : ∀xs ys, p (d xs)) ⊢ g`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L65-L66","name":"Mathlib.Tactic.Choose.mkFreshNameFrom","kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mkFreshNameFrom","doc":"`mkFreshNameFrom orig base` returns `mkFreshUserName base` if ``orig = `_``\nand `orig` otherwise. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L58-L61","name":"Mathlib.Tactic.Choose.ElimStatus.merge","kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.merge","doc":"Combine two statuses, keeping a success from either side\nor merging the failures. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L54-L54","name":"Mathlib.Tactic.Choose.ElimStatus.failure","kind":"ctor","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.failure","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L53-L53","name":"Mathlib.Tactic.Choose.ElimStatus.success","kind":"ctor","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.success","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L52-L54","name":"Mathlib.Tactic.Choose.ElimStatus","kind":"inductive","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus","doc":"Results of searching for nonempty instances,\nto eliminate dependencies on propositions (`choose!`).\n`success` means we found at least one instance;\n`failure ts` means we didn't find instances for any `t ∈ ts`.\n(`failure []` means we didn't look for instances at all.)\n\nRationale:\n`choose!` means we are expected to succeed at least once\nin eliminating dependencies on propositions.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Choose.lean#L28-L40","name":"Mathlib.Tactic.Choose.mk_sometimes","kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mk_sometimes","doc":"Given `α : Sort u`, `nonemp : Nonempty α`, `p : α → Prop`, a context of free variables\n`ctx`, and a pair of an element `val : α` and `spec : p val`,\n`mk_sometimes u α nonemp p ctx (val, spec)` produces another pair `val', spec'`\nsuch that `val'` does not have any free variables from elements of `ctx` whose types are\npropositions. This is done by applying `Function.sometimes` to abstract over all the propositional\narguments. "}]}