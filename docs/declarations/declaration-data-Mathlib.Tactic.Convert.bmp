{"name":"Mathlib.Tactic.Convert","instances":[],"imports":["Init","Lean","Mathlib.Tactic.Congr!"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Convert.lean#L118-L130","name":"convertTo","kind":"def","docLink":"./Mathlib/Tactic/Convert.html#convertTo","doc":"`convert_to g using n` attempts to change the current goal to `g`, but unlike `change`,\nit will generate equality proof obligations using `congr! n` to resolve discrepancies.\n`convert_to g` defaults to using `congr! 1`.\n`convert_to` is similar to `convert`, but `convert_to` takes a type (the desired subgoal) while\n`convert` takes a proof term.\nThat is, `convert_to g using n` is equivalent to `convert (?_ : g) using n`.\n\nThe syntax for `convert_to` is the same as for `convert`, and it has variations such as\n`convert_to ← g` and `convert_to (config := {transparency := .default}) g`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Convert.lean#L36-L99","name":"convert","kind":"def","docLink":"./Mathlib/Tactic/Convert.html#convert","doc":"The `exact e` and `refine e` tactics require a term `e` whose type is\ndefinitionally equal to the goal. `convert e` is similar to `refine e`,\nbut the type of `e` is not required to exactly match the\ngoal. Instead, new goals are created for differences between the type\nof `e` and the goal using the same strategies as the `congr!` tactic.\nFor example, in the proof state\n\n```lean\nn : ℕ,\ne : Prime (2 * n + 1)\n⊢ Prime (n + n + 1)\n```\n\nthe tactic `convert e using 2` will change the goal to\n\n```lean\n⊢ n + n = 2 * n\n```\n\nIn this example, the new goal can be solved using `ring`.\n\nThe `using 2` indicates it should iterate the congruence algorithm up to two times,\nwhere `convert e` would use an unrestricted number of iterations and lead to two\nimpossible goals: `⊢ HAdd.hAdd = HMul.hMul` and `⊢ n = 2`.\n\nA variant configuration is `convert (config := .unfoldSameFun) e`, which only equates function\napplications for the same function (while doing so at the higher `default` transparency).\nThis gives the same goal of `⊢ n + n = 2 * n` without needing `using 2`.\n\nThe `convert` tactic applies congruence lemmas eagerly before reducing,\ntherefore it can fail in cases where `exact` succeeds:\n```lean\ndef p (n : ℕ) := true\nexample (h : p 0) : p 1 := by exact h -- succeeds\nexample (h : p 0) : p 1 := by convert h -- fails, with leftover goal `1 = 0`\n```\nLimiting the depth of recursion can help with this. For example, `convert h using 1` will work\nin this case.\n\nThe syntax `convert ← e` will reverse the direction of the new goals\n(producing `⊢ 2 * n = n + n` in this example).\n\nInternally, `convert e` works by creating a new goal asserting that\nthe goal equals the type of `e`, then simplifying it using\n`congr!`. The syntax `convert e using n` can be used to control the\ndepth of matching (like `congr! n`). In the example, `convert e using 1`\nwould produce a new goal `⊢ n + n + 1 = 2 * n + 1`.\n\nRefer to the `congr!` tactic to understand the congruence operations. One of its many\nfeatures is that if `x y : t` and an instance `Subsingleton t` is in scope,\nthen any goals of the form `x = y` are solved automatically.\n\nLike `congr!`, `convert` takes an optional `with` clause of `rintro` patterns,\nfor example `convert e using n with x y z`.\n\nThe `convert` tactic also takes a configuration option, for example\n```lean\nconvert (config := {transparency := .default}) h\n```\nThese are passed to `congr!`. See `Congr!.Config` for options.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Convert.lean#L24-L34","name":"Lean.MVarId.convert","kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Lean.MVarId.convert","doc":"Close the goal `g` using `Eq.mp v e`,\nwhere `v` is a metavariable asserting that the type of `g` and `e` are equal.\nThen call `MVarId.congrN!` (also using local hypotheses and reflexivity) on `v`,\nand return the resulting goals.\n\nWith `sym = true`, reverses the equality in `v`, and uses `Eq.mpr v e` instead.\nWith `depth = some n`, calls `MVarId.congrN! n` instead, with `n` as the max recursion depth.\n"}]}