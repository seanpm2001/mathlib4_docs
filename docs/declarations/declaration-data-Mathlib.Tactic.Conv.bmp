{"name":"Mathlib.Tactic.Conv","instances":[],"imports":["Init","Mathlib.Tactic.RunCmd","Lean.Elab.Tactic.Conv.Basic","Std.Lean.Parser"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L110-L117","name":"Mathlib.Tactic.Conv.«command#simpOnly_=>__»","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#simpOnly_=>__»","doc":"* `#simp => e` runs `simp` on the expression `e` and displays the resulting expression after\n  simplification.\n* `#simp only [lems] => e` runs `simp only [lems]` on `e`.\n* The `=>` is optional, so `#simp e` and `#simp only [lems] e` have the same behavior.\n  It is mostly useful for disambiguating the expression `e` from the lemmas.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L108-L108","name":"Mathlib.Tactic.Conv.«command#whnfR_»","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#whnfR_»","doc":"The command `#whnfR e` evaluates `e` to Weak Head Normal Form with Reducible transparency,\nthat is, it uses `whnf` but only unfolding reducible definitions.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L102-L102","name":"Mathlib.Tactic.Conv.«command#whnf_»","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#whnf_»","doc":"The command `#whnf e` evaluates `e` to Weak Head Normal Form, which means that the \"head\"\nof the expression is reduced to a primitive - a lambda or forall, or an axiom or inductive type.\nIt is similar to `#reduce e`, but it does not reduce the expression completely,\nonly until the first constructor is exposed. For example:\n```\nopen Nat List\nset_option pp.notation false\n#whnf [1, 2, 3].map succ\n-- cons (succ 1) (map succ (cons 2 (cons 3 nil)))\n#reduce [1, 2, 3].map succ\n-- cons 2 (cons 3 (cons 4 nil))\n```\nThe head of this expression is the `List.cons` constructor,\nso we can see from this much that the list is not empty,\nbut the subterms `Nat.succ 1` and `List.map Nat.succ (List.cons 2 (List.cons 3 List.nil))` are\nstill unevaluated. `#reduce` is equivalent to using `#whnf` on every subexpression.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L81-L82","name":"Mathlib.Tactic.Conv.withReducible","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.withReducible","doc":"`with_reducible tacs` excutes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L57-L78","name":"Mathlib.Tactic.Conv.«command#conv_=>_»","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#conv_=>_»","doc":"The command `#conv tac => e` will run a conv tactic `tac` on `e`, and display the resulting\nexpression (discarding the proof).\nFor example, `#conv rw [true_and] => True ∧ False` displays `False`.\nThere are also shorthand commands for several common conv tactics:\n\n* `#whnf e` is short for `#conv whnf => e`\n* `#simp e` is short for `#conv simp => e`\n* `#norm_num e` is short for `#conv norm_num => e`\n* `#push_neg e` is short for `#conv push_neg => e`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L54-L54","name":"Mathlib.Tactic.Conv.convRefine_","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRefine_","doc":"Use `refine` in `conv` mode. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L37-L51","name":"Mathlib.Tactic.Conv.elabDischargeConv","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.elabDischargeConv","doc":"Elaborator for the `discharge` tactic. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L29-L34","name":"Mathlib.Tactic.Conv.dischargeConv","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.dischargeConv","doc":"* `discharge => tac` is a conv tactic which rewrites target `p` to `True` if `tac` is a tactic\n  which proves the goal `⊢ p`.\n* `discharge` without argument returns `⊢ p` as a subgoal.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L27-L27","name":"Mathlib.Tactic.Conv.convRun_conv_","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRun_conv_","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L22-L22","name":"Mathlib.Tactic.Conv.convRHS","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRHS","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Conv.lean#L17-L17","name":"Mathlib.Tactic.Conv.convLHS","kind":"def","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convLHS","doc":""}]}