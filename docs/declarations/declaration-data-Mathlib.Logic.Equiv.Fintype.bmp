{"name":"Mathlib.Logic.Equiv.Fintype","instances":[],"imports":["Init","Mathlib.Data.Fintype.Basic","Mathlib.GroupTheory.Perm.Sign","Mathlib.Logic.Equiv.Defs"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L140-L143","name":"Equiv.extendSubtype_not_mem","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.extendSubtype_not_mem","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L133-L137","name":"Equiv.extendSubtype_apply_of_not_mem","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.extendSubtype_apply_of_not_mem","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L127-L130","name":"Equiv.extendSubtype_mem","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.extendSubtype_mem","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L120-L124","name":"Equiv.extendSubtype_apply_of_mem","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.extendSubtype_apply_of_mem","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L116-L117","name":"Equiv.extendSubtype","kind":"def","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.extendSubtype","doc":"If `e` is an equivalence between two subtypes of a fintype `α`, `e.extendSubtype`\nis a permutation of `α` acting like `e` on the subtypes and doing something arbitrary outside.\n\nNote that when `p = q`, `Equiv.Perm.subtypeCongr e (Equiv.refl _)` can be used instead. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L107-L109","name":"Equiv.toCompl","kind":"def","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.toCompl","doc":"If `e` is an equivalence between two subtypes of a fintype `α`, `e.toCompl`\nis an equivalence between the complement of those subtypes.\n\nSee also `Equiv.compl`, for a computable version when a term of type\n`{e' : α ≃ α // ∀ x : {x // p x}, e' x = e x}` is known. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L93-L95","name":"Equiv.Perm.viaFintypeEmbedding_sign","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.Perm.viaFintypeEmbedding_sign","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L87-L89","name":"Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L80-L84","name":"Equiv.Perm.viaFintypeEmbedding_apply_mem_range","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.Perm.viaFintypeEmbedding_apply_mem_range","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L74-L77","name":"Equiv.Perm.viaFintypeEmbedding_apply_image","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.Perm.viaFintypeEmbedding_apply_image","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L69-L70","name":"Equiv.Perm.viaFintypeEmbedding","kind":"def","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Equiv.Perm.viaFintypeEmbedding","doc":"Extend the domain of `e : Equiv.Perm α`, mapping it through `f : α ↪ β`.\nEverything outside of `Set.range f` is kept fixed. Has poor computational performance,\ndue to exhaustive searching in constructed inverse due to using `Function.Embedding.toEquivRange`.\nWhen a better `α ≃ Set.range f` is known, use `Equiv.Perm.viaSetRange`.\nWhen `[Fintype α]` is not available, a noncomputable version is available as\n`Equiv.Perm.viaEmbedding`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L56-L59","name":"Function.Embedding.toEquivRange_eq_ofInjective","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Function.Embedding.toEquivRange_eq_ofInjective","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L52-L53","name":"Function.Embedding.toEquivRange_symm_apply_self","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Function.Embedding.toEquivRange_symm_apply_self","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L46-L48","name":"Function.Embedding.toEquivRange_apply","kind":"theorem","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Function.Embedding.toEquivRange_apply","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Equiv/Fintype.lean#L41-L42","name":"Function.Embedding.toEquivRange","kind":"def","docLink":"./Mathlib/Logic/Equiv/Fintype.html#Function.Embedding.toEquivRange","doc":"Computably turn an embedding `f : α ↪ β` into an equiv `α ≃ Set.range f`,\nif `α` is a `Fintype`. Has poor computational performance, due to exhaustive searching in\nconstructed inverse. When a better inverse is known, use `Equiv.ofLeftInverse'` or\n`Equiv.ofLeftInverse` instead. This is the computable version of `Equiv.ofInjective`.\n"}]}