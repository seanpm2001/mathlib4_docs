{"name":"Std.Data.List.Basic","instances":[{"typeNames":["List"],"name":"List.instHasSubsetList","className":"HasSubset"},{"typeNames":["Exists","And","Membership.mem","List","List.instMembershipList"],"name":"List.decidableBEx","className":"Decidable"},{"typeNames":["Membership.mem","List","List.instMembershipList"],"name":"List.decidableBAll","className":"Decidable"},{"typeNames":["List"],"name":"List.instUnionList","className":"Union"},{"typeNames":["List"],"name":"List.instInterList","className":"Inter"},{"typeNames":["List.Pairwise"],"name":"List.instDecidablePairwise","className":"Decidable"},{"typeNames":["List.Nodup"],"name":"List.nodupDecidable","className":"Decidable"}],"imports":["Init","Std.Classes.SetNotation","Std.Tactic.NoMatch","Std.Data.Option.Init.Lemmas","Std.Data.Array.Init.Lemmas"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1580-L1581","name":"List.mapWithComplement","kind":"def","docLink":"./Std/Data/List/Basic.html#List.mapWithComplement","doc":"`List.mapWithComplement f l` is a variant of `List.mapWithPrefixSuffix`\nthat maps `f` across a list `l`.\nFor each `a ∈ l` with `l = pref ++ [a] ++ suff`, `a` is mapped to `f a (pref ++ suff)`,\ni.e., the list input to `f` is `l` with `a` removed.\nExample: if `f : Nat → list Nat → β`, `List.mapWithComplement f [1, 2, 3]` will produce the list\n`[f 1 [2, 3], f 2 [1, 3], f 3 [1, 2]]`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1569-L1570","name":"List.mapWithPrefixSuffix","kind":"def","docLink":"./Std/Data/List/Basic.html#List.mapWithPrefixSuffix","doc":"`List.mapWithPrefixSuffix f l` maps `f` across a list `l`.\nFor each `a ∈ l` with `l = pref ++ [a] ++ suff`, `a` is mapped to `f pref a suff`.\nExample: if `f : list Nat → Nat → list Nat → β`,\n`List.mapWithPrefixSuffix f [1, 2, 3]` will produce the list\n`[f [] 1 [2, 3], f [1] 2 [3], f [1, 2] 3 []]`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1558-L1560","name":"List.mapWithPrefixSuffixAux","kind":"def","docLink":"./Std/Data/List/Basic.html#List.mapWithPrefixSuffixAux","doc":"An auxiliary function for `List.mapWithPrefixSuffix`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1552-L1554","name":"List.zipWith₅","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWith₅","doc":"Quinary version of `List.zipWith`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1547-L1549","name":"List.zipWith₄","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWith₄","doc":"Quaternary version of `List.zipWith`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1542-L1544","name":"List.zipWith₃","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWith₃","doc":"Ternary version of `List.zipWith`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1522-L1528","name":"List.toChunks.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.toChunks.go","doc":"Auxliary definition used to define `toChunks`.\n`toChunks.go xs acc₁ acc₂` pushes elements into `acc₁` until it reaches size `n`,\nthen it pushes the resulting list to `acc₂` and continues until `xs` is exhausted. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1514-L1529","name":"List.toChunks","kind":"def","docLink":"./Std/Data/List/Basic.html#List.toChunks","doc":"`xs.toChunks n` splits the list into sublists of size at most `n`,\nsuch that `(xs.toChunks n).join = xs`.\n```\n[1, 2, 3, 4, 5, 6, 7, 8].toChunks 10 = [[1, 2, 3, 4, 5, 6, 7, 8]]\n[1, 2, 3, 4, 5, 6, 7, 8].toChunks 3 = [[1, 2, 3], [4, 5, 6], [7, 8]]\n[1, 2, 3, 4, 5, 6, 7, 8].toChunks 2 = [[1, 2], [3, 4], [5, 6], [7, 8]]\n[1, 2, 3, 4, 5, 6, 7, 8].toChunks 0 = [[1, 2, 3, 4, 5, 6, 7, 8]]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1495-L1502","name":"List.toChunksAux","kind":"def","docLink":"./Std/Data/List/Basic.html#List.toChunksAux","doc":"Auxliary definition used to define `toChunks`.\n`toChunksAux n xs i` returns `(xs.take i, (xs.drop i).toChunks (n+1))`,\nthat is, the first `i` elements of `xs`, and the remaining elements chunked into\nsublists of length `n+1`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1485-L1488","name":"List.takeList_eq_takeListTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.takeList_eq_takeListTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1483-L1489","name":"List.takeList_eq_takeListTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.takeList_eq_takeListTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1477-L1481","name":"List.takeListTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeListTR.go","doc":"Auxiliary for `takeListTR`: `takeListTR.go as as' acc = acc.toList ++ takeList as as'`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1474-L1481","name":"List.takeListTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeListTR","doc":"Tail-recursive version of `takeList`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1466-L1471","name":"List.takeList","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeList","doc":"`takeList as ns` extracts successive sublists from `as`. For `ns = n₁ ... nₘ`,\nit first takes the `n₁` initial elements from `as`, then the next `n₂` ones,\netc. It returns the sublists of `as` -- one for each `nᵢ` -- and the remaining\nelements of `as`. If `as` does not have at least as many elements as the sum of\nthe `nᵢ`, the corresponding sublists will have less than `nᵢ` elements.\n```\ntakeList ['a', 'b', 'c', 'd', 'e'] [2, 1, 1] = ([['a', 'b'], ['c'], ['d']], ['e'])\ntakeList ['a', 'b'] [3, 1] = ([['a', 'b'], []], [])\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1448-L1452","name":"List.fillNones_eq_fillNonesTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.fillNones_eq_fillNonesTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1446-L1453","name":"List.fillNones_eq_fillNonesTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.fillNones_eq_fillNonesTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1440-L1444","name":"List.fillNonesTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.fillNonesTR.go","doc":"Auxiliary for `fillNonesTR`: `fillNonesTR.go as as' acc = acc.toList ++ fillNones as as'`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1438-L1444","name":"List.fillNonesTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.fillNonesTR","doc":"Tail-recursive version of `fillNones`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1431-L1435","name":"List.fillNones","kind":"def","docLink":"./Std/Data/List/Basic.html#List.fillNones","doc":"`fillNones xs ys` replaces the `none`s in `xs` with elements of `ys`. If there\nare not enough `ys` to replace all the `none`s, the remaining `none`s are\ndropped from `xs`.\n```\nfillNones [none, some 1, none, none] [2, 3] = [2, 1, 3]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1421-L1421","name":"List.allSome","kind":"def","docLink":"./Std/Data/List/Basic.html#List.allSome","doc":"If all elements of `xs` are `some xᵢ`, `allSome xs` returns the `xᵢ`. Otherwise\nit returns `none`.\n```\nallSome [some 1, some 2] = some [1, 2]\nallSome [some 1, none  ] = none\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1411-L1411","name":"List.zipRight","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipRight","doc":"Right-biased version of `List.zip`. `zipRight as bs` returns the list of pairs\n`(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, the\nremaining `bᵢ` are paired with `none`.\n```\nzipRight [1, 2] ['a'] = [(some 1, 'a')]\nzipRight [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]\nzipRight = zipWithRight prod.mk\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1399-L1399","name":"List.zipLeft","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipLeft","doc":"Left-biased version of `List.zip`. `zipLeft as bs` returns the list of pairs\n`(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, the\nremaining `aᵢ` are paired with `none`.\n```\nzipLeft [1, 2] ['a'] = [(1, some 'a'), (2, none)]\nzipLeft [1] ['a', 'b'] = [(1, some 'a')]\nzipLeft = zipWithLeft prod.mk\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1386-L1387","name":"List.zipWithRight","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWithRight","doc":"Right-biased version of `List.zipWith`. `zipWithRight f as bs` applies `f` to each\npair `aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `as` is shorter than `bs`, `f` is applied to\n`none` for the remaining `bᵢ`.\n```\nzipWithRight prod.mk [1, 2] ['a'] = [(some 1, 'a')]\nzipWithRight prod.mk [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]\nzipWithRight f as bs = (zipWithRight' f as bs).fst\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1370-L1373","name":"List.zipWithLeft_eq_zipWithLeftTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.zipWithLeft_eq_zipWithLeftTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1368-L1374","name":"List.zipWithLeft_eq_zipWithLeftTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.zipWithLeft_eq_zipWithLeftTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1363-L1366","name":"List.zipWithLeftTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWithLeftTR.go","doc":"Auxiliary for `zipWithLeftTR`: `zipWithLeftTR.go l acc = acc.toList ++ zipWithLeft l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1360-L1366","name":"List.zipWithLeftTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWithLeftTR","doc":"Tail-recursive version of `zipWithLeft`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1354-L1357","name":"List.zipWithLeft","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWithLeft","doc":"Left-biased version of `List.zipWith`. `zipWithLeft f as bs` applies `f` to each pair\n`aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `bs` is shorter than `as`, `f` is applied to `none`\nfor the remaining `aᵢ`.\n```\nzipWithLeft prod.mk [1, 2] ['a'] = [(1, some 'a'), (2, none)]\nzipWithLeft prod.mk [1] ['a', 'b'] = [(1, some 'a')]\nzipWithLeft f as bs = (zipWithLeft' f as bs).fst\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1342-L1342","name":"List.zipRight'","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipRight'","doc":"Right-biased version of `List.zip`. `zipRight' as bs` returns the list of\npairs `(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, the\nremaining `bᵢ` are paired with `none`. Also returns the remaining `as`.\n```\nzipRight' [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])\nzipRight' [1, 2] ['a'] = ([(some 1, 'a')], [2])\nzipRight' = zipWithRight' prod.mk\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1330-L1330","name":"List.zipLeft'","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipLeft'","doc":"Left-biased version of `List.zip`. `zipLeft' as bs` returns the list of\npairs `(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, the\nremaining `aᵢ` are paired with `none`. Also returns the remaining `bs`.\n```\nzipLeft' [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])\nzipLeft' [1] ['a', 'b'] = ([(1, some 'a')], ['b'])\nzipLeft' = zipWithLeft' prod.mk\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1317-L1318","name":"List.zipWithRight'","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWithRight'","doc":"Right-biased version of `List.zipWith`. `zipWithRight' f as bs` applies `f` to each\npair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, `f` is\napplied to `none` for the remaining `bᵢ`. Returns the results of the `f`\napplications and the remaining `as`.\n```\nzipWithRight' prod.mk [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])\nzipWithRight' prod.mk [1, 2] ['a'] = ([(some 1, 'a')], [2])\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1300-L1304","name":"List.zipWithLeft'_eq_zipWithLeft'TR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.zipWithLeft'_eq_zipWithLeft'TR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1298-L1305","name":"List.zipWithLeft'_eq_zipWithLeft'TR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.zipWithLeft'_eq_zipWithLeft'TR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1293-L1296","name":"List.zipWithLeft'TR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWithLeft'TR.go","doc":"Auxiliary for `zipWithLeft'TR`: `zipWithLeft'TR.go l acc = acc.toList ++ zipWithLeft' l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1290-L1296","name":"List.zipWithLeft'TR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWithLeft'TR","doc":"Tail-recursive version of `zipWithLeft'`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1284-L1287","name":"List.zipWithLeft'","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWithLeft'","doc":"Left-biased version of `List.zipWith`. `zipWithLeft' f as bs` applies `f` to each\npair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, `f` is\napplied to `none` for the remaining `aᵢ`. Returns the results of the `f`\napplications and the remaining `bs`.\n```\nzipWithLeft' prod.mk [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])\nzipWithLeft' prod.mk [1] ['a', 'b'] = ([(1, some 'a')], ['b'])\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1267-L1271","name":"List.dropSlice_eq_dropSliceTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.dropSlice_eq_dropSliceTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1263-L1272","name":"List.dropSlice_eq_dropSliceTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.dropSlice_eq_dropSliceTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1259-L1261","name":"List.dropSlice_zero₂","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.dropSlice_zero₂","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1254-L1257","name":"List.dropSliceTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.dropSliceTR.go","doc":"Auxiliary for `dropSliceTR`: `dropSliceTR.go l m xs n acc = acc.toList ++ dropSlice n m xs`\nunless `n ≥ length xs`, in which case it is `l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1247-L1257","name":"List.dropSliceTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.dropSliceTR","doc":"Optimized version of `dropSlice`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1241-L1244","name":"List.dropSlice","kind":"def","docLink":"./Std/Data/List/Basic.html#List.dropSlice","doc":"`List.dropSlice n m xs` removes a slice of length `m` at index `n` in list `xs`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1235-L1238","name":"List.getRest","kind":"def","docLink":"./Std/Data/List/Basic.html#List.getRest","doc":"`getRest l l₁` returns `some l₂` if `l = l₁ ++ l₂`.\nIf `l₁` is not a prefix of `l`, returns `none` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1229-L1231","name":"List.forDiagM","kind":"def","docLink":"./Std/Data/List/Basic.html#List.forDiagM","doc":"`forDiagM f l` calls `f` on all elements in the upper triangular part of `l × l`.\nThat is, for each `e ∈ l`, it will run `f e e` and then `f e e'`\nfor each `e'` that appears after `e` in `l`.\n```\nforDiagM f [1, 2, 3] = do f 1 1; f 1 2; f 1 3; f 2 2; f 2 3; f 3 3\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1214-L1219","name":"List.mapDiagM.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.mapDiagM.go","doc":"Auxiliary for `mapDiagM`: `mapDiagM.go as f acc = (acc.toList ++ ·) <$> mapDiagM f as` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1212-L1219","name":"List.mapDiagM","kind":"def","docLink":"./Std/Data/List/Basic.html#List.mapDiagM","doc":"`mapDiagM f l` calls `f` on all elements in the upper triangular part of `l × l`.\nThat is, for each `e ∈ l`, it will run `f e e` and then `f e e'`\nfor each `e'` that appears after `e` in `l`.\n```\nmapDiagM f [1, 2, 3] =\n  return [← f 1 1, ← f 1 2, ← f 1 3, ← f 2 2, ← f 2 3, ← f 3 3]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1198-L1201","name":"List.rotate'","kind":"def","docLink":"./Std/Data/List/Basic.html#List.rotate'","doc":"`rotate'` is the same as `rotate`, but slower. Used for proofs about `rotate` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1193-L1195","name":"List.rotate","kind":"def","docLink":"./Std/Data/List/Basic.html#List.rotate","doc":"`rotate l n` rotates the elements of `l` to the left by `n`\n```\nrotate [0, 1, 2, 3, 4, 5] 2 = [2, 3, 4, 5, 0, 1]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1182-L1185","name":"List.last'","kind":"def","docLink":"./Std/Data/List/Basic.html#List.last'","doc":"`last' xs` returns the last element of `xs` if `xs` is non-empty; it returns `none` otherwise.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1175-L1177","name":"List.ilast'","kind":"def","docLink":"./Std/Data/List/Basic.html#List.ilast'","doc":"`ilast' x xs` returns the last element of `xs` if `xs` is non-empty; it returns `x` otherwise.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1169-L1170","name":"List.reduceOption","kind":"def","docLink":"./Std/Data/List/Basic.html#List.reduceOption","doc":"Drop `none`s from a list, and replace each remaining `some a` with `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1159-L1165","name":"List.range'_eq_range'TR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.range'_eq_range'TR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1157-L1166","name":"List.range'_eq_range'TR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.range'_eq_range'TR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1153-L1155","name":"List.range'TR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.range'TR.go","doc":"Auxiliary for `range'TR`: `range'TR.go n e = [e-n, ..., e-1] ++ acc`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1151-L1155","name":"List.range'TR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.range'TR","doc":"Optimized version of `range'`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1146-L1148","name":"List.range'","kind":"def","docLink":"./Std/Data/List/Basic.html#List.range'","doc":"`range' start len step` is the list of numbers `[start, start+step, ..., start+(len-1)*step]`.\nIt is intended mainly for proving properties of `range` and `iota`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1142-L1142","name":"List.eraseDup","kind":"def","docLink":"./Std/Data/List/Basic.html#List.eraseDup","doc":"`eraseDup l` removes duplicates from `l` (taking only the first occurrence).\nDefined as `pwFilter (≠)`.\n\n    eraseDup [1, 0, 2, 2, 1] = [0, 2, 1] "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1135-L1136","name":"List.nodupDecidable","kind":"instance","docLink":"./Std/Data/List/Basic.html#List.nodupDecidable","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1133-L1133","name":"List.Nodup","kind":"def","docLink":"./Std/Data/List/Basic.html#List.Nodup","doc":"`Nodup l` means that `l` has no duplicates, that is, any element appears at most\nonce in the List. It is defined as `Pairwise (≠)`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1125-L1127","name":"List.Chain'","kind":"def","docLink":"./Std/Data/List/Basic.html#List.Chain'","doc":"`Chain' R l` means that `R` holds between adjacent elements of `l`.\n```\nChain' R [a, b, c, d] ↔ R a b ∧ R b c ∧ R c d\n``` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1118-L1119","name":"List.Chain.cons","kind":"ctor","docLink":"./Std/Data/List/Basic.html#List.Chain.cons","doc":"If `a` relates to `b` and `b::l` is a chain, then `a :: b :: l` is also a chain. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1116-L1117","name":"List.Chain.nil","kind":"ctor","docLink":"./Std/Data/List/Basic.html#List.Chain.nil","doc":"A chain of length 1 is trivially a chain. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1115-L1119","name":"List.Chain","kind":"inductive","docLink":"./Std/Data/List/Basic.html#List.Chain","doc":"`Chain R a l` means that `R` holds between adjacent elements of `a::l`.\n```\nChain R a [b, c, d] ↔ R a b ∧ R b c ∧ R c d\n``` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1104-L1105","name":"List.pwFilter","kind":"def","docLink":"./Std/Data/List/Basic.html#List.pwFilter","doc":"`pwFilter R l` is a maximal sublist of `l` which is `Pairwise R`.\n`pwFilter (·≠·)` is the erase duplicates function (cf. `eraseDup`), and `pwFilter (·<·)` finds\na maximal increasing subsequence in `l`. For example,\n```\npwFilter (·<·) [0, 1, 5, 2, 6, 3, 4] = [0, 1, 2, 3, 4]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1083-L1092","name":"List.instDecidablePairwise","kind":"instance","docLink":"./Std/Data/List/Basic.html#List.instDecidablePairwise","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1080-L1081","name":"List.pairwise_cons","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.pairwise_cons","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1072-L1074","name":"List.Pairwise.cons","kind":"ctor","docLink":"./Std/Data/List/Basic.html#List.Pairwise.cons","doc":"`a :: l` is `Pairwise R` if `a` `R`-relates to every element of `l`,\nand `l` is `Pairwise R`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1070-L1071","name":"List.Pairwise.nil","kind":"ctor","docLink":"./Std/Data/List/Basic.html#List.Pairwise.nil","doc":"All elements of the empty list are vacuously pairwise related. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1069-L1074","name":"List.Pairwise","kind":"inductive","docLink":"./Std/Data/List/Basic.html#List.Pairwise","doc":"`Pairwise R l` means that all the elements with earlier indexes are\n`R`-related to all the elements with later indexes.\n```\nPairwise R [1, 2, 3] ↔ R 1 2 ∧ R 1 3 ∧ R 2 3\n```\nFor example if `R = (·≠·)` then it asserts `l` has no duplicates,\nand if `R = (·<·)` then it asserts that `l` is (strictly) sorted.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1050-L1053","name":"List.takeWhile₂_eq_takeWhile₂TR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.takeWhile₂_eq_takeWhile₂TR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1048-L1054","name":"List.takeWhile₂_eq_takeWhile₂TR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.takeWhile₂_eq_takeWhile₂TR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1043-L1046","name":"List.takeWhile₂TR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeWhile₂TR.go","doc":"Auxiliary for `takeWhile₂TR`:\n`takeWhile₂TR.go R as bs acca accb = (acca.reverse ++ as', acca.reverse ++ bs')`\nif `takeWhile₂ R as bs = (as', bs')`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1037-L1046","name":"List.takeWhile₂TR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeWhile₂TR","doc":"Tail-recursive version of `takeWhile₂`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1029-L1034","name":"List.takeWhile₂","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeWhile₂","doc":"Returns the longest initial prefix of two lists such that they are pairwise related by `R`.\n```\ntakeWhile₂ (· < ·) [1, 2, 4, 5] [5, 4, 3, 6] = ([1, 2], [5, 4])\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1020-L1021","name":"List.Disjoint","kind":"def","docLink":"./Std/Data/List/Basic.html#List.Disjoint","doc":"`disjoint l₁ l₂` means that `l₁` and `l₂` have no elements in common. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1016-L1017","name":"List.ofFnNthVal","kind":"def","docLink":"./Std/Data/List/Basic.html#List.ofFnNthVal","doc":"`ofFnNthVal f i` returns `some (f i)` if `i < n` and `none` otherwise. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1013-L1013","name":"List.ofFn","kind":"def","docLink":"./Std/Data/List/Basic.html#List.ofFn","doc":"`ofFn f` with `f : fin n → α` returns the list whose ith element is `f i`\n```\nofFn f = [f 0, f 1, ... , f(n - 1)]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L1002-L1005","name":"List.sigma_eq_sigmaTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.sigma_eq_sigmaTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L999-L1000","name":"List.sigmaTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.sigmaTR","doc":"Optimized version of `sigma`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L995-L996","name":"List.sigma","kind":"def","docLink":"./Std/Data/List/Basic.html#List.sigma","doc":"`sigma l₁ l₂` is the list of dependent pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂ a`.\n```\nsigma [1, 2] (λ_, [(5 : Nat), 6]) = [(1, 5), (1, 6), (2, 5), (2, 6)]\n``` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L986-L989","name":"List.product_eq_productTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.product_eq_productTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L983-L984","name":"List.productTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.productTR","doc":"Optimized version of `product`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L980-L980","name":"List.product","kind":"def","docLink":"./Std/Data/List/Basic.html#List.product","doc":"`product l₁ l₂` is the list of pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂`.\n```\nproduct [1, 2] [5, 6] = [(1, 5), (1, 6), (2, 5), (2, 6)]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L972-L972","name":"List.revzip","kind":"def","docLink":"./Std/Data/List/Basic.html#List.revzip","doc":"`revzip l` returns a list of pairs of the elements of `l` paired\nwith the elements of `l` in reverse order.\n```\nrevzip [1, 2, 3, 4, 5] = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L961-L963","name":"List.extractP.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.extractP.go","doc":"Auxiliary for `extractP`:\n`extractP.go p l xs acc = (some a, acc.toList ++ out)` if `extractP p xs = (some a, out)`,\nand `extractP.go p l xs acc = (none, l)` if `extractP p xs = (none, _)`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L957-L963","name":"List.extractP","kind":"def","docLink":"./Std/Data/List/Basic.html#List.extractP","doc":"`extractP p l` returns a pair of an element `a` of `l` satisfying the predicate\n`p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L945-L950","name":"List.eraseP_eq_erasePTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.eraseP_eq_erasePTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L943-L951","name":"List.eraseP_eq_erasePTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.eraseP_eq_erasePTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L939-L941","name":"List.erasePTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.erasePTR.go","doc":"Auxiliary for `erasePTR`: `erasePTR.go p l xs acc = acc.toList ++ eraseP p xs`,\nunless `xs` does not contain any elements satisfying `p`, where it returns `l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L936-L941","name":"List.erasePTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.erasePTR","doc":"Tail-recursive version of `eraseP`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L931-L933","name":"List.eraseP","kind":"def","docLink":"./Std/Data/List/Basic.html#List.eraseP","doc":"`eraseP p l` removes the first element of `l` satisfying the predicate `p`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L922-L928","name":"List.sections_eq_sectionsTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.sections_eq_sectionsTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L915-L920","name":"List.sections_eq_nil_of_isEmpty","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.sections_eq_nil_of_isEmpty","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L910-L913","name":"List.sectionsTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.sectionsTR.go","doc":"`go : List α → Array (List α) → Array (List α)` inserts one list into the accumulated\nlist of sections `acc`: `go [a, b] #[l₁, l₂] = [a::l₁, b::l₁, a::l₂, b::l₂]`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L905-L913","name":"List.sectionsTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.sectionsTR","doc":"Optimized version of `sections`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L900-L902","name":"List.sections","kind":"def","docLink":"./Std/Data/List/Basic.html#List.sections","doc":"List of all sections through a list of lists. A section\nof `[L₁, L₂, ..., Lₙ]` is a list whose first element comes from\n`L₁`, whose second element comes from `L₂`, and so on.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L891-L893","name":"List.transpose.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.transpose.go","doc":"`go : List α → Array (List α) → Array (List α)` handles the insertion of\na new list into all the lists in the array:\n`go [a, b, c] #[l₁, l₂, l₃] = #[a::l₁, b::l₂, c::l₃]`.\nIf the new list is too short, the later lists are unchanged, and if it is too long\nthe array is extended:\n```\ngo [a] #[l₁, l₂, l₃] = #[a::l₁, l₂, l₃]\ngo [a, b, c, d] #[l₁, l₂, l₃] = #[a::l₁, b::l₂, c::l₃, [d]]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L877-L879","name":"List.transpose.pop","kind":"def","docLink":"./Std/Data/List/Basic.html#List.transpose.pop","doc":"`pop : List α → StateM (List α) (List α)` transforms the input list `old`\nby taking the head of the current state and pushing it on the head of `old`.\nIf the state list is empty, then `old` is left unchanged. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L873-L893","name":"List.transpose","kind":"def","docLink":"./Std/Data/List/Basic.html#List.transpose","doc":"Transpose of a list of lists, treated as a matrix.\n```\ntranspose [[1, 2], [3, 4], [5, 6]] = [[1, 3, 5], [2, 4, 6]]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L859-L861","name":"List.Forall₂.cons","kind":"ctor","docLink":"./Std/Data/List/Basic.html#List.Forall₂.cons","doc":"Two cons lists are related by `Forall₂ R`\nif the heads are related by `R` and the tails are related by `Forall₂ R` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L857-L858","name":"List.Forall₂.nil","kind":"ctor","docLink":"./Std/Data/List/Basic.html#List.Forall₂.nil","doc":"Two nil lists are `Forall₂`-related "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L856-L861","name":"List.Forall₂","kind":"inductive","docLink":"./Std/Data/List/Basic.html#List.Forall₂","doc":"`Forall₂ R l₁ l₂` means that `l₁` and `l₂` have the same length,\nand whenever `a` is the nth element of `l₁`, and `b` is the nth element of `l₂`,\nthen `R a b` is satisfied.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L842-L845","name":"List.sublists","kind":"def","docLink":"./Std/Data/List/Basic.html#List.sublists","doc":"`sublists l` is the list of all (non-contiguous) sublists of `l`; cf. `sublists'`\nfor a different ordering.\n```\nsublists [1, 2, 3] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L831-L833","name":"List.sublists'","kind":"def","docLink":"./Std/Data/List/Basic.html#List.sublists'","doc":"`sublists' l` is the list of all (non-contiguous) sublists of `l`.\nIt differs from `sublists` only in the order of appearance of the sublists;\n`sublists'` uses the first element of the list as the MSB,\n`sublists` uses the first element of the list as the LSB.\n```\nsublists' [1, 2, 3] = [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L816-L820","name":"List.tails_eq_tailsTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.tails_eq_tailsTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L811-L814","name":"List.tailsTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.tailsTR.go","doc":"Auxiliary for `tailsTR`: `tailsTR.go l acc = acc.toList ++ tails l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L809-L814","name":"List.tailsTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.tailsTR","doc":"Tail-recursive version of `tails`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L804-L806","name":"List.tails","kind":"def","docLink":"./Std/Data/List/Basic.html#List.tails","doc":"`tails l` is the list of terminal segments of `l`.\n```\ntails [1, 2, 3] = [[1, 2, 3], [2, 3], [3], []]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L795-L796","name":"List.inits_eq_initsTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.inits_eq_initsTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L792-L793","name":"List.initsTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.initsTR","doc":"Tail-recursive version of `inits`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L787-L789","name":"List.inits","kind":"def","docLink":"./Std/Data/List/Basic.html#List.inits","doc":"`inits l` is the list of initial segments of `l`.\n```\ninits [1, 2, 3] = [[], [1], [1, 2], [1, 2, 3]]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L779-L779","name":"List.«term_<:+:_»","kind":"def","docLink":"./Std/Data/List/Basic.html#List.«term_<:+:_»","doc":"`isInfix l₁ l₂`, or `l₁ <:+: l₂`, means that `l₁` is a contiguous\nsubstring of `l₂`, that is, `l₂` has the form `s ++ l₁ ++ t` for some `s, t`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L777-L777","name":"List.«term_<:+_»","kind":"def","docLink":"./Std/Data/List/Basic.html#List.«term_<:+_»","doc":"`isSuffix l₁ l₂`, or `l₁ <:+ l₂`, means that `l₁` is a suffix of `l₂`,\nthat is, `l₂` has the form `t ++ l₁` for some `t`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L775-L775","name":"List.«term_<+:_»","kind":"def","docLink":"./Std/Data/List/Basic.html#List.«term_<+:_»","doc":"`isPrefix l₁ l₂`, or `l₁ <+: l₂`, means that `l₁` is a prefix of `l₂`,\nthat is, `l₂` has the form `l₁ ++ t` for some `t`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L773-L773","name":"List.isInfix","kind":"def","docLink":"./Std/Data/List/Basic.html#List.isInfix","doc":"`isInfix l₁ l₂`, or `l₁ <:+: l₂`, means that `l₁` is a contiguous\nsubstring of `l₂`, that is, `l₂` has the form `s ++ l₁ ++ t` for some `s, t`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L767-L767","name":"List.isSuffix","kind":"def","docLink":"./Std/Data/List/Basic.html#List.isSuffix","doc":"`isSuffix l₁ l₂`, or `l₁ <:+ l₂`, means that `l₁` is a suffix of `l₂`,\nthat is, `l₂` has the form `t ++ l₁` for some `t`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L761-L761","name":"List.isPrefix","kind":"def","docLink":"./Std/Data/List/Basic.html#List.isPrefix","doc":"`isPrefix l₁ l₂`, or `l₁ <+: l₂`, means that `l₁` is a prefix of `l₂`,\nthat is, `l₂` has the form `l₁ ++ t` for some `t`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L755-L755","name":"List.count","kind":"def","docLink":"./Std/Data/List/Basic.html#List.count","doc":"`count a l` is the number of occurrences of `a` in `l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L750-L752","name":"List.countp.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.countp.go","doc":"Auxiliary for `countp`: `countp.go p l acc = countp p l + acc`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L748-L752","name":"List.countp","kind":"def","docLink":"./Std/Data/List/Basic.html#List.countp","doc":"`countp p l` is the number of elements of `l` that satisfy `p`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L741-L745","name":"List.lookmap.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.lookmap.go","doc":"Auxiliary for `lookmap`: `lookmap.go f l acc = acc.toList ++ lookmap f l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L739-L745","name":"List.lookmap","kind":"def","docLink":"./Std/Data/List/Basic.html#List.lookmap","doc":"`lookmap` is a combination of `lookup` and `filterMap`.\n`lookmap f l` will apply `f : α → Option α` to each element of the list,\nreplacing `a → b` at the first value `a` in the list such that `f a = some b`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L731-L732","name":"List.attach","kind":"def","docLink":"./Std/Data/List/Basic.html#List.attach","doc":"\"Attach\" the proof that the elements of `l` are in `l` to produce a new list\nwith the same elements but in the type `{x // x ∈ l}`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L725-L727","name":"List.pmap","kind":"def","docLink":"./Std/Data/List/Basic.html#List.pmap","doc":"Partial map. If `f : Π a, p a → β` is a partial function defined on\n`a : α` satisfying `p`, then `pmap f l h` is essentially the same as `map f l`\nbut is defined only when all members of `l` satisfy `p`, using the proof\nto apply `f`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L719-L719","name":"List.indexOf?","kind":"def","docLink":"./Std/Data/List/Basic.html#List.indexOf?","doc":"Return the index of the first occurrence of `a` in the list. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L714-L716","name":"List.findIdx?","kind":"def","docLink":"./Std/Data/List/Basic.html#List.findIdx?","doc":"Return the index of the first occurrence of an element satisfying `p`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L711-L711","name":"List.indexesOf","kind":"def","docLink":"./Std/Data/List/Basic.html#List.indexesOf","doc":"`indexesOf a l` is the list of all indexes of `a` in `l`. For example:\n```\nindexesOf a [a, b, a, a] = [0, 2, 3]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L702-L703","name":"List.indexesValues","kind":"def","docLink":"./Std/Data/List/Basic.html#List.indexesValues","doc":"Returns the elements of `l` that satisfy `p` together with their indexes in\n`l`. The returned list is ordered by index.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L695-L696","name":"List.findIdxs","kind":"def","docLink":"./Std/Data/List/Basic.html#List.findIdxs","doc":"`findIdxs p l` is the list of indexes of elements of `l` that satisfy `p`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L689-L692","name":"List.foldrIdx","kind":"def","docLink":"./Std/Data/List/Basic.html#List.foldrIdx","doc":"Fold a list from right to left as with `foldr`, but the combining function\nalso receives each element's index.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L680-L682","name":"List.foldlIdx","kind":"def","docLink":"./Std/Data/List/Basic.html#List.foldlIdx","doc":"Fold a list from left to right as with `foldl`, but the combining function\nalso receives each element's index.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L669-L674","name":"List.partitionMap.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.partitionMap.go","doc":"Auxiliary for `partitionMap`:\n`partitionMap.go f l acc₁ acc₂ = (acc₁.toList ++ left, acc₂.toList ++ right)`\nif `partitionMap f l = (left, right)`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L665-L674","name":"List.partitionMap","kind":"def","docLink":"./Std/Data/List/Basic.html#List.partitionMap","doc":"Given a function `f : α → β ⊕ γ`, `partitionMap f l` maps the list by `f`\nwhilst partitioning the result it into a pair of lists, `List β × List γ`,\npartitioning the `.inl _` into the left list, and the `.inr _` into the right List.\n```\npartitionMap (id : Nat ⊕ Nat → Nat ⊕ Nat) [inl 0, inr 1, inl 2] = ([0, 2], [1])\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L653-L655","name":"List.scanr","kind":"def","docLink":"./Std/Data/List/Basic.html#List.scanr","doc":"Fold a function `f` over the list from the right, returning the list of partial results.\n```\nscanr (+) 0 [1, 2, 3] = [6, 5, 3, 0]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L644-L645","name":"List.scanl_eq_scanlTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.scanl_eq_scanlTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L640-L642","name":"List.scanlTR_go_eq","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.scanlTR_go_eq","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L636-L638","name":"List.scanlTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.scanlTR.go","doc":"Auxiliary for `scanlTR`: `scanlTR.go f l a acc = acc.toList ++ scanl f a l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L634-L638","name":"List.scanlTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.scanlTR","doc":"Tail-recursive version of `scanl`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L629-L631","name":"List.scanl","kind":"def","docLink":"./Std/Data/List/Basic.html#List.scanl","doc":"Fold a function `f` over the list from the left, returning the list of partial results.\n```\nscanl (+) 0 [1, 2, 3] = [0, 1, 3, 6]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L620-L621","name":"List.leftpad_eq_leftpadTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.leftpad_eq_leftpadTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L617-L618","name":"List.leftpadTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.leftpadTR","doc":"Optimized version of `leftpad`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L614-L614","name":"List.leftpad","kind":"def","docLink":"./Std/Data/List/Basic.html#List.leftpad","doc":"Pads `l : List α` with repeated occurrences of `a : α` until it is of length `n`.\nIf `l` is initially larger than `n`, just return `l`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L607-L608","name":"List.takeD_eq_takeDTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.takeD_eq_takeDTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L602-L605","name":"List.takeDTR_go_eq","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.takeDTR_go_eq","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L597-L600","name":"List.takeDTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeDTR.go","doc":"Auxiliary for `takeDTR`: `takeDTR.go dflt n l acc = acc.toList ++ takeD n l dflt`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L595-L600","name":"List.takeDTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeDTR","doc":"Tail-recursive version of `takeD`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L592-L592","name":"List.takeD_nil","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.takeD_nil","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L589-L590","name":"List.takeD_succ","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.takeD_succ","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L588-L588","name":"List.takeD_zero","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.takeD_zero","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L584-L586","name":"List.takeD","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeD","doc":"Take `n` elements from a list `l`. If `l` has less than `n` elements, append `n - length l`\nelements `x`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L578-L578","name":"List.headD_eq_head?","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.headD_eq_head?","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L575-L576","name":"List.insertNth_eq_insertNthTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.insertNth_eq_insertNthTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L571-L573","name":"List.insertNthTR_go_eq","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.insertNthTR_go_eq","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L566-L569","name":"List.insertNthTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.insertNthTR.go","doc":"Auxiliary for `insertNthTR`: `insertNthTR.go a n l acc = acc.toList ++ insertNth n a l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L564-L569","name":"List.insertNthTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.insertNthTR","doc":"Tail-recursive version of `insertNth`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L560-L561","name":"List.insertNth","kind":"def","docLink":"./Std/Data/List/Basic.html#List.insertNth","doc":"`insertNth n a l` inserts `a` into the list `l` after the first `n` elements of `l`\n```\ninsertNth 2 1 [1, 2, 3, 4] = [1, 2, 1, 3, 4]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L549-L552","name":"List.modifyLast.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.modifyLast.go","doc":"Auxiliary for `modifyLast`: `modifyLast.go f l acc = acc.toList ++ modifyLast f l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L547-L552","name":"List.modifyLast","kind":"def","docLink":"./Std/Data/List/Basic.html#List.modifyLast","doc":"Apply `f` to the last element of `l`, if it exists. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L543-L544","name":"List.modifyNth_eq_modifyNthTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.modifyNth_eq_modifyNthTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L538-L541","name":"List.modifyNthTR_go_eq","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.modifyNthTR_go_eq","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L533-L536","name":"List.modifyNthTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.modifyNthTR.go","doc":"Auxiliary for `modifyNthTR`: `modifyNthTR.go f l n acc = acc.toList ++ modifyNth f n l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L531-L536","name":"List.modifyNthTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.modifyNthTR","doc":"Tail-recursive version of `modifyNth`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L527-L528","name":"List.modifyNth","kind":"def","docLink":"./Std/Data/List/Basic.html#List.modifyNth","doc":"Apply `f` to the nth element of the list, if it exists. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L522-L524","name":"List.modifyHead","kind":"def","docLink":"./Std/Data/List/Basic.html#List.modifyHead","doc":"Apply `f` to the head of the list, if it exists. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L516-L519","name":"List.modifyNthTail","kind":"def","docLink":"./Std/Data/List/Basic.html#List.modifyNthTail","doc":"Apply a function to the nth tail of `l`. Returns the input without\nusing `f` if the index is larger than the length of the List.\n```\nmodifyNthTail f 2 [a, b, c] = [a, b] ++ f [c]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L507-L507","name":"List.splitOn","kind":"def","docLink":"./Std/Data/List/Basic.html#List.splitOn","doc":"Split a list at every occurrence of a separator element. The separators are not in the result.\n```\n[1, 1, 2, 3, 2, 4, 4].splitOn 2 = [[1, 1], [3], [4, 4]]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L494-L499","name":"List.splitOnP_eq_splitOnPTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.splitOnP_eq_splitOnPTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L490-L492","name":"List.splitOnPTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.splitOnPTR.go","doc":"Auxiliary for `splitOnP`: `splitOnP.go xs acc r = r.toList ++ res'`\nwhere `res'` is obtained from `splitOnP P xs` by prepending `acc.toList` to the first element. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L487-L492","name":"List.splitOnPTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.splitOnPTR","doc":"Tail recursive version of `removeNth`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L482-L484","name":"List.splitOnP.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.splitOnP.go","doc":"Auxiliary for `splitOnP`: `splitOnP.go xs acc = res'`\nwhere `res'` is obtained from `splitOnP P xs` by prepending `acc.reverse` to the first element. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L479-L484","name":"List.splitOnP","kind":"def","docLink":"./Std/Data/List/Basic.html#List.splitOnP","doc":"Split a list at every element satisfying a predicate. The separators are not in the result.\n```\n[1, 1, 2, 3, 2, 4, 4].splitOnP (· == 2) = [[1, 1], [3], [4, 4]]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L468-L471","name":"List.splitAtD.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.splitAtD.go","doc":"Auxiliary for `splitAtD`: `splitAtD.go dflt n l acc = (acc.toList ++ left, right)`\nif `splitAtD n l dflt = (left, right)`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L465-L471","name":"List.splitAtD","kind":"def","docLink":"./Std/Data/List/Basic.html#List.splitAtD","doc":"Split a list at an index. Ensures the left list always has the specified length\nby right padding with the provided default element.\n```\nsplitAtD 2 [a, b, c] x = ([a, b], [c])\nsplitAtD 4 [a, b, c] x = ([a, b, c, x], [])\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L452-L455","name":"List.splitAt.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.splitAt.go","doc":"Auxiliary for `splitAt`: `splitAt.go l n xs acc = (acc.toList ++ take n xs, drop n xs)`\nif `n < length xs`, else `(l, [])`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L449-L455","name":"List.splitAt","kind":"def","docLink":"./Std/Data/List/Basic.html#List.splitAt","doc":"Split a list at an index.\n```\nsplitAt 2 [a, b, c] = ([a, b], [c])\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L441-L441","name":"List.«term_<+_»","kind":"def","docLink":"./Std/Data/List/Basic.html#List.«term_<+_»","doc":"`l₁ <+ l₂`, or `Sublist l₁ l₂`, says that `l₁` is a (non-contiguous) subsequence of `l₂`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L438-L439","name":"List.Sublist.cons₂","kind":"ctor","docLink":"./Std/Data/List/Basic.html#List.Sublist.cons₂","doc":"If `l₁` is a subsequence of `l₂`, then `a :: l₁` is a subsequence of `a :: l₂`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L436-L437","name":"List.Sublist.cons","kind":"ctor","docLink":"./Std/Data/List/Basic.html#List.Sublist.cons","doc":"If `l₁` is a subsequence of `l₂`, then it is also a subsequence of `a :: l₂`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L434-L435","name":"List.Sublist.slnil","kind":"ctor","docLink":"./Std/Data/List/Basic.html#List.Sublist.slnil","doc":"the base case: `[]` is a sublist of `[]` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L433-L439","name":"List.Sublist","kind":"inductive","docLink":"./Std/Data/List/Basic.html#List.Sublist","doc":"`l₁ <+ l₂`, or `Sublist l₁ l₂`, says that `l₁` is a (non-contiguous) subsequence of `l₂`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L430-L430","name":"List.instInterList","kind":"instance","docLink":"./Std/Data/List/Basic.html#List.instInterList","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L428-L428","name":"List.inter","kind":"def","docLink":"./Std/Data/List/Basic.html#List.inter","doc":"Constructs the intersection of two lists, by filtering the elements of `l₁` that are in `l₂`.\nUnlike `bagInter` this does not preserve multiplicity: `[1, 1].inter [1]` is `[1, 1]`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L422-L422","name":"List.instUnionList","kind":"instance","docLink":"./Std/Data/List/Basic.html#List.instUnionList","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L420-L420","name":"List.union","kind":"def","docLink":"./Std/Data/List/Basic.html#List.union","doc":"Constructs the union of two lists, by inserting the elements of `l₁` in reverse order to `l₂`.\nAs a result, `l₂` will always be a suffix, but only the last occurrence of each element in `l₁`\nwill be retained (but order will otherwise be preserved).\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L412-L413","name":"List.insert","kind":"def","docLink":"./Std/Data/List/Basic.html#List.insert","doc":"Inserts an element into a list without duplication. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L404-L408","name":"List.replaceF_eq_replaceFTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.replaceF_eq_replaceFTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L402-L409","name":"List.replaceF_eq_replaceFTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.replaceF_eq_replaceFTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L396-L400","name":"List.replaceFTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.replaceFTR.go","doc":"Auxiliary for `replaceFTR`: `replaceFTR.go f xs acc = acc.toList ++ replaceF f xs`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L394-L400","name":"List.replaceFTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.replaceFTR","doc":"Tail-recursive version of `replaceF`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L387-L391","name":"List.replaceF","kind":"def","docLink":"./Std/Data/List/Basic.html#List.replaceF","doc":"Replaces the first element of the list for which `f` returns `some` with the returned value. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L375-L384","name":"List.removeNth_eq_removeNthTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.removeNth_eq_removeNthTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L370-L373","name":"List.removeNthTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.removeNthTR.go","doc":"Auxiliary for `removeNthTR`:\n`removeNthTR.go l xs n acc = acc.toList ++ removeNth xs n` if `n < length xs`, else `l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L367-L373","name":"List.removeNthTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.removeNthTR","doc":"Tail recursive version of `removeNth`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L361-L364","name":"List.removeNth","kind":"def","docLink":"./Std/Data/List/Basic.html#List.removeNth","doc":"Removes the `n`th element of `l`, or the original list if `n` is out of bounds. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L358-L358","name":"List.indexOf","kind":"def","docLink":"./Std/Data/List/Basic.html#List.indexOf","doc":"Returns the index of the first element equal to `a`, or the length of the list otherwise. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L353-L355","name":"List.findIdx.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.findIdx.go","doc":"Auxiliary for `findIdx`: `findIdx.go p l n = findIdx p l + n` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L351-L355","name":"List.findIdx","kind":"def","docLink":"./Std/Data/List/Basic.html#List.findIdx","doc":"Returns the index of the first element satisfying `p`, or the length of the list otherwise. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L346-L348","name":"List.after","kind":"def","docLink":"./Std/Data/List/Basic.html#List.after","doc":"`after p xs` is the suffix of `xs` after the first element that satisfies\n`p`, not including that element.\n```lean\nafter      (· == 1) [0, 1, 2, 3] = [2, 3]\ndrop_while (· != 1) [0, 1, 2, 3] = [1, 2, 3]\n```\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L334-L336","name":"List.mapIdxM.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.mapIdxM.go","doc":"Auxiliary for `mapIdxM`:\n`mapIdxM.go as f acc = acc.toList ++ [← f acc.size a₀, ← f (acc.size + 1) a₁, ...]` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L330-L336","name":"List.mapIdxM","kind":"def","docLink":"./Std/Data/List/Basic.html#List.mapIdxM","doc":"Monadic variant of `mapIdx`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L325-L327","name":"List.mapIdx.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.mapIdx.go","doc":"Auxiliary for `mapIdx`:\n`mapIdx.go [a₀, a₁, ...] acc = acc.toList ++ [f acc.size a₀, f (acc.size + 1) a₁, ...]` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L322-L327","name":"List.mapIdx","kind":"def","docLink":"./Std/Data/List/Basic.html#List.mapIdx","doc":"Given a function `f : Nat → α → β` and `as : list α`, `as = [a₀, a₁, ...]`, returns the list\n`[f 0 a₀, f 1 a₁, ...]`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L314-L316","name":"List.next?","kind":"def","docLink":"./Std/Data/List/Basic.html#List.next?","doc":"Get the head and tail of a list, if it is nonempty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L311-L311","name":"List.tail_cons","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.tail_cons","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L310-L310","name":"List.tail_nil","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.tail_nil","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L305-L307","name":"List.tail","kind":"def","docLink":"./Std/Data/List/Basic.html#List.tail","doc":"Get the tail of a nonempty list, or return `[]` for `[]`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L298-L300","name":"List.diff","kind":"def","docLink":"./Std/Data/List/Basic.html#List.diff","doc":"Computes the difference of `l₁` and `l₂`, by removing each element in `l₂` from `l₁`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L292-L295","name":"List.bagInter","kind":"def","docLink":"./Std/Data/List/Basic.html#List.bagInter","doc":"Computes the \"bag intersection\" of `l₁` and `l₂`, that is,\nthe collection of elements of `l₁` which are also in `l₂`. As each element\nis identified, it is removed from `l₂`, so elements are counted with multiplicity.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L275-L285","name":"List.decidableBAll","kind":"instance","docLink":"./Std/Data/List/Basic.html#List.decidableBAll","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L264-L273","name":"List.decidableBEx","kind":"instance","docLink":"./Std/Data/List/Basic.html#List.decidableBEx","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L262-L262","name":"List.instHasSubsetList","kind":"instance","docLink":"./Std/Data/List/Basic.html#List.instHasSubsetList","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L260-L260","name":"List.Subset","kind":"def","docLink":"./Std/Data/List/Basic.html#List.Subset","doc":"`l₁ ⊆ l₂` means that every element of `l₁` is also an element of `l₂`, ignoring multiplicity.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L249-L252","name":"List.intercalate_eq_intercalateTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.intercalate_eq_intercalateTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L243-L253","name":"List.intercalate_eq_intercalateTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.intercalate_eq_intercalateTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L239-L241","name":"List.intercalateTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.intercalateTR.go","doc":"Auxiliary for `intercalateTR`:\n`intercalateTR.go sep x xs acc = acc.toList ++ intercalate sep.toList (x::xs)` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L232-L241","name":"List.intercalateTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.intercalateTR","doc":"Tail recursive version of `intercalate`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L225-L229","name":"List.intersperse_eq_intersperseTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.intersperse_eq_intersperseTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L220-L223","name":"List.intersperseTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.intersperseTR","doc":"Tail recursive version of `intersperse`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L216-L217","name":"List.dropLast_eq_dropLastTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.dropLast_eq_dropLastTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L214-L214","name":"List.dropLastTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.dropLastTR","doc":"Tail recursive version of `dropLast`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L208-L211","name":"List.replicateTR_loop_eq","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.replicateTR_loop_eq","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L202-L205","name":"List.enumFrom_eq_enumFromTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.enumFrom_eq_enumFromTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L199-L206","name":"List.enumFrom_eq_enumFromTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.enumFrom_eq_enumFromTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L195-L197","name":"List.enumFromTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.enumFromTR","doc":"Tail recursive version of `enumFrom`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L191-L192","name":"List.unzip_eq_unzipTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.unzip_eq_unzipTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L188-L189","name":"List.unzipTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.unzipTR","doc":"Tail recursive version of `unzip`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L182-L184","name":"List.zipWith_eq_zipWithTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.zipWith_eq_zipWithTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L180-L185","name":"List.zipWith_eq_zipWithTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.zipWith_eq_zipWithTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L176-L178","name":"List.zipWithTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWithTR.go","doc":"Auxiliary for `zipWith`: `zipWith.go f as bs acc = acc.toList ++ zipWith f as bs` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L174-L178","name":"List.zipWithTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.zipWithTR","doc":"Tail recursive version of `zipWith`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L170-L171","name":"List.foldr_eq_foldrTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.foldr_eq_foldrTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L168-L168","name":"List.foldrTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.foldrTR","doc":"Tail recursive version of `foldr`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L156-L165","name":"List.takeWhile_eq_takeWhileTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.takeWhile_eq_takeWhileTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L152-L154","name":"List.takeWhileTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeWhileTR.go","doc":"Auxiliary for `takeWhile`: `takeWhile.go p l xs acc = acc.toList ++ takeWhile p xs`,\nunless no element satisfying `p` is found in `xs` in which case it returns `l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L149-L154","name":"List.takeWhileTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeWhileTR","doc":"Tail recursive version of `takeWhile`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L138-L146","name":"List.take_eq_takeTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.take_eq_takeTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L133-L136","name":"List.takeTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeTR.go","doc":"Auxiliary for `take`: `take.go l xs n acc = acc.toList ++ take n xs`,\nunless `n ≥ xs.length` in which case it returns `l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L130-L136","name":"List.takeTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.takeTR","doc":"Tail recursive version of `take`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L118-L127","name":"List.replace_eq_replaceTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.replace_eq_replaceTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L114-L116","name":"List.replaceTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.replaceTR.go","doc":"Auxiliary for `replace`: `replace.go l b c xs acc = acc.toList ++ replace xs b c`,\nunless `b` is not found in `xs` in which case it returns `l`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L111-L116","name":"List.replaceTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.replaceTR","doc":"Tail recursive version of `replace`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L105-L107","name":"List.filterMap_eq_filterMapTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.filterMap_eq_filterMapTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L103-L108","name":"List.filterMap_eq_filterMapTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.filterMap_eq_filterMapTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L97-L101","name":"List.filterMapTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.filterMapTR.go","doc":"Auxiliary for `filterMap`: `filterMap.go f l = acc.toList ++ filterMap f l` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L95-L101","name":"List.filterMapTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.filterMapTR","doc":"Tail recursive version of `filterMap`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L91-L92","name":"List.join_eq_joinTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.join_eq_joinTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L89-L89","name":"List.joinTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.joinTR","doc":"Tail recursive version of `join`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L83-L85","name":"List.bind_eq_bindTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.bind_eq_bindTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L81-L86","name":"List.bind_eq_bindTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.bind_eq_bindTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L77-L79","name":"List.bindTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.bindTR.go","doc":"Auxiliary for `bind`: `bind.go f as = acc.toList ++ bind f as` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L75-L79","name":"List.bindTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.bindTR","doc":"Tail recursive version of `bind`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L61-L72","name":"List.eraseIdx_eq_eraseIdxTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.eraseIdx_eq_eraseIdxTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L56-L59","name":"List.eraseIdxTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.eraseIdxTR.go","doc":"Auxiliary for `eraseIdxTR`: `eraseIdxTR.go l n xs acc = acc.toList ++ eraseIdx xs a`,\nunless `a` is not present in which case it returns `l` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L53-L59","name":"List.eraseIdxTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.eraseIdxTR","doc":"Tail recursive version of `eraseIdx`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L41-L50","name":"List.erase_eq_eraseTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.erase_eq_eraseTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L37-L39","name":"List.eraseTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.eraseTR.go","doc":"Auxiliary for `eraseTR`: `eraseTR.go l a xs acc = acc.toList ++ erase xs a`,\nunless `a` is not present in which case it returns `l` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L34-L39","name":"List.eraseTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.eraseTR","doc":"Tail recursive version of `erase`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L26-L30","name":"List.set_eq_setTR.go","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.set_eq_setTR.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L24-L31","name":"List.set_eq_setTR","kind":"theorem","docLink":"./Std/Data/List/Basic.html#List.set_eq_setTR","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L19-L22","name":"List.setTR.go","kind":"def","docLink":"./Std/Data/List/Basic.html#List.setTR.go","doc":"Auxiliary for `setTR`: `setTR.go l a xs n acc = acc.toList ++ set xs a`,\nunless `n ≥ l.length` in which case it returns `l` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/List/Basic.lean#L16-L22","name":"List.setTR","kind":"def","docLink":"./Std/Data/List/Basic.html#List.setTR","doc":"Tail recursive version of `erase`. "}]}