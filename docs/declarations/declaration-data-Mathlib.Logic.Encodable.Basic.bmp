{"name":"Mathlib.Logic.Encodable.Basic","instances":[{"typeNames":[],"name":"Encodable.countable","className":"Countable"},{"typeNames":["Nat"],"name":"Nat.encodable","className":"Encodable"},{"typeNames":[],"name":"IsEmpty.toEncodable","className":"Encodable"},{"typeNames":["PUnit"],"name":"PUnit.encodable","className":"Encodable"},{"typeNames":["Option"],"name":"Option.encodable","className":"Encodable"},{"typeNames":["Sum"],"name":"Sum.encodable","className":"Encodable"},{"typeNames":["Bool"],"name":"Bool.encodable","className":"Encodable"},{"typeNames":["_builtin_prop"],"name":"Prop.encodable","className":"Encodable"},{"typeNames":["Sigma"],"name":"Sigma.encodable","className":"Encodable"},{"typeNames":["Prod"],"name":"Encodable.Prod.encodable","className":"Encodable"},{"typeNames":["Subtype"],"name":"Subtype.encodable","className":"Encodable"},{"typeNames":["Fin"],"name":"Fin.encodable","className":"Encodable"},{"typeNames":["Int"],"name":"Int.encodable","className":"Encodable"},{"typeNames":["PNat"],"name":"PNat.encodable","className":"Encodable"},{"typeNames":["ULift"],"name":"ULift.encodable","className":"Encodable"},{"typeNames":["PLift"],"name":"PLift.encodable","className":"Encodable"},{"typeNames":["PNat"],"name":"instCountablePNat","className":"Countable"},{"typeNames":["Eq","ULower"],"name":"instDecidableEqULower","className":"Decidable"},{"typeNames":["ULower"],"name":"instEncodableULower","className":"Encodable"},{"typeNames":["ULower"],"name":"ULower.instInhabitedULower","className":"Inhabited"},{"typeNames":["Order.Preimage","Nat","FunLike.coe","Function.Embedding","EmbeddingLike.toFunLike","Function.instEmbeddingLikeEmbedding","Encodable.encode'","LE.le","instLENat"],"name":"Encodable.instIsTransPreimageNatCoeEmbeddingToFunLikeInstEmbeddingLikeEmbeddingEncode'LeInstLENat","className":"IsTrans"},{"typeNames":["Order.Preimage","Nat","FunLike.coe","Function.Embedding","EmbeddingLike.toFunLike","Function.instEmbeddingLikeEmbedding","Encodable.encode'","LE.le","instLENat"],"name":"Encodable.instIsAntisymmPreimageNatCoeEmbeddingToFunLikeInstEmbeddingLikeEmbeddingEncode'LeInstLENat","className":"IsAntisymm"},{"typeNames":["Order.Preimage","Nat","FunLike.coe","Function.Embedding","EmbeddingLike.toFunLike","Function.instEmbeddingLikeEmbedding","Encodable.encode'","LE.le","instLENat"],"name":"Encodable.instIsTotalPreimageNatCoeEmbeddingToFunLikeInstEmbeddingLikeEmbeddingEncode'LeInstLENat","className":"IsTotal"}],"imports":["Init","Mathlib.Logic.Equiv.Nat","Mathlib.Data.PNat.Basic","Mathlib.Order.Directed","Mathlib.Data.Countable.Defs","Mathlib.Order.RelIso.Basic","Mathlib.Data.Fin.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L690-L692","name":"encodableQuotient","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#encodableQuotient","doc":"The quotient of an encodable space by a decidable equivalence relation is encodable. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L685-L686","name":"Quotient.rep_spec","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Quotient.rep_spec","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L681-L682","name":"Quotient.rep","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Quotient.rep","doc":"Representative of an equivalence class. This is a computable version of `Quot.out` for a setoid\non an encodable type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L667-L668","name":"Directed.le_sequence","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Directed.le_sequence","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L663-L664","name":"Directed.sequence_mono","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Directed.sequence_mono","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L655-L658","name":"Directed.rel_sequence","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Directed.rel_sequence","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L646-L652","name":"Directed.sequence_mono_nat","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Directed.sequence_mono_nat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L637-L643","name":"Directed.sequence","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Directed.sequence","doc":"Given a `Directed r` function `f : α → β` defined on an encodable inhabited type,\nconstruct a noncomputable sequence such that `r (f (x n)) (f (x (n + 1)))`\nand `r (f a) (f (x (encode a + 1))`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L623-L624","name":"Encodable.instIsTotalPreimageNatCoeEmbeddingToFunLikeInstEmbeddingLikeEmbeddingEncode'LeInstLENat","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.instIsTotalPreimageNatCoeEmbeddingToFunLikeInstEmbeddingLikeEmbeddingEncode'LeInstLENat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L620-L621","name":"Encodable.instIsAntisymmPreimageNatCoeEmbeddingToFunLikeInstEmbeddingLikeEmbeddingEncode'LeInstLENat","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.instIsAntisymmPreimageNatCoeEmbeddingToFunLikeInstEmbeddingLikeEmbeddingEncode'LeInstLENat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L617-L618","name":"Encodable.instIsTransPreimageNatCoeEmbeddingToFunLikeInstEmbeddingLikeEmbeddingEncode'LeInstLENat","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.instIsTransPreimageNatCoeEmbeddingToFunLikeInstEmbeddingLikeEmbeddingEncode'LeInstLENat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L613-L614","name":"Encodable.encode'","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode'","doc":"The `encode` function, viewed as an embedding. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L604-L606","name":"Encodable.skolem","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.skolem","doc":"A constructive version of `Classical.skolem` for `Encodable` types. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L598-L600","name":"Encodable.axiom_of_choice","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.axiom_of_choice","doc":"A constructive version of `Classical.axiom_of_choice` for `Encodable` types. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L591-L592","name":"Encodable.choose_spec","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.choose_spec","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L587-L588","name":"Encodable.choose","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.choose","doc":"Constructive choice function for a decidable predicate over an encodable type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L578-L583","name":"Encodable.chooseX","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.chooseX","doc":"Constructive choice function for a decidable subtype of an encodable type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L544-L545","name":"ULower.ext","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULower.ext","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L539-L540","name":"ULower.down_eq_down","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULower.down_eq_down","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L534-L535","name":"ULower.up_eq_up","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULower.up_eq_up","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L529-L530","name":"ULower.up_down","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULower.up_down","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L524-L525","name":"ULower.down_up","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULower.down_up","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L519-L520","name":"ULower.up","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULower.up","doc":"Lifts an `a : ULower α` into `α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L515-L516","name":"ULower.instInhabitedULower","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULower.instInhabitedULower","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L511-L512","name":"ULower.down","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULower.down","doc":"Lowers an `a : α` into `ULower α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L504-L505","name":"ULower.equiv","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULower.equiv","doc":"The equivalence between the encodable type `α` and `ULower α : Type`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L494-L495","name":"instEncodableULower","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#instEncodableULower","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L491-L492","name":"instDecidableEqULower","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#instDecidableEqULower","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L487-L488","name":"ULower","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULower","doc":"`ULower α : Type` is an equivalent type in the lowest universe, given `Encodable α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L479-L479","name":"instCountablePNat","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#instCountablePNat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L475-L476","name":"nonempty_encodable","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#nonempty_encodable","doc":"See also `nonempty_fintype`, `nonempty_denumerable`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L468-L469","name":"Encodable.nonempty_encodable","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.nonempty_encodable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L461-L464","name":"Encodable.ofCountable","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.ofCountable","doc":"If `α` is countable, then it has a (non-canonical) `Encodable` structure. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L456-L457","name":"Encodable.ofInj","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.ofInj","doc":"If `β` is encodable and there is an injection `f : α → β`, then `α` is encodable as well. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L451-L452","name":"PLift.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#PLift.encodable","doc":"The lift of an encodable type is encodable. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L446-L447","name":"ULift.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#ULift.encodable","doc":"The lift of an encodable type is encodable "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L441-L442","name":"PNat.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#PNat.encodable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L437-L438","name":"Int.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Int.encodable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L433-L434","name":"Fin.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Fin.encodable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L428-L428","name":"Encodable.Subtype.encode_eq","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.Subtype.encode_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L424-L425","name":"Subtype.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Subtype.encodable","doc":"A decidable subtype of an encodable type is encodable. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L419-L420","name":"Encodable.decodeSubtype","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decodeSubtype","doc":"Explicit decoding function for a decidable subtype of an encodable type "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L412-L413","name":"Encodable.encodeSubtype","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encodeSubtype","doc":"Explicit encoding function for a decidable subtype of an encodable type "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L397-L398","name":"Encodable.encode_prod_val","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_prod_val","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L388-L393","name":"Encodable.decode_prod_val","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_prod_val","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L384-L385","name":"Encodable.Prod.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.Prod.encodable","doc":"If `α` and `β` are encodable, then so is their product. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L373-L374","name":"Encodable.encode_sigma_val","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_sigma_val","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L366-L369","name":"Encodable.decode_sigma_val","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_sigma_val","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L360-L362","name":"Sigma.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Sigma.encodable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L355-L357","name":"Encodable.decodeSigma","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decodeSigma","doc":"Explicit decoding function for `Sigma γ` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L350-L351","name":"Encodable.encodeSigma","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encodeSigma","doc":"Explicit encoding function for `Sigma γ` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L341-L342","name":"Prop.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Prop.encodable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L329-L338","name":"Encodable.decode_ge_two","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_ge_two","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L325-L326","name":"Encodable.decode_one","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_one","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L320-L321","name":"Encodable.decode_zero","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L315-L316","name":"Encodable.encode_false","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_false","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L310-L311","name":"Encodable.encode_true","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_true","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L305-L306","name":"Bool.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Bool.encodable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L299-L300","name":"Encodable.decode_sum_val","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_sum_val","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L294-L295","name":"Encodable.encode_inr","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_inr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L288-L289","name":"Encodable.encode_inl","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_inl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L282-L283","name":"Sum.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Sum.encodable","doc":"If `α` and `β` are encodable, then so is their sum. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L275-L278","name":"Encodable.decodeSum","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decodeSum","doc":"Explicit decoding function for the sum of two encodable types. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L269-L271","name":"Encodable.encodeSum","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encodeSum","doc":"Explicit encoding function for the sum of two encodable types. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L259-L260","name":"Unique.encodable","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Unique.encodable","doc":"A type with unique element is encodable. This is not an instance to avoid diamonds. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L242-L255","name":"Encodable.equivRangeEncode","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.equivRangeEncode","doc":"An encodable type is equivalent to the range of its encoding function. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L234-L238","name":"Encodable.decidableRangeEncode","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decidableRangeEncode","doc":"The encoding function has decidable range. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L229-L230","name":"Encodable.encodek₂","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encodek₂","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L224-L226","name":"Encodable.decode₂_inj","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode₂_inj","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L220-L221","name":"Encodable.decode₂_is_partial_inv","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode₂_is_partial_inv","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L214-L217","name":"Encodable.decode₂_ne_none_iff","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode₂_ne_none_iff","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L209-L211","name":"Encodable.decode₂_encode","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode₂_encode","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L204-L205","name":"Encodable.decode₂_eq_some","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode₂_eq_some","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L200-L201","name":"Encodable.mem_decode₂","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.mem_decode₂","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L195-L197","name":"Encodable.mem_decode₂'","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.mem_decode₂'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L191-L192","name":"Encodable.decode₂","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode₂","doc":"Failsafe variant of `decode`. `decode₂ α n` returns the preimage of `n` under `encode` if it\nexists, and returns `none` if it doesn't. This requirement could be imposed directly on `decode` but\nis not to help make the definition easier to use. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L183-L185","name":"Encodable.decode_option_succ","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_option_succ","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L178-L179","name":"Encodable.decode_option_zero","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_option_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L173-L174","name":"Encodable.encode_some","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_some","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L168-L169","name":"Encodable.encode_none","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_none","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L161-L164","name":"Option.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Option.encodable","doc":"If `α` is encodable, then so is `Option α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L156-L157","name":"Encodable.decode_unit_succ","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_unit_succ","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L151-L152","name":"Encodable.decode_unit_zero","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_unit_zero","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L146-L147","name":"Encodable.encode_star","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_star","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L141-L142","name":"PUnit.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#PUnit.encodable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L137-L138","name":"IsEmpty.toEncodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#IsEmpty.toEncodable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L133-L134","name":"Encodable.decode_nat","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_nat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L128-L129","name":"Encodable.encode_nat","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_nat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L123-L124","name":"Nat.encodable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Nat.encodable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L117-L120","name":"Encodable.decode_ofEquiv","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode_ofEquiv","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L111-L113","name":"Encodable.encode_ofEquiv","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_ofEquiv","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L106-L107","name":"Encodable.ofEquiv","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.ofEquiv","doc":"Encodability is preserved by equivalence. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L100-L102","name":"Encodable.ofLeftInverse","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.ofLeftInverse","doc":"If `α` is encodable and `f : β → α` is invertible, then `β` is encodable as well. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L93-L96","name":"Encodable.ofLeftInjection","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.ofLeftInjection","doc":"If `α` is encodable and there is an injection `f : β → α`, then `β` is encodable as well. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L88-L89","name":"Encodable.decidableEqOfEncodable","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decidableEqOfEncodable","doc":"An encodable type has decidable equality. Not set as an instance because this is usually not the\nbest way to infer decidability. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L81-L83","name":"Encodable.surjective_decode_iget","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.surjective_decode_iget","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L78-L79","name":"Encodable.countable","kind":"instance","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.countable","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L72-L73","name":"Encodable.encode_inj","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_inj","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L67-L68","name":"Encodable.encode_injective","kind":"theorem","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode_injective","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L56-L56","name":"Encodable.encodek","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encodek","doc":"Invariant relationship between encoding and decoding"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L54-L54","name":"Encodable.decode","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.decode","doc":"Decoding from ℕ to Option α"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L50-L50","name":"Encodable.encode","kind":"def","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.encode","doc":"Encoding from Type α to ℕ "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L48-L48","name":"Encodable.mk","kind":"ctor","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Logic/Encodable/Basic.lean#L48-L56","name":"Encodable","kind":"class","docLink":"./Mathlib/Logic/Encodable/Basic.html#Encodable","doc":"Constructively countable type. Made from an explicit injection `encode : α → ℕ` and a partial\ninverse `decode : ℕ → Option α`. Note that finite types *are* countable. See `Denumerable` if you\nwish to enforce infiniteness. "}]}