{"name":"Mathlib.Mathport.Notation","instances":[],"imports":["Init","Mathlib.Lean.Expr","Mathlib.Util.Syntax","Std.Data.Option.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L397-L560","name":"Mathlib.Notation3.«command___Notation3______=>_»","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.«command___Notation3______=>_»","doc":"`notation3` declares notation using Lean-3-style syntax.\n\nExamples:\n```\nnotation3 \"∀ᶠ \" (...) \" in \" f \", \" r:(scoped p => Filter.eventually p f) => r\nnotation3 \"MyList[\" (x\", \"* => foldr (a b => MyList.cons a b) MyList.nil) \"]\" => x\n```\nBy default notation is unable to mention any variables defined using `variable`, but\n`local notation3` is able to use such local variables.\n\nUse `notation3 (prettyPrint := false)` to keep the command from generating a pretty printer\nfor the notation.\n\nThis command can be used in mathlib4 but it has an uncertain future and was created primarily\nfor backward compatibility.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L389-L395","name":"Mathlib.Notation3.getPrettyPrintOpt","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.getPrettyPrintOpt","doc":"Interpret a `prettyPrintOpt`. The default value is `true`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L386-L386","name":"Mathlib.Notation3.prettyPrintOpt","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.prettyPrintOpt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L383-L384","name":"Mathlib.Notation3.BoundValueType.foldr","kind":"ctor","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.BoundValueType.foldr","doc":"A fold variable, use the fold state (do not reverse the array). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L381-L382","name":"Mathlib.Notation3.BoundValueType.foldl","kind":"ctor","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.BoundValueType.foldl","doc":"A fold variable, use the fold state (but reverse the array). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L379-L380","name":"Mathlib.Notation3.BoundValueType.normal","kind":"ctor","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.BoundValueType.normal","doc":"A normal variable, delaborate its expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L378-L384","name":"Mathlib.Notation3.BoundValueType","kind":"inductive","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.BoundValueType","doc":"Used when processing different kinds of variables when building the\nfinal delaborator. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L366-L374","name":"Mathlib.Notation3.mkNameFromSyntax","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.mkNameFromSyntax","doc":"Create a name that we can use for the `syntax` definition, using the\nalgorithm from `notation`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L353-L360","name":"Mathlib.Notation3.mkFoldrMatcher","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.mkFoldrMatcher","doc":"Create a `Term` that represents a matcher for `foldr` notation.\nReminder: `( lit \",\"* =>  foldr (x y => scopedTerm) init )` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L343-L349","name":"Mathlib.Notation3.mkFoldlMatcher","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.mkFoldlMatcher","doc":"Create a `Term` that represents a matcher for `foldl` notation.\nReminder: `( lit \",\"* =>  foldl (x y => scopedTerm) init )` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L321-L339","name":"Mathlib.Notation3.matchFoldl","kind":"opaque","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.matchFoldl","doc":"Matcher for expressions produced by `foldl`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L314-L318","name":"Mathlib.Notation3.mkScopedMatcher","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.mkScopedMatcher","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L304-L308","name":"Mathlib.Notation3.matchScoped'","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.matchScoped'","doc":"Like `matchScoped` but ensures that it matches at least one binder. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L273-L301","name":"Mathlib.Notation3.matchScoped","kind":"opaque","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.matchScoped","doc":"Matcher for processing `scoped` syntax. Assumes the expression to be matched\nagainst is in the `lit` variable.\n\nRuns `smatcher`, extracts the resulting `scopeId` variable, processes this value\n(which must be a lambda) to produce a binder, and loops.\n\nSucceeds even if it matches nothing, so it is up to the caller to decide if the\nempty scope state is ok. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L250-L263","name":"Mathlib.Notation3.mkExprMatcher.processFn","kind":"opaque","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.mkExprMatcher.processFn","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L226-L263","name":"Mathlib.Notation3.mkExprMatcher","kind":"opaque","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.mkExprMatcher","doc":"Returns a `Term` that represents a `Matcher` for the given pattern `stx`.\nThe `boundNames` set determines which identifiers are variables in the pattern.\nFails in the `OptionT` sense if it comes across something it's unable to handle.\n\nAlso returns constant names that could serve as a key for a delaborator.\nFor example, if it's for a function `f`, then `app.f`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L210-L218","name":"Mathlib.Notation3.fnArgMatcher","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.fnArgMatcher","doc":"A matcher that runs `matchf` for the function and the `matchers` for the associated\nargument indices. Fails if the function doesn't have exactly `arity` arguments. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L200-L206","name":"Mathlib.Notation3.getExplicitArgIndices.collectIdxs","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.getExplicitArgIndices.collectIdxs","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L187-L206","name":"Mathlib.Notation3.getExplicitArgIndices","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.getExplicitArgIndices","doc":"Given an identifier `f`, returns\n(1) the resolved constant (if it's not an fvar)\n(2) a Term for a matcher for the function\n(3) the arity\n(4) the positions at which the function takes an explicit argument "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L175-L180","name":"Mathlib.Notation3.natLitMatcher","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.natLitMatcher","doc":"Matches raw nat lits and `OfNat.ofNat` expressions. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L169-L172","name":"Mathlib.Notation3.matchFVar","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.matchFVar","doc":"Matcher for `Expr.fvar`. This is only used for `local notation3`.\nIt checks that the user name agrees, which isn't completely accurate, but probably sufficient. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L163-L165","name":"Mathlib.Notation3.matchConst","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.matchConst","doc":"Matcher for `Expr.const`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L155-L160","name":"Mathlib.Notation3.matchVar","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.matchVar","doc":"Matcher that assigns the current `SubExpr` into the match state;\nif a value already exists, then it checks for equality. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L149-L151","name":"Mathlib.Notation3.MatchState.pushFold","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.pushFold","doc":"Push a delaborated term onto a foldr/foldl array. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L145-L146","name":"Mathlib.Notation3.MatchState.getFoldArray","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.getFoldArray","doc":"Get the accumulated array of delaborated terms for a given foldr/foldl.\nReturns `#[]` if nothing has been pushed yet. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L136-L141","name":"Mathlib.Notation3.MatchState.pushBinder","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.pushBinder","doc":"Push a binder onto the binder array. For `scoped`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L132-L133","name":"Mathlib.Notation3.MatchState.captureSubexpr","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.captureSubexpr","doc":"Assign a variable to the current `SubExpr`, capturing the local context. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L124-L129","name":"Mathlib.Notation3.MatchState.delabVar","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.delabVar","doc":"Delaborate the given variable's value. Fails if the variable has no value.\nIf `checkNot` is provided, then checks that the expression being delaborated is not\nthe given one (this is used to prevent infinite loops). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L116-L119","name":"Mathlib.Notation3.MatchState.withVar","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.withVar","doc":"Evaluate `f` with the given variable's value as the `SubExpr` and within that subexpression's\nsaved context. Fails if the variable has no value. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L109-L112","name":"Mathlib.Notation3.MatchState.empty","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.empty","doc":"The initial state. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L105-L106","name":"Mathlib.Notation3.Matcher","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.Matcher","doc":"A matcher is a delaboration function that transforms `MatchState`s. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L102-L102","name":"Mathlib.Notation3.MatchState.foldState","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.foldState","doc":"The arrays of delaborated `Term`s accumulated while matching\n`foldl` and `foldr` expressions. For `foldl`, the arrays are stored in reverse order. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L99-L99","name":"Mathlib.Notation3.MatchState.scopeState","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.scopeState","doc":"The binders accumulated when matching a `scoped` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L97-L97","name":"Mathlib.Notation3.MatchState.vars","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.vars","doc":"This stores the assignments of variables to subexpressions (and their contexts)\nthat have been found so far during the course of the matching algorithm.\nWe store the contexts since we need to delaborate expressions after we leave\nscoping constructs. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L92-L102","name":"Mathlib.Notation3.MatchState","kind":"structure","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState","doc":"The dynamic state of a `Matcher`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L76-L79","name":"Mathlib.Notation3.notation3Item","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.notation3Item","doc":"`notation3` argument. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L73-L75","name":"Mathlib.Notation3.identOptScoped","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.identOptScoped","doc":"`notation3` argument binding a name. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L70-L72","name":"Mathlib.Notation3.foldAction","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.foldAction","doc":"`notation3` argument simulating a Lean 3 fold notation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L68-L69","name":"Mathlib.Notation3.bindersItem","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.bindersItem","doc":"`notation3` argument matching `extBinders`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L66-L67","name":"Mathlib.Notation3.foldKind","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.foldKind","doc":"Keywording indicating whether to use a left- or right-fold. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L60-L64","name":"Mathlib.Notation3.expandFoldr","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.expandFoldr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L55-L59","name":"Mathlib.Notation3.expandFoldl","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.expandFoldl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L25-L32","name":"Mathlib.Notation3.«termExpand_binders%(_=>_)_,_»","kind":"def","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.«termExpand_binders%(_=>_)_,_»","doc":"Expands binders into nested combinators.\nFor example, the familiar exists is given by:\n`expand_binders% (p => Exists p) x y : Nat, x < y`\nwhich expands to the same expression as\n`∃ x y : Nat, x < y`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Mathport/Notation.lean#L1-L1","name":"Mathlib.Notation3.MatchState.mk","kind":"ctor","docLink":"./Mathlib/Mathport/Notation.html#Mathlib.Notation3.MatchState.mk","doc":""}]}