{"name":"Mathlib.Data.ByteArray","instances":[{"typeNames":["ByteSlice","UInt8"],"name":"ByteSlice.instForInByteSliceUInt8","className":"ForIn"},{"typeNames":["ByteSlice"],"name":"instToStringByteSlice","className":"ToString"}],"imports":["Init","Mathlib.Data.Nat.Basic","Mathlib.Data.Char","Mathlib.Data.UInt"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L93-L97","name":"instToStringByteSlice","kind":"instance","docLink":"./Mathlib/Data/ByteArray.html#instToStringByteSlice","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L88-L91","name":"ByteSlice.toString","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.toString","doc":"Convert a byte slice into a string. This does not handle non-ASCII characters correctly:\nevery byte will become a unicode character with codepoint < 256. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L76-L82","name":"String.toAsciiByteArray.loop","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#String.toAsciiByteArray.loop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L75-L84","name":"String.toAsciiByteArray","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#String.toAsciiByteArray","doc":"Convert a string of assumed-ASCII characters into a byte array.\n(If any characters are non-ASCII they will be reduced modulo 256.) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L71-L71","name":"ByteArray.toSlice","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteArray.toSlice","doc":"Convert a byte array into a byte slice. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L67-L68","name":"ByteSliceT.toSlice","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.toSlice","doc":"Convert a terminal byte slice into a regular byte slice. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L61-L62","name":"ByteSlice.instForInByteSliceUInt8","kind":"instance","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.instForInByteSliceUInt8","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L52-L59","name":"ByteSlice.forIn.loop","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.forIn.loop","doc":"The inner loop of the `forIn` implementation for byte slices. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L48-L48","name":"ByteSlice.getOp","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.getOp","doc":"Index into a byte slice. The `getOp` function allows the use of the `buf[i]` notation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L44-L45","name":"ByteSlice.toArray","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.toArray","doc":"Convert a byte slice into an array, by copying the data if necessary. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L39-L39","name":"ByteSlice.len","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.len","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L39-L39","name":"ByteSlice.off","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.off","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L39-L39","name":"ByteSlice.arr","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.arr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L39-L39","name":"ByteSlice","kind":"structure","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice","doc":"A byte slice, given by a backing byte array, and an offset and length. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L36-L36","name":"ByteArray.toSliceT","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteArray.toSliceT","doc":"Convert a byte array into a terminal slice. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L31-L31","name":"ByteSliceT.getOp","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.getOp","doc":"Index into a byte slice. The `getOp` function allows the use of the `buf[i]` notation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L28-L28","name":"ByteSliceT.size","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.size","doc":"The number of elements in the byte slice. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L23-L23","name":"ByteSliceT.off","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.off","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L23-L23","name":"ByteSliceT.arr","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.arr","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L23-L23","name":"ByteSliceT","kind":"structure","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT","doc":"A terminal byte slice, a suffix of a byte array. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L18-L18","name":"Nat.upRel","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#Nat.upRel","doc":"A well-ordered relation for \"upwards\" induction on the natural numbers up to some bound `ub`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L14-L15","name":"Nat.Up.WF","kind":"theorem","docLink":"./Mathlib/Data/ByteArray.html#Nat.Up.WF","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L12-L12","name":"Nat.Up.next","kind":"theorem","docLink":"./Mathlib/Data/ByteArray.html#Nat.Up.next","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L10-L10","name":"Nat.Up","kind":"def","docLink":"./Mathlib/Data/ByteArray.html#Nat.Up","doc":"A well-ordered relation for \"upwards\" induction on the natural numbers up to some bound `ub`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L1-L1","name":"ByteSlice.mk","kind":"ctor","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Data/ByteArray.lean#L1-L1","name":"ByteSliceT.mk","kind":"ctor","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.mk","doc":""}]}