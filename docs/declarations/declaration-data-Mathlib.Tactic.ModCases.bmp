{"name":"Mathlib.Tactic.ModCases","instances":[],"imports":["Init","Mathlib.Data.Int.ModEq"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ModCases.lean#L71-L79","name":"Mathlib.Tactic.ModCases.«tacticMod_cases_:_%_»","kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.«tacticMod_cases_:_%_»","doc":"* The tactic `mod_cases h : e % 3` will perform a case disjunction on `e : ℤ` and yield subgoals\n  containing the assumptions `h : e ≡ 0 [ZMOD 3]`, `h : e ≡ 1 [ZMOD 3]`, `h : e ≡ 2 [ZMOD 3]`\n  respectively.\n* In general, `mod_cases h : e % n` works\n  when `n` is a positive numeral and `e` is an expression of type `ℤ`.\n* If `h` is omitted as in `mod_cases e % n`, it will be default-named `H`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ModCases.lean#L60-L69","name":"Mathlib.Tactic.ModCases.proveOnModCases","kind":"opaque","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.proveOnModCases","doc":"Proves an expression of the form `OnModCases n a b p` where `n` and `b` are raw nat literals\nand `b ≤ n`. Returns the list of subgoals `?gi : a ≡ i [ZMOD n] → p`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ModCases.lean#L51-L54","name":"Mathlib.Tactic.ModCases.onModCases_succ","kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.onModCases_succ","doc":"The successor case decomposes `∃ z, b ≤ z < n ∧ a ≡ z (mod n)` into\n`a ≡ b (mod n) ∨ ∃ z, b+1 ≤ z < n ∧ a ≡ z (mod n)`,\nand the `a ≡ b (mod n) → p` case becomes a subgoal.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ModCases.lean#L43-L44","name":"Mathlib.Tactic.ModCases.onModCases_stop","kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.onModCases_stop","doc":"The end point is that once we have reduced to `∃ z, n ≤ z < n ∧ a ≡ z (mod n)`\nthere are no more cases to consider.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ModCases.lean#L30-L37","name":"Mathlib.Tactic.ModCases.onModCases_start","kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.onModCases_start","doc":"The first theorem we apply says that `∃ z, 0 ≤ z < n ∧ a ≡ z (mod n)`.\nThe actual mathematical content of the proof is here.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ModCases.lean#L23-L24","name":"Mathlib.Tactic.ModCases.OnModCases","kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.OnModCases","doc":"`OnModCases n a lb p` represents a partial proof by cases that\nthere exists `0 ≤ z < n` such that `a ≡ z (mod n)`.\nIt asserts that if `∃ z, lb ≤ z < n ∧ a ≡ z (mod n)` holds, then `p`\n(where `p` is the current goal).\n"}]}