{"name":"Mathlib.Tactic.TFAE","instances":[],"imports":["Init","Mathlib.Util.AtomM","Mathlib.Data.List.TFAE"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L191-L196","name":"Mathlib.Tactic.TFAE.mkImplType","kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.mkImplType","doc":"Construct an expression for the type `Pj → Pi`, `Pi → Pj`, or `Pi ↔ Pj` given expressions\n`Pi Pj : Q(Prop)` and `impArrow` syntax `arr`, depending on whether `arr` is `←`, `→`, or `↔`\nrespectively. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L182-L186","name":"Mathlib.Tactic.TFAE.elabIndex","kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.elabIndex","doc":"Turn syntax for a given index into a natural number, as long as it lies between `1` and\n`maxIndex`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L167-L178","name":"Mathlib.Tactic.TFAE.tfaeHaveCore","kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeHaveCore","doc":"The core of `tfae_have`, which behaves like `haveLetCore` in `Mathlib.Tactic.Have`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L157-L163","name":"Mathlib.Tactic.TFAE.mkTFAEHypName","kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.mkTFAEHypName","doc":"Construct a name for a hypothesis introduced by `tfae_have`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L144-L152","name":"Mathlib.Tactic.TFAE.proveTFAE","kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveTFAE","doc":"Attempt to prove a statement of the form `TFAE [P₁, P₂, ...]`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L135-L141","name":"Mathlib.Tactic.TFAE.proveILast'Impl","kind":"opaque","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveILast'Impl","doc":"Attempt to prove `ilast' P' l → P` given an explicit list `l`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L124-L132","name":"Mathlib.Tactic.TFAE.proveChain","kind":"opaque","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveChain","doc":"Generate a proof of `Chain (· → ·) P l`. We assume `P : Prop` and `l : List Prop`, and that `l`\nis an explicit list. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L115-L120","name":"Mathlib.Tactic.TFAE.proveImpl","kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveImpl","doc":"Prove an implication via depth-first traversal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L102-L112","name":"Mathlib.Tactic.TFAE.dfs","kind":"opaque","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.dfs","doc":"Uses depth-first search to find a path from `P` to `P'`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L91-L95","name":"Mathlib.Tactic.TFAE.getTFAEList.getExplicitList","kind":"opaque","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.getTFAEList.getExplicitList","doc":"Convert an expression representing an explicit list into a list of expressions. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L83-L95","name":"Mathlib.Tactic.TFAE.getTFAEList","kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.getTFAEList","doc":"Extract a list of `Prop` expressions from an expression of the form `TFAE [P₁, P₂, ...]` as\nlong as `[P₁, P₂, ...]` is an explicit list. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L59-L77","name":"Mathlib.Tactic.TFAE.tfaeFinish","kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeFinish","doc":"`tfae_finish` is used to close goals of the form `TFAE [P₁, P₂, ...]` once a sufficient collection\nof hypotheses of the form `Pᵢ → Pⱼ` or `Pᵢ ↔ Pⱼ` have been introduced to the local context.\n\n`tfae_have` can be used to conveniently introduce these hypotheses; see `tfae_have`.\n\nExample:\n```lean\nexample : TFAE [P, Q, R] := by\n  tfae_have 1 → 2\n  · /- proof of P → Q -/\n  tfae_have 2 → 1\n  · /- proof of Q → P -/\n  tfae_have 2 ↔ 3\n  · /- proof of Q ↔ R -/\n  tfae_finish\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L23-L57","name":"Mathlib.Tactic.TFAE.tfaeHave","kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeHave","doc":"`tfae_have` introduces hypotheses for proving goals of the form `TFAE [P₁, P₂, ...]`. Specifically,\n`tfae_have i arrow j` introduces a hypothesis of type `Pᵢ arrow Pⱼ` to the local context,\nwhere `arrow` can be `→`, `←`, or `↔`. Note that `i` and `j` are natural number indices (beginning\nat 1) used to specify the propositions `P₁, P₂, ...` that appear in the `TFAE` goal list. A proof\nis required afterward, typically via a tactic block.\n\n```lean\nexample (h : P → R) : TFAE [P, Q, R] := by\n  tfae_have 1 → 3\n  · exact h\n  ...\n```\nThe resulting context now includes `tfae_1_to_3 : P → R`.\n\nThe introduced hypothesis can be given a custom name, in analogy to `have` syntax:\n```lean\ntfae_have h : 2 ↔ 3\n```\n\nOnce sufficient hypotheses have been introduced by `tfae_have`, `tfae_finish` can be used to close\nthe goal.\n\n```lean\nexample : TFAE [P, Q, R] := by\n  tfae_have 1 → 2\n  · /- proof of P → Q -/\n  tfae_have 2 → 1\n  · /- proof of Q → P -/\n  tfae_have 2 ↔ 3\n  · /- proof of Q ↔ R -/\n  tfae_finish\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/TFAE.lean#L20-L21","name":"Mathlib.Tactic.TFAE.impArrow","kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.impArrow","doc":"An arrow of the form `←`, `→`, or `↔`. "}]}