{"name":"Mathlib.Tactic.Linarith.Elimination","instances":[{"typeNames":["Linarith.CompSource"],"name":"Linarith.instInhabitedCompSource","className":"Inhabited"},{"typeNames":["Linarith.CompSource"],"name":"Linarith.instToFormatCompSource","className":"Std.ToFormat"},{"typeNames":["Linarith.PComp"],"name":"Linarith.instToFormatPComp","className":"Std.ToFormat"},{"typeNames":["Linarith.PComp"],"name":"Linarith.instToStringPComp","className":"ToString"}],"imports":["Init","Mathlib.Tactic.Linarith.Datatypes"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L333-L337","name":"Linarith.FourierMotzkin.produceCertificate","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.FourierMotzkin.produceCertificate","doc":"`produceCertificate hyps vars` tries to derive a contradiction from the comparisons in `hyps`\nby eliminating all variables ≤ `maxVar`.\nIf successful, it returns a map `coeff : ℕ → ℕ` as a certificate.\nThis map represents that we can find a contradiction by taking the sum  `∑ (coeff i) * hyps[i]`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L324-L325","name":"Linarith.mkLinarithData","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.mkLinarithData","doc":"`mkLinarithData hyps vars` takes a list of hypotheses and the largest variable present in\nthose hypotheses. It produces an initial state for the elimination monad.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L316-L318","name":"Linarith.elimAllVarsM","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.elimAllVarsM","doc":"`elimAllVarsM` eliminates all variables from the linarith state, leaving it with a set of\nground comparisons. If this succeeds without exception, the original `linarith` state is consistent.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L304-L310","name":"Linarith.elimVarM","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.elimVarM","doc":"`elimVarM a` performs one round of Fourier-Motzkin elimination, eliminating the variable `a`\nfrom the `linarith` state.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L292-L298","name":"Linarith.splitSetByVarSign","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.splitSetByVarSign","doc":"`splitSetByVarSign a comps` partitions the set `comps` into three parts.\n* `pos` contains the elements of `comps` in which `a` has a positive coefficient.\n* `neg` contains the elements of `comps` in which `a` has a negative coefficient.\n* `notPresent` contains the elements of `comps` in which `a` has coefficient 0.\n\nReturns `(pos, neg, notPresent)`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L280-L282","name":"Linarith.update","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.update","doc":"Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L271-L274","name":"Linarith.validate","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.validate","doc":"Throws an exception if a contradictory `PComp` is contained in the current state. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L267-L268","name":"Linarith.getPCompSet","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.getPCompSet","doc":"Return the current comparison set. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L263-L264","name":"Linarith.getMaxVar","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.getMaxVar","doc":"Returns the current max variable. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L259-L260","name":"Linarith.LinarithM","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.LinarithM","doc":"The linarith monad extends an exceptional monad with a `LinarithData` state.\nAn exception produces a contradictory `PComp`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L253-L253","name":"Linarith.LinarithData.comps","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.LinarithData.comps","doc":"The set of comparisons. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L251-L251","name":"Linarith.LinarithData.maxVar","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.LinarithData.maxVar","doc":"The largest variable index that has not been (officially) eliminated. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L249-L253","name":"Linarith.LinarithData","kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.LinarithData","doc":"The state for the elimination monad.\n* `maxVar`: the largest variable index that has not been eliminated.\n* `comps`: a set of comparisons\n\nThe elimination procedure proceeds by eliminating variable `v` from `comps` progressively\nin decreasing order.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L235-L239","name":"Linarith.elimWithSet","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.elimWithSet","doc":"`elimWithSet a p comps` collects the result of calling `pelimVar p p' a`\nfor every `p' ∈ comps`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L229-L229","name":"Linarith.PComp.isContr","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.isContr","doc":"A `PComp` represents a contradiction if its `Comp` field represents a contradiction.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L222-L224","name":"Linarith.pelimVar","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.pelimVar","doc":"`pelimVar p1 p2` calls `elimVar` on the `Comp` components of `p1` and `p2`.\nIf this returns `v1` and `v2`, it creates a new `PComp` equal to `v1*p1 + v2*p2`,\nand tracks this in the `CompSource`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L209-L215","name":"Linarith.elimVar","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.elimVar","doc":"If `c1` and `c2` both contain variable `a` with opposite coefficients,\nproduces `v1` and `v2` such that `a` has been cancelled in `v1*c1 + v2*c2`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L203-L203","name":"Linarith.PCompSet","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PCompSet","doc":"A collection of comparisons. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L199-L200","name":"Linarith.instToStringPComp","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.instToStringPComp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L196-L197","name":"Linarith.instToFormatPComp","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.instToFormatPComp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L188-L194","name":"Linarith.PComp.assump","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.assump","doc":"`PComp.assump c n` creates a `PComp` whose comparison is `c` and whose source is\n`CompSource.assump n`, that is, `c` is derived from the `n`th hypothesis.\nThe history is the singleton set `{n}`.\nNo variables have been eliminated (effectively or implicitly).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L173-L180","name":"Linarith.PComp.add","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.add","doc":"`PComp.add c1 c2 elimVar` creates the result of summing the linear comparisons `c1` and `c2`,\nduring the process of eliminating the variable `elimVar`.\nThe computation assumes, but does not enforce, that `elimVar` appears in both `c1` and `c2`\nand does not appear in the sum.\nComputing the sum of the two comparisons is easy; the complicated details lie in tracking the\nadditional fields of `PComp`.\n* The historical set `pcomp.history` of `c1 + c2` is the union of the two historical sets.\n* `vars` is the union of `c1.vars` and `c2.vars`.\n* The effectively eliminated variables of `c1 + c2` are the union of the two effective sets,\n  with `elim_var` inserted.\n* The implicitly eliminated variables of `c1 + c2` are those that appear in\n  `vars` but not `c.vars` or `effective`.\n(Note that the description of the implicitly eliminated variables of `c1 + c2` in the algorithm\ndescribed in Section 6 of https://doi.org/10.1016/B978-0-444-88771-9.50019-2 seems to be wrong:\nthat says it should be `(c1.implicit.union c2.implicit).sdiff explicit`.\nSince the implicitly eliminated sets start off empty for the assumption,\nthis formula would leave them always empty.)\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L151-L152","name":"Linarith.PComp.scale","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.scale","doc":"`PComp.scale c n` scales the coefficients of `c` by `n` and notes this in the `CompSource`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L148-L148","name":"Linarith.PComp.cmp","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.cmp","doc":"The `src : CompSource` field is ignored when comparing `PComp`s. Two `PComp`s proving the same\ncomparison, with different sources, are considered equivalent.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L141-L142","name":"Linarith.PComp.maybeMinimal","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.maybeMinimal","doc":"Any comparison whose history is not minimal is redundant,\nand need not be included in the new set of comparisons.\n`elimedGE : ℕ` is a natural number such that all variables with index ≥ `elimedGE` have been\nremoved from the system.\n\nThis test is an overapproximation to minimality. It gives necessary but not sufficient conditions.\nIf the history of `c` is minimal, then `c.maybeMinimal` is true,\nbut `c.maybeMinimal` may also be true for some `c` with non-minimal history.\nThus, if `c.maybeMinimal` is false, `c` is known not to be minimal and must be redundant.\nSee https://doi.org/10.1016/B978-0-444-88771-9.50019-2 (Theorem 13).\nThe condition described there considers only implicitly eliminated variables that have been\nofficially eliminated from the system. This is not the case for every implicitly eliminated\nvariable. Consider eliminating `z` from `{x + y + z < 0, x - y - z < 0}`. The result is the set\n`{2*x < 0}`; `y` is implicitly but not officially eliminated.\n\nThis implementation of Fourier-Motzkin elimination processes variables in decreasing order of\nindices. Immediately after a step that eliminates variable `k`, variable `k'` has been eliminated\niff `k' ≥ k`. Thus we can compute the intersection of officially and implicitly eliminated variables\nby taking the set of implicitly eliminated variables with indices ≥ `elimedGE`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L118-L118","name":"Linarith.PComp.vars","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.vars","doc":"The union of all variables appearing in those original assumptions\nwhich appear in the `history` set. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L115-L115","name":"Linarith.PComp.implicit","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.implicit","doc":"The variables which have been *implicitly eliminated*.\nThese are variables that appear in the historical set,\ndo not appear in `c` itself, and are not in `effective."},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L111-L111","name":"Linarith.PComp.effective","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.effective","doc":"The variables which have been *effectively eliminated*,\ni.e. the by running the elimination algorithm on that variable. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L108-L108","name":"Linarith.PComp.history","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.history","doc":"The set of original assumptions which have been used in constructing this comparison. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L106-L106","name":"Linarith.PComp.src","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.src","doc":"We track how the comparison was constructed by adding and scaling previous comparisons,\nback to the original assumptions. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L103-L103","name":"Linarith.PComp.c","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.c","doc":"The comparison `Σ cᵢ*xᵢ R 0`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L101-L118","name":"Linarith.PComp","kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp","doc":"A `PComp` stores a linear comparison `Σ cᵢ*xᵢ R 0`,\nalong with information about how this comparison was derived.\nThe original expressions fed into `linarith` are each assigned a unique natural number label.\nThe *historical set* `PComp.history` stores the labels of expressions\nthat were used in deriving the current `PComp`.\nVariables are also indexed by natural numbers. The sets `PComp.effective`, `PComp.implicit`,\nand `PComp.vars` contain variable indices.\n* `PComp.vars` contains the variables that appear in any inequality in the historical set.\n* `PComp.effective` contains the variables that have been effectively eliminated from `PComp`.\n  A variable `n` is said to be *effectively eliminated* in `p : PComp` if the elimination of `n`\n  produced at least one of the ancestors of `p` (or `p` itself).\n* `PComp.implicit` contains the variables that have been implicitly eliminated from `PComp`.\n  A variable `n` is said to be *implicitly eliminated* in `p` if it satisfies the following\n  properties:\n  - `n` appears in some inequality in the historical set (i.e. in `p.vars`).\n  - `n` does not appear in `p.c.vars` (i.e. it has been eliminated).\n  - `n` was not effectively eliminated.\n\nWe track these sets in order to compute whether the history of a `PComp` is *minimal*.\nChecking this directly is expensive, but effective approximations can be defined in terms of these\nsets. During the variable elimination process, a `PComp` with non-minimal history can be discarded.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L75-L76","name":"Linarith.instToFormatCompSource","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.instToFormatCompSource","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L70-L73","name":"Linarith.CompSource.toString","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.CompSource.toString","doc":"Formats a `CompSource` for printing. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L63-L67","name":"Linarith.CompSource.flatten","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.CompSource.flatten","doc":"Given a `CompSource` `cs`, `cs.flatten` maps an assumption index\nto the number of copies of that assumption that appear in the history of `cs`.\n\nFor example, suppose `cs` is produced by scaling assumption 2 by 5,\nand adding to that the sum of assumptions 1 and 2.\n`cs.flatten` maps `1 ↦ 1, 2 ↦ 6`.\n "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L53-L53","name":"Linarith.instInhabitedCompSource","kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.instInhabitedCompSource","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L52-L52","name":"Linarith.CompSource.scale","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.CompSource.scale","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L51-L51","name":"Linarith.CompSource.add","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.CompSource.add","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L50-L50","name":"Linarith.CompSource.assump","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.CompSource.assump","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L49-L53","name":"Linarith.CompSource","kind":"inductive","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.CompSource","doc":"`CompSource` tracks the source of a comparison.\nThe atomic source of a comparison is an assumption, indexed by a natural number.\nTwo comparisons can be added to produce a new comparison,\nand one comparison can be scaled by a natural number to produce a new comparison.\n "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L1-L1","name":"Linarith.LinarithData.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.LinarithData.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Elimination.lean#L1-L1","name":"Linarith.PComp.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Elimination.html#Linarith.PComp.mk","doc":""}]}