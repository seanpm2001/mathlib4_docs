{"name":"Mathlib.Tactic.ProjectionNotation","instances":[],"imports":["Init","Lean","Lean.Elab.AuxDef"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProjectionNotation.lean#L69-L151","name":"Mathlib.ProjectionNotation.commandPp_extended_field_notation_","kind":"def","docLink":"./Mathlib/Tactic/ProjectionNotation.html#Mathlib.ProjectionNotation.commandPp_extended_field_notation_","doc":"Defines an `app_unexpander` for the given function to support a basic form of projection\nnotation. It is *only* for functions whose first explicit argument is the receiver\nof the generalized field notation. That is to say, it is only meant for transforming\n`C.f c x y z ...` to `c.f x y z ...` for `c : C`.\n\nIt can be used to help get projection notation to work for function-valued structure fields,\nsince the default projection delaborator cannot handle excess arguments.\n\nExample for generalized field notation:\n```\nstructure A where\n  n : Nat\n\ndef A.foo (a : A) (m : Nat) : Nat := a.n + m\n\npp_extended_field_notation A.foo\n```\nNow, `A.foo x m` pretty prints as `x.foo m`. If `A` is a structure, it also adds a rule that\n`A.foo x.toA m` pretty prints as `x.foo m`. This rule is meant to combine with\nthe projection collapse delaborator, so that `A.foo x.toB.toA m` also will\npretty print as `x.foo m`.\n\nSince this last rule is a purely syntactic transformation,\nit might lead to output that does not round trip, though this can only occur if\nthere exists an `A`-valued `toA` function that is not a parent projection that\nhappens to be pretty printable using dot notation.\n\nHere is an example to illustrate the round tripping issue:\n```lean\nimport Mathlib.Tactic.ProjectionNotation\n\nstructure A where n : Int\n\ndef A.inc (a : A) (k : Int) : Int := a.n + k\n\npp_extended_field_notation A.inc\n\nstructure B where n : Nat\n\ndef B.toA (b : B) : A := ⟨b.n⟩\n\nvariable (b : B)\n\n#check A.inc b.toA 1\n-- (B.toA b).inc 1 : Int\n\npp_extended_field_notation B.toA\n#check A.inc b.toA 1\n-- b.inc 1 : Int\n\n#check b.inc 1\n-- invalid field 'inc', the environment does not contain 'B.inc'\n```\nTo avoid this, don't use `pp_extended_field_notation` for coercion functions\nsuch as `B.toA`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProjectionNotation.lean#L58-L63","name":"Mathlib.ProjectionNotation.delabProjectionApp'.walkUp","kind":"opaque","docLink":"./Mathlib/Tactic/ProjectionNotation.html#Mathlib.ProjectionNotation.delabProjectionApp'.walkUp","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProjectionNotation.lean#L42-L67","name":"Mathlib.ProjectionNotation.delabProjectionApp'","kind":"def","docLink":"./Mathlib/Tactic/ProjectionNotation.html#Mathlib.ProjectionNotation.delabProjectionApp'","doc":"Like the projection delaborator from core Lean, but collapses projections to parent\nstructures into a single projection.\n\nThe only functional difference from `Lean.PrettyPrinter.Delaborator.delabProjectionApp` is\nthe `walkUp` function. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProjectionNotation.lean#L33-L34","name":"Mathlib.ProjectionNotation.getPPCollapseStructureProjections","kind":"def","docLink":"./Mathlib/Tactic/ProjectionNotation.html#Mathlib.ProjectionNotation.getPPCollapseStructureProjections","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProjectionNotation.lean#L27-L31","name":"Mathlib.ProjectionNotation.pp.collapseStructureProjections","kind":"opaque","docLink":"./Mathlib/Tactic/ProjectionNotation.html#Mathlib.ProjectionNotation.pp.collapseStructureProjections","doc":""}]}