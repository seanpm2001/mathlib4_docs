{"name":"Std.Tactic.GuardExpr","instances":[],"imports":["Init","Lean.Elab.Command","Lean.Elab.Tactic.Conv.Basic","Lean.Meta.Basic","Lean.Meta.Eval","Std.Util.TermUnsafe"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L217-L241","name":"Std.Tactic.GuardExpr.«command#guard_»","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.«command#guard_»","doc":"Command to check that an expression evaluates to `true`.\n\n`#guard e` elaborates `e` ensuring its type is `Bool` then evaluates `e` and checks that\nthe result is `true`. The term is elaborated *without* variables declared using `variable`, since\nthese cannot be evaluated.\n\nSince this makes use of coercions, so long as a proposition `p` is decidable, one can write\n`#guard p` rather than `#guard decide p`. A consequence to this is that if there is decidable\nequality one can write `#guard a = b`. Note that this is not exactly the same as checking\nif `a` and `b` evaluate to the same thing since it uses the `DecidableEq` instance to do\nthe evaluation.\n\nNote: this uses the untrusted evaluator, so `#guard` passing is *not* a proof that the\nexpression equals `true`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L208-L215","name":"Std.Tactic.GuardExpr.evalGuardExprCmd","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardExprCmd","doc":"Command to check equality of two expressions.\n* `#guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `#guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `#guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `#guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nThis is a command version of the `guard_expr` tactic. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L197-L205","name":"Std.Tactic.GuardExpr.guardExprCmd","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardExprCmd","doc":"Command to check equality of two expressions.\n* `#guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `#guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `#guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `#guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nThis is a command version of the `guard_expr` tactic. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L172-L195","name":"Std.Tactic.GuardExpr.evalGuardHyp","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardHyp","doc":"Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L168-L169","name":"Std.Tactic.GuardExpr.guardHypConv","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardHypConv","doc":"Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L152-L167","name":"Std.Tactic.GuardExpr.guardHyp","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardHyp","doc":"Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L141-L150","name":"Std.Tactic.GuardExpr.evalGuardTarget","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardTarget","doc":"Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L138-L138","name":"Std.Tactic.GuardExpr.guardTargetConv","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardTargetConv","doc":"Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L127-L137","name":"Std.Tactic.GuardExpr.guardTarget","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardTarget","doc":"Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L118-L125","name":"Std.Tactic.GuardExpr.evalGuardExpr","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardExpr","doc":"Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L108-L115","name":"Std.Tactic.GuardExpr.elabAndEvalMatchKind","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.elabAndEvalMatchKind","doc":"Elaborate `a` and `b` and then do the given equality test `mk`. We make sure to unify\nthe types of `a` and `b` after elaboration so that when synthesizing pending metavariables\nwe don't get the wrong instances due to default instances (for example, for nat literals). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L103-L103","name":"Std.Tactic.GuardExpr.guardExprConv","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardExprConv","doc":"Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L91-L102","name":"Std.Tactic.GuardExpr.guardExpr","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardExpr","doc":"Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L86-L89","name":"Std.Tactic.GuardExpr.MatchKind.isEq","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.isEq","doc":"Applies the selected matching rule to two expressions. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L78-L83","name":"Std.Tactic.GuardExpr.equal.toMatchKind","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equal.toMatchKind","doc":"Converts a `equal` syntax into a `MatchKind` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L70-L75","name":"Std.Tactic.GuardExpr.colonEq.toMatchKind","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEq.toMatchKind","doc":"Converts a `colonEq` syntax into a `MatchKind` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L62-L67","name":"Std.Tactic.GuardExpr.colon.toMatchKind","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colon.toMatchKind","doc":"Converts a `colon` syntax into a `MatchKind` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L58-L59","name":"Std.Tactic.GuardExpr.equal","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equal","doc":"The `guard_expr` matching specifier, one of `=`, `=~`, `=ₛ`, `=ₐ` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L56-L57","name":"Std.Tactic.GuardExpr.equalA","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalA","doc":"Alpha-eq matching for `guard_expr` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L54-L55","name":"Std.Tactic.GuardExpr.equalS","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalS","doc":"Syntactic matching for `guard_expr` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L52-L53","name":"Std.Tactic.GuardExpr.equalD","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalD","doc":"Default-reducibility defeq matching for `guard_expr` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L50-L51","name":"Std.Tactic.GuardExpr.equalR","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalR","doc":"Reducible defeq matching for `guard_expr` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L47-L48","name":"Std.Tactic.GuardExpr.colonEq","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEq","doc":"The `guard_hyp` value specifier, one of `:=`, `:=~`, `:=ₛ`, `:=ₐ` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L45-L46","name":"Std.Tactic.GuardExpr.colonEqA","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqA","doc":"Alpha-eq matching for `guard_hyp` values "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L43-L44","name":"Std.Tactic.GuardExpr.colonEqS","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqS","doc":"Syntactic matching for `guard_hyp` values "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L41-L42","name":"Std.Tactic.GuardExpr.colonEqD","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqD","doc":"Default-reducibility defeq matching for `guard_hyp` values "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L39-L40","name":"Std.Tactic.GuardExpr.colonEqR","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqR","doc":"Reducible defeq matching for `guard_hyp` values "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L36-L37","name":"Std.Tactic.GuardExpr.colon","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colon","doc":"The `guard_hyp` type specifier, one of `:`, `:~`, `:ₛ`, `:ₐ` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L34-L35","name":"Std.Tactic.GuardExpr.colonA","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonA","doc":"Alpha-eq matching for `guard_hyp` types "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L32-L33","name":"Std.Tactic.GuardExpr.colonS","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonS","doc":"Syntactic matching for `guard_hyp` types "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L30-L31","name":"Std.Tactic.GuardExpr.colonD","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonD","doc":"Default-reducibility defeq matching for `guard_hyp` types "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L28-L29","name":"Std.Tactic.GuardExpr.colonR","kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonR","doc":"Reducible defeq matching for `guard_hyp` types "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L25-L26","name":"Std.Tactic.GuardExpr.MatchKind.alphaEq","kind":"ctor","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.alphaEq","doc":"An alpha-eq match means that `Expr.eqv` returns true. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L23-L24","name":"Std.Tactic.GuardExpr.MatchKind.defEq","kind":"ctor","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.defEq","doc":"A defeq match `isDefEqGuarded` returns true. (Note that unification is allowed here.) "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L21-L22","name":"Std.Tactic.GuardExpr.MatchKind.syntactic","kind":"ctor","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.syntactic","doc":"A syntactic match means that the `Expr`s are `==` after stripping `MData` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Tactic/GuardExpr.lean#L20-L26","name":"Std.Tactic.GuardExpr.MatchKind","kind":"inductive","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind","doc":"The various `guard_*` tactics have similar matching specifiers for how equal expressions\nhave to be to pass the tactic.\nThis inductive gives the different specifiers that can be selected.\n"}]}