{"name":"Std.Data.PairingHeap","instances":[{"typeNames":["Std.PairingHeapImp.Heap"],"name":"Std.PairingHeapImp.instReprHeap","className":"Repr"},{"typeNames":["Std.PairingHeapImp.Heap.NoSibling"],"name":"Std.PairingHeapImp.instDecidableNoSibling","className":"Decidable"},{"typeNames":["Std.PairingHeap"],"name":"Std.PairingHeap.instInhabitedPairingHeap","className":"Inhabited"}],"imports":["Init","Std.Classes.Order","Std.Logic"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L372-L372","name":"Std.PairingHeap.toArrayUnordered","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.toArrayUnordered","doc":"`O(n)`. Convert the heap to an array in arbitrary order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L369-L369","name":"Std.PairingHeap.toListUnordered","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.toListUnordered","doc":"`O(n)`. Convert the heap to a list in arbitrary order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L366-L366","name":"Std.PairingHeap.toArray","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.toArray","doc":"`O(n log n)`. Convert the heap to an array in increasing order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L363-L363","name":"Std.PairingHeap.toList","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.toList","doc":"`O(n log n)`. Convert the heap to a list in increasing order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L360-L360","name":"Std.PairingHeap.tail","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.tail","doc":"Amortized `O(log n)`. Removes the smallest element from the heap, if possible. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L354-L357","name":"Std.PairingHeap.tail?","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.tail?","doc":"Amortized `O(log n)`. Removes the smallest element from the heap, or `none` if the heap is empty.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L349-L349","name":"Std.PairingHeap.headI","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.headI","doc":"`O(1)`. Returns the smallest element in the heap, or `default` if the heap is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L346-L346","name":"Std.PairingHeap.head!","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.head!","doc":"`O(1)`. Returns the smallest element in the heap, or panics if the heap is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L343-L343","name":"Std.PairingHeap.head?","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.head?","doc":"`O(1)`. Returns the smallest element in the heap, or `none` if the heap is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L337-L340","name":"Std.PairingHeap.deleteMin","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.deleteMin","doc":"Amortized `O(log n)`. Remove and return the minimum element from the heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L333-L334","name":"Std.PairingHeap.ofArray","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.ofArray","doc":"`O(n log n)`. Construct a heap from a list by inserting all the elements. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L329-L330","name":"Std.PairingHeap.ofList","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.ofList","doc":"`O(n log n)`. Construct a heap from a list by inserting all the elements. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L325-L326","name":"Std.PairingHeap.insert","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.insert","doc":"`O(1)`. Add element `a` to the given heap `h`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L321-L322","name":"Std.PairingHeap.merge","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.merge","doc":"`O(1)`. Merge the contents of two heaps. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L317-L318","name":"Std.PairingHeap.singleton","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.singleton","doc":"`O(1)`. Make a new heap containing `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L314-L314","name":"Std.PairingHeap.size","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.size","doc":"`O(n)`. The number of elements in the heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L311-L311","name":"Std.PairingHeap.isEmpty","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.isEmpty","doc":"`O(1)`. Is the heap empty? "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L308-L308","name":"Std.PairingHeap.instInhabitedPairingHeap","kind":"instance","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.instInhabitedPairingHeap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L306-L306","name":"Std.PairingHeap.empty","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap.empty","doc":"`O(1)`. Make a new empty pairing heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L299-L300","name":"Std.mkPairingHeap","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.mkPairingHeap","doc":"`O(1)`. Make a new empty pairing heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L295-L296","name":"Std.PairingHeap","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeap","doc":"A [pairing heap](https://en.wikipedia.org/wiki/Pairing_heap) is a data structure which supports\nthe following primary operations:\n\n* `insert : α → PairingHeap α → PairingHeap α`: add an element to the heap\n* `deleteMin : PairingHeap α → Option (α × PairingHeap α)`:\n  remove the minimum element from the heap\n* `merge : PairingHeap α → PairingHeap α → PairingHeap α`: combine two heaps\n\nThe first two operations are known as a \"priority queue\", so this could be called\na \"mergeable priority queue\". The standard choice for a priority queue is a binary heap,\nwhich supports `insert` and `deleteMin` in `O(log n)`, but `merge` is `O(n)`.\nWith a `PairingHeap`, `insert` and `merge` are `O(1)`, `deleteMin` is amortized `O(log n)`.\n\nNote that `deleteMin` may be `O(n)` in a single operation. So if you need an efficient\npersistent priority queue, you should use other data structures with better worst-case time.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L269-L272","name":"Std.PairingHeapImp.Heap.deleteMin_fst","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.deleteMin_fst","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L263-L267","name":"Std.PairingHeapImp.Heap.WF.tail","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.WF.tail","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L257-L261","name":"Std.PairingHeapImp.Heap.WF.tail?","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.WF.tail?","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L253-L255","name":"Std.PairingHeapImp.Heap.WF.deleteMin","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.WF.deleteMin","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L247-L251","name":"Std.PairingHeapImp.Heap.WF.combine","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.WF.combine","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L239-L245","name":"Std.PairingHeapImp.Heap.WF.merge","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.WF.merge","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L232-L237","name":"Std.PairingHeapImp.Heap.WF.merge_node","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.WF.merge_node","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L230-L230","name":"Std.PairingHeapImp.Heap.WF.singleton","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.WF.singleton","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L227-L228","name":"Std.PairingHeapImp.Heap.WF.node","kind":"ctor","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.WF.node","doc":"There is exactly one tree and it is a `le`-min-heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L225-L226","name":"Std.PairingHeapImp.Heap.WF.nil","kind":"ctor","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.WF.nil","doc":"It is an empty heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L224-L228","name":"Std.PairingHeapImp.Heap.WF","kind":"inductive","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.WF","doc":"The well formedness predicate for a pairing heap.\nIt asserts that:\n* There is no more than one tree.\n* It is a `le`-min-heap (if `le` is well-behaved)\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L214-L216","name":"Std.PairingHeapImp.Heap.NodeWF","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.NodeWF","doc":"The well formedness predicate for a heap node.\nIt asserts that:\n* If `a` is added at the top to make the forest into a tree, the resulting tree\n  is a `le`-min-heap (if `le` is well-behaved)\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L205-L206","name":"Std.PairingHeapImp.Heap.toArrayUnordered","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.toArrayUnordered","doc":"`O(n)`. Convert the heap to an array in arbitrary order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L201-L202","name":"Std.PairingHeapImp.Heap.toListUnordered","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.toListUnordered","doc":"`O(n)`. Convert the heap to a list in arbitrary order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L197-L198","name":"Std.PairingHeapImp.Heap.foldTree","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.foldTree","doc":"`O(n)`. Fold a function over the tree structure to accumulate a value. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L192-L194","name":"Std.PairingHeapImp.Heap.foldTreeM","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.foldTreeM","doc":"`O(n)`. Fold a monadic function over the tree structure to accumulate a value. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L189-L189","name":"Std.PairingHeapImp.Heap.toList","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.toList","doc":"`O(n log n)`. Convert the heap to a list in increasing order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L186-L186","name":"Std.PairingHeapImp.Heap.toArray","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.toArray","doc":"`O(n log n)`. Convert the heap to an array in increasing order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L182-L183","name":"Std.PairingHeapImp.Heap.fold","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.fold","doc":"`O(n log n)`. Fold over the elements of a heap in increasing order,\nby repeatedly pulling the minimum element out of the heap.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L169-L176","name":"Std.PairingHeapImp.Heap.foldM","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.foldM","doc":"`O(n log n)`. Monadic fold over the elements of a heap in increasing order,\nby repeatedly pulling the minimum element out of the heap.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L159-L163","name":"Std.PairingHeapImp.Heap.size_tail?_lt","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.size_tail?_lt","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L155-L157","name":"Std.PairingHeapImp.Heap.size_deleteMin_lt","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.size_deleteMin_lt","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L149-L153","name":"Std.PairingHeapImp.Heap.size_tail","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.size_tail","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L143-L147","name":"Std.PairingHeapImp.Heap.size_tail?","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.size_tail?","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L139-L141","name":"Std.PairingHeapImp.Heap.size_deleteMin","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.size_deleteMin","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L130-L137","name":"Std.PairingHeapImp.Heap.size_combine","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.size_combine","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L124-L128","name":"Std.PairingHeapImp.Heap.size_merge","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.size_merge","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L120-L122","name":"Std.PairingHeapImp.Heap.size_merge_node","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.size_merge_node","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L114-L118","name":"Std.PairingHeapImp.Heap.noSibling_tail","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.noSibling_tail","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L108-L112","name":"Std.PairingHeapImp.Heap.noSibling_tail?","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.noSibling_tail?","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L104-L106","name":"Std.PairingHeapImp.Heap.noSibling_deleteMin","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.noSibling_deleteMin","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L96-L102","name":"Std.PairingHeapImp.Heap.noSibling_combine","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.noSibling_combine","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L91-L94","name":"Std.PairingHeapImp.Heap.noSibling_merge","kind":"theorem","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.noSibling_merge","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L85-L89","name":"Std.PairingHeapImp.instDecidableNoSibling","kind":"instance","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.instDecidableNoSibling","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L82-L83","name":"Std.PairingHeapImp.Heap.NoSibling.node","kind":"ctor","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.NoSibling.node","doc":"Or there is exactly one tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L80-L81","name":"Std.PairingHeapImp.Heap.NoSibling.nil","kind":"ctor","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.NoSibling.nil","doc":"An empty heap is no more than one tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L79-L83","name":"Std.PairingHeapImp.Heap.NoSibling","kind":"inductive","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.NoSibling","doc":"A predicate says there is no more than one tree. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L75-L76","name":"Std.PairingHeapImp.Heap.tail","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.tail","doc":"Amortized `O(log n)`. Remove the minimum element of the heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L71-L72","name":"Std.PairingHeapImp.Heap.tail?","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.tail?","doc":"Amortized `O(log n)`. Get the tail of the pairing heap after removing the minimum element. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L66-L68","name":"Std.PairingHeapImp.Heap.deleteMin","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.deleteMin","doc":"Amortized `O(log n)`. Find and remove the the minimum element from the heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L61-L63","name":"Std.PairingHeapImp.Heap.head?","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.head?","doc":"`O(1)`. Get the smallest element in the heap, if it has an element. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L56-L58","name":"Std.PairingHeapImp.Heap.headD","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.headD","doc":"`O(1)`. Get the smallest element in the heap, including the passed in value `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L51-L53","name":"Std.PairingHeapImp.Heap.combine","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.combine","doc":"Auxiliary for `Heap.deleteMin`: merge the forest in pairs. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L43-L48","name":"Std.PairingHeapImp.Heap.merge","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.merge","doc":"`O(1)`. Merge two heaps. Ignore siblings. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L38-L40","name":"Std.PairingHeapImp.Heap.isEmpty","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.isEmpty","doc":"`O(1)`. Is the heap empty? "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L35-L35","name":"Std.PairingHeapImp.Heap.singleton","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.singleton","doc":"A node containing a single element `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L30-L32","name":"Std.PairingHeapImp.Heap.size","kind":"def","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.size","doc":"`O(n)`. The number of elements in the heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L27-L27","name":"Std.PairingHeapImp.instReprHeap","kind":"instance","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.instReprHeap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L24-L26","name":"Std.PairingHeapImp.Heap.node","kind":"ctor","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.node","doc":"A forest consists of a root `a`, a forest `child` elements greater than `a`,\nand another forest `sibling`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L22-L23","name":"Std.PairingHeapImp.Heap.nil","kind":"ctor","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap.nil","doc":"An empty forest, which has depth `0`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/PairingHeap.lean#L21-L27","name":"Std.PairingHeapImp.Heap","kind":"inductive","docLink":"./Std/Data/PairingHeap.html#Std.PairingHeapImp.Heap","doc":"A `Heap` is the nodes of the pairing heap.\nEach node have two pointers: `child` going to the first child of this node,\nand `sibling` goes to the next sibling of this tree.\nSo it actually encodes a forest where each node has children\n`node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc.\n\nEach edge in this forest denotes a `le a b` relation that has been checked, so\nthe root is smaller than everything else under it.\n"}]}