{"name":"Std.Data.BinomialHeap","instances":[{"typeNames":["Std.BinomialHeapImp.HeapNode"],"name":"Std.BinomialHeapImp.instReprHeapNode","className":"Repr"},{"typeNames":["Std.BinomialHeapImp.Heap"],"name":"Std.BinomialHeapImp.instReprHeap","className":"Repr"},{"typeNames":["Std.BinomialHeapImp.Heap.rankGT"],"name":"Std.BinomialHeapImp.instDecidableRankGT","className":"Decidable"},{"typeNames":["Std.BinomialHeap"],"name":"Std.BinomialHeap.instInhabitedBinomialHeap","className":"Inhabited"}],"imports":["Init","Std.Classes.Order","Std.Data.Nat.Lemmas","Std.Tactic.NoMatch"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L606-L606","name":"Std.BinomialHeap.toArrayUnordered","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.toArrayUnordered","doc":"`O(n)`. Convert the heap to an array in arbitrary order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L603-L603","name":"Std.BinomialHeap.toListUnordered","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.toListUnordered","doc":"`O(n)`. Convert the heap to a list in arbitrary order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L600-L600","name":"Std.BinomialHeap.toArray","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.toArray","doc":"`O(n log n)`. Convert the heap to an array in increasing order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L597-L597","name":"Std.BinomialHeap.toList","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.toList","doc":"`O(n log n)`. Convert the heap to a list in increasing order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L594-L594","name":"Std.BinomialHeap.tail","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.tail","doc":"`O(log n)`. Removes the smallest element from the heap, if possible. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L588-L591","name":"Std.BinomialHeap.tail?","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.tail?","doc":"`O(log n)`. Removes the smallest element from the heap, or `none` if the heap is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L585-L585","name":"Std.BinomialHeap.headI","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.headI","doc":"`O(log n)`. Returns the smallest element in the heap, or `default` if the heap is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L582-L582","name":"Std.BinomialHeap.head!","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.head!","doc":"`O(log n)`. Returns the smallest element in the heap, or panics if the heap is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L579-L579","name":"Std.BinomialHeap.head?","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.head?","doc":"`O(log n)`. Returns the smallest element in the heap, or `none` if the heap is empty. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L573-L576","name":"Std.BinomialHeap.deleteMin","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.deleteMin","doc":"`O(log n)`. Remove and return the minimum element from the heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L569-L570","name":"Std.BinomialHeap.ofArray","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.ofArray","doc":"`O(n log n)`. Construct a heap from a list by inserting all the elements. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L565-L566","name":"Std.BinomialHeap.ofList","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.ofList","doc":"`O(n log n)`. Construct a heap from a list by inserting all the elements. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L561-L562","name":"Std.BinomialHeap.insert","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.insert","doc":"`O(log n)`. Add element `a` to the given heap `h`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L557-L558","name":"Std.BinomialHeap.merge","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.merge","doc":"`O(log n)`. Merge the contents of two heaps. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L553-L554","name":"Std.BinomialHeap.singleton","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.singleton","doc":"`O(1)`. Make a new heap containing `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L550-L550","name":"Std.BinomialHeap.size","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.size","doc":"`O(log n)`. The number of elements in the heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L547-L547","name":"Std.BinomialHeap.isEmpty","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.isEmpty","doc":"`O(1)`. Is the heap empty? "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L544-L544","name":"Std.BinomialHeap.instInhabitedBinomialHeap","kind":"instance","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.instInhabitedBinomialHeap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L542-L542","name":"Std.BinomialHeap.empty","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap.empty","doc":"`O(1)`. Make a new empty binomial heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L535-L536","name":"Std.mkBinomialHeap","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.mkBinomialHeap","doc":"`O(1)`. Make a new empty binomial heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L531-L532","name":"Std.BinomialHeap","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeap","doc":"A [binomial heap](https://en.wikipedia.org/wiki/Binomial_heap) is a data structure which supports\nthe following primary operations:\n\n* `insert : α → BinomialHeap α → BinomialHeap α`: add an element to the heap\n* `deleteMin : BinomialHeap α → Option (α × BinomialHeap α)`:\n  remove the minimum element from the heap\n* `merge : BinomialHeap α → BinomialHeap α → BinomialHeap α`: combine two heaps\n\nThe first two operations are known as a \"priority queue\", so this could be called\na \"mergeable priority queue\". The standard choice for a priority queue is a binary heap,\nwhich supports `insert` and `deleteMin` in `O(log n)`, but `merge` is `O(n)`.\nWith a `BinomialHeap`, all three operations are `O(log n)`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L506-L511","name":"Std.BinomialHeapImp.Heap.WellFormed.tail","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.tail","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L499-L504","name":"Std.BinomialHeapImp.Heap.WellFormed.tail?","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.tail?","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L486-L497","name":"Std.BinomialHeapImp.Heap.WellFormed.deleteMin","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.deleteMin","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L474-L484","name":"Std.BinomialHeapImp.Heap.WellFormed.findMin","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.findMin","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L472-L472","name":"Std.BinomialHeapImp.FindMin.WellFormed.next","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.WellFormed.next","doc":"`next` is a binomial heap with ranks above `rank + 1`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L470-L470","name":"Std.BinomialHeapImp.FindMin.WellFormed.node","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.WellFormed.node","doc":"`node` is a well formed forest of rank `rank` with `val` at the root. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L468-L468","name":"Std.BinomialHeapImp.FindMin.WellFormed.before","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.WellFormed.before","doc":"`before` is a difference list which can be appended to a binomial heap\nwith ranks at least `rank` to produce another well formed heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L465-L465","name":"Std.BinomialHeapImp.FindMin.WellFormed.rank","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.WellFormed.rank","doc":"The rank of the minimum element "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L463-L463","name":"Std.BinomialHeapImp.FindMin.WellFormed.mk","kind":"ctor","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.WellFormed.mk","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L463-L472","name":"Std.BinomialHeapImp.FindMin.WellFormed","kind":"structure","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.WellFormed","doc":"The well formedness predicate for a `FindMin` value.\nThis is not actually a predicate, as it contains an additional data value\n`rank` corresponding to the rank of the returned node, which is omitted from `findMin`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L452-L456","name":"Std.BinomialHeapImp.HeapNode.WellFormed.toHeap.go","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.WellFormed.toHeap.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L447-L456","name":"Std.BinomialHeapImp.HeapNode.WellFormed.toHeap","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.WellFormed.toHeap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L440-L445","name":"Std.BinomialHeapImp.Heap.WellFormed.size_eq","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.size_eq","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L433-L438","name":"Std.BinomialHeapImp.HeapNode.WellFormed.realSize_eq","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.WellFormed.realSize_eq","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L428-L431","name":"Std.BinomialHeapImp.HeapNode.WellFormed.rank_eq","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.WellFormed.rank_eq","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L424-L426","name":"Std.BinomialHeapImp.HeapNode.rankTR_eq.go","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.rankTR_eq.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L423-L426","name":"Std.BinomialHeapImp.HeapNode.rankTR_eq","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.rankTR_eq","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L419-L421","name":"Std.BinomialHeapImp.HeapNode.rank","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.rank","doc":"`O(log n)`. The rank, or the number of trees in the forest.\nThis is the same as `rankTR` but it is not tail recursive.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L410-L413","name":"Std.BinomialHeapImp.Heap.deleteMin_fst","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.deleteMin_fst","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L405-L408","name":"Std.BinomialHeapImp.Heap.findMin_val","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.findMin_val","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L401-L403","name":"Std.BinomialHeapImp.Heap.WellFormed.merge","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.merge","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L362-L399","name":"Std.BinomialHeapImp.Heap.WellFormed.merge'","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.merge'","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L357-L360","name":"Std.BinomialHeapImp.Heap.WellFormed.rankGT","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.rankGT","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L352-L355","name":"Std.BinomialHeapImp.Heap.rankGT.le_trans","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.rankGT.le_trans","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L346-L350","name":"Std.BinomialHeapImp.Heap.WellFormed.of_le","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.of_le","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L340-L344","name":"Std.BinomialHeapImp.Heap.WellFormed.of_rankGT","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.of_rankGT","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L338-L338","name":"Std.BinomialHeapImp.Heap.WellFormed.singleton","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.singleton","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L336-L336","name":"Std.BinomialHeapImp.Heap.WellFormed.nil","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed.nil","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L332-L334","name":"Std.BinomialHeapImp.Heap.WellFormed","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.WellFormed","doc":"The well formedness predicate for a binomial heap.\nIt asserts that:\n* It consists of a list of well formed trees with the specified ranks\n* The ranks are in strictly increasing order, and all are at least `n`\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L321-L324","name":"Std.BinomialHeapImp.HeapNode.WellFormed","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.WellFormed","doc":"The well formedness predicate for a heap node.\nIt asserts that:\n* If `a` is added at the top to make the forest into a tree, the resulting tree\n  is a `le`-min-heap (if `le` is well-behaved)\n* When interpreting `child` and `sibling` as left and right children of a binary tree,\n  it is a perfect binary tree with depth `r`\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L310-L311","name":"Std.BinomialHeapImp.Heap.toArrayUnordered","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.toArrayUnordered","doc":"`O(n)`. Convert the heap to an array in arbitrary order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L306-L307","name":"Std.BinomialHeapImp.Heap.toListUnordered","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.toListUnordered","doc":"`O(n)`. Convert the heap to a list in arbitrary order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L302-L303","name":"Std.BinomialHeapImp.Heap.foldTree","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.foldTree","doc":"`O(n)`. Fold a function over the tree structure to accumulate a value. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L295-L297","name":"Std.BinomialHeapImp.Heap.foldTreeM","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.foldTreeM","doc":"`O(n)`. Fold a monadic function over the tree structure to accumulate a value. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L290-L292","name":"Std.BinomialHeapImp.HeapNode.foldTreeM","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.foldTreeM","doc":"`O(n)`. Fold a monadic function over the tree structure to accumulate a value. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L284-L284","name":"Std.BinomialHeapImp.Heap.toList","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.toList","doc":"`O(n log n)`. Convert the heap to a list in increasing order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L281-L281","name":"Std.BinomialHeapImp.Heap.toArray","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.toArray","doc":"`O(n log n)`. Convert the heap to an array in increasing order. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L277-L278","name":"Std.BinomialHeapImp.Heap.fold","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.fold","doc":"`O(n log n)`. Fold over the elements of a heap in increasing order,\nby repeatedly pulling the minimum element out of the heap.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L264-L271","name":"Std.BinomialHeapImp.Heap.foldM","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.foldM","doc":"`O(n log n)`. Monadic fold over the elements of a heap in increasing order,\nby repeatedly pulling the minimum element out of the heap.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L254-L258","name":"Std.BinomialHeapImp.Heap.realSize_tail","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.realSize_tail","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L248-L252","name":"Std.BinomialHeapImp.Heap.realSize_tail?","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.realSize_tail?","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L236-L246","name":"Std.BinomialHeapImp.Heap.realSize_deleteMin","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.realSize_deleteMin","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L232-L234","name":"Std.BinomialHeapImp.HeapNode.realSize_toHeap.go","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.realSize_toHeap.go","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L231-L234","name":"Std.BinomialHeapImp.HeapNode.realSize_toHeap","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.realSize_toHeap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L218-L229","name":"Std.BinomialHeapImp.Heap.realSize_findMin","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.realSize_findMin","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L194-L211","name":"Std.BinomialHeapImp.Heap.realSize_merge","kind":"theorem","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.realSize_merge","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L191-L192","name":"Std.BinomialHeapImp.Heap.tail","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.tail","doc":"`O(log n)`. Remove the minimum element of the heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L187-L188","name":"Std.BinomialHeapImp.Heap.tail?","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.tail?","doc":"`O(log n)`. Get the tail of the binomial heap after removing the minimum element. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L180-L184","name":"Std.BinomialHeapImp.Heap.deleteMin","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.deleteMin","doc":"`O(log n)`. Find and remove the the minimum element from the binomial heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L170-L177","name":"Std.BinomialHeapImp.Heap.findMin","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.findMin","doc":"`O(log n)`. Find the minimum element, and return a data structure `FindMin` with information\nneeded to reconstruct the rest of the binomial heap.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L164-L164","name":"Std.BinomialHeapImp.FindMin.next","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.next","doc":"The forest after the minimum element. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L162-L162","name":"Std.BinomialHeapImp.FindMin.node","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.node","doc":"The children of the minimum element. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L160-L160","name":"Std.BinomialHeapImp.FindMin.val","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.val","doc":"The minimum element. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L158-L158","name":"Std.BinomialHeapImp.FindMin.before","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.before","doc":"The list of elements prior to the minimum element, encoded as a \"difference list\". "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L156-L156","name":"Std.BinomialHeapImp.FindMin.mk","kind":"ctor","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin.mk","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L156-L164","name":"Std.BinomialHeapImp.FindMin","kind":"structure","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.FindMin","doc":"The return type of `FindMin`, which encodes various quantities needed to\nreconstruct the tree in `deleteMin`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L148-L150","name":"Std.BinomialHeapImp.Heap.head?","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.head?","doc":"`O(log n)`. Get the smallest element in the heap, if it has an element. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L143-L145","name":"Std.BinomialHeapImp.Heap.headD","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.headD","doc":"`O(log n)`. Get the smallest element in the heap, including the passed in value `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L138-L140","name":"Std.BinomialHeapImp.HeapNode.toHeap.go","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.toHeap.go","doc":"Computes `s.toHeap ++ res` tail-recursively, assuming `n = s.rank`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L136-L140","name":"Std.BinomialHeapImp.HeapNode.toHeap","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.toHeap","doc":"`O(log n)`. Convert a `HeapNode` to a `Heap` by reversing the order of the nodes\nalong the `sibling` spine.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L114-L130","name":"Std.BinomialHeapImp.Heap.merge","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.merge","doc":"Merge two forests of binomial trees. The forests are assumed to be ordered\nby rank and `merge` maintains this invariant.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L107-L108","name":"Std.BinomialHeapImp.combine","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.combine","doc":"`O(1)`. Auxiliary for `Heap.merge`: combines two heap nodes of the same rank\ninto one with the next larger rank.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L99-L101","name":"Std.BinomialHeapImp.Heap.length","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.length","doc":"`O(log n)`. The number of trees in the forest. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L93-L96","name":"Std.BinomialHeapImp.instDecidableRankGT","kind":"instance","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.instDecidableRankGT","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L89-L91","name":"Std.BinomialHeapImp.Heap.rankGT","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.rankGT","doc":"`O(1)`. Auxiliary for `Heap.merge`: Is the minimum rank in `Heap` strictly larger than `n`? "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L86-L86","name":"Std.BinomialHeapImp.Heap.singleton","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.singleton","doc":"`O(1)`. The heap containing a single value `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L81-L83","name":"Std.BinomialHeapImp.Heap.isEmpty","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.isEmpty","doc":"`O(1)`. Is the heap empty? "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L76-L78","name":"Std.BinomialHeapImp.Heap.size","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.size","doc":"`O(log n)`. The number of elements in the heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L71-L73","name":"Std.BinomialHeapImp.Heap.realSize","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.realSize","doc":"`O(n)`. The \"real size\" of the heap, counting up how many values of type `α` are stored.\nThis is intended mainly for specification purposes.\nPrefer `Heap.size`, which is the same for well formed heaps.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L64-L64","name":"Std.BinomialHeapImp.instReprHeap","kind":"instance","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.instReprHeap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L61-L63","name":"Std.BinomialHeapImp.Heap.cons","kind":"ctor","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.cons","doc":"A cons node contains a tree of root `val`, children `node` and rank `rank`,\nand then `next` which is the rest of the forest. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L59-L60","name":"Std.BinomialHeapImp.Heap.nil","kind":"ctor","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap.nil","doc":"An empty heap. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L58-L64","name":"Std.BinomialHeapImp.Heap","kind":"inductive","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.Heap","doc":"A `Heap` is the top level structure in a binomial heap.\nIt consists of a forest of `HeapNode`s with strictly increasing ranks.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L50-L52","name":"Std.BinomialHeapImp.HeapNode.rankTR.go","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.rankTR.go","doc":"Computes `s.rank + r` "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L48-L52","name":"Std.BinomialHeapImp.HeapNode.rankTR","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.rankTR","doc":"`O(log n)`. The rank, or the number of trees in the forest.\nIt is also the depth of the forest.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L42-L42","name":"Std.BinomialHeapImp.HeapNode.singleton","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.singleton","doc":"A node containing a single element `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L37-L39","name":"Std.BinomialHeapImp.HeapNode.realSize","kind":"def","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.realSize","doc":"The \"real size\" of the node, counting up how many values of type `α` are stored.\nThis is `O(n)` and is intended mainly for specification purposes.\nFor a well formed `HeapNode` the size is always `2^n - 1` where `n` is the depth.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L30-L30","name":"Std.BinomialHeapImp.instReprHeapNode","kind":"instance","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.instReprHeapNode","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L26-L29","name":"Std.BinomialHeapImp.HeapNode.node","kind":"ctor","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.node","doc":"A forest of rank `r + 1` consists of a root `a`,\na forest `child` of rank `r` elements greater than `a`,\nand another forest `sibling` of rank `r`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L24-L25","name":"Std.BinomialHeapImp.HeapNode.nil","kind":"ctor","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode.nil","doc":"An empty forest, which has depth `0`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/BinomialHeap.lean#L23-L30","name":"Std.BinomialHeapImp.HeapNode","kind":"inductive","docLink":"./Std/Data/BinomialHeap.html#Std.BinomialHeapImp.HeapNode","doc":"A `HeapNode` is one of the internal nodes of the binomial heap.\nIt is always a perfect binary tree, with the depth of the tree stored in the `Heap`.\nHowever the interpretation of the two pointers is different: we view the `child`\nas going to the first child of this node, and `sibling` goes to the next sibling\nof this tree. So it actually encodes a forest where each node has children\n`node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc.\n\nEach edge in this forest denotes a `le a b` relation that has been checked, so\nthe root is smaller than everything else under it.\n"}]}