{"name":"Mathlib.Tactic.Linarith.Frontend","instances":[],"imports":["Init","Mathlib.Control.Basic","Mathlib.Data.HashMap","Mathlib.Tactic.Linarith.Verification","Mathlib.Tactic.Linarith.Preprocessing"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L386-L389","name":"elabLinarithConfig","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#elabLinarithConfig","doc":"Allow elaboration of `LinarithConfig` arguments to tactics.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L383-L384","name":"tacticNlinarith!_","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#tacticNlinarith!_","doc":"An extension of `linarith` with some preprocessing to allow it to solve some nonlinear arithmetic\nproblems. (Based on Coq's `nra` tactic.) See `linarith` for the available syntax of options,\nwhich are inherited by `nlinarith`; that is, `nlinarith!` and `nlinarith only [h1, h2]` all work as\nin `linarith`. The preprocessing is as follows:\n\n* For every subterm `a ^ 2` or `a * a` in a hypothesis or the goal,\n  the assumption `0 ≤ a ^ 2` or `0 ≤ a * a` is added to the context.\n* For every pair of hypotheses `a1 R1 b1`, `a2 R2 b2` in the context, `R1, R2 ∈ {<, ≤, =}`,\n  the assumption `0 R' (b1 - a1) * (b2 - a2)` is added to the context (non-recursively),\n  where `R ∈ {<, ≤, =}` is the appropriate comparison derived from `R1, R2`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L370-L382","name":"nlinarith","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#nlinarith","doc":"An extension of `linarith` with some preprocessing to allow it to solve some nonlinear arithmetic\nproblems. (Based on Coq's `nra` tactic.) See `linarith` for the available syntax of options,\nwhich are inherited by `nlinarith`; that is, `nlinarith!` and `nlinarith only [h1, h2]` all work as\nin `linarith`. The preprocessing is as follows:\n\n* For every subterm `a ^ 2` or `a * a` in a hypothesis or the goal,\n  the assumption `0 ≤ a ^ 2` or `0 ≤ a * a` is added to the context.\n* For every pair of hypotheses `a1 R1 b1`, `a2 R2 b2` in the context, `R1, R2 ∈ {<, ≤, =}`,\n  the assumption `0 R' (b1 - a1) * (b2 - a2)` is added to the context (non-recursively),\n  where `R ∈ {<, ≤, =}` is the appropriate comparison derived from `R1, R2`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L367-L368","name":"tacticLinarith!_","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#tacticLinarith!_","doc":"`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `False`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `Nat` and `Int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `LinearOrderedCommRing`.\n\nAn example:\n```lean\nexample (x y z : ℚ) (h1 : 2*x  < 3*y) (h2 : -4*x + 2*z < 0)\n        (h3 : 12*y - 4* z < 0)  : False :=\nby linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ℚ) : id x ≥ x :=\nby linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `split_hypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `exfalso` is false, `linarith` will fail when the goal is neither an inequality nor `false`.\n  (True by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer and rational valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L313-L365","name":"linarith","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#linarith","doc":"`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `False`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `Nat` and `Int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `LinearOrderedCommRing`.\n\nAn example:\n```lean\nexample (x y z : ℚ) (h1 : 2*x  < 3*y) (h2 : -4*x + 2*z < 0)\n        (h3 : 12*y - 4* z < 0)  : False :=\nby linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ℚ) : id x ≥ x :=\nby linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `split_hypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `exfalso` is false, `linarith` will fail when the goal is neither an inequality nor `false`.\n  (True by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer and rational valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L310-L311","name":"linarithArgsRest","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#linarithArgsRest","doc":"Syntax for the arguments of `linarith`, after the optional `!`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L265-L302","name":"Linarith.linarith","kind":"opaque","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.linarith","doc":"`linarith only_on hyps cfg` tries to close the goal using linear arithmetic. It fails\nif it does not succeed at doing this.\n\n* `hyps` is a list of proofs of comparisons to include in the search.\n* If `only_on` is true, the search will be restricted to `hyps`. Otherwise it will use all\n  comparisons in the local context.\n* If `cfg.transparency := semireducible`,\n  it will unfold semireducible definitions when trying to match atomic expressions.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L221-L242","name":"Linarith.runLinarith","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.runLinarith","doc":"Given a list `hyps` of proofs of comparisons, `runLinarith cfg hyps prefType`\npreprocesses `hyps` according to the list of preprocessors in `cfg`.\nThis results in a list of branches (typically only one),\neach of which must succeed in order to close the goal.\n\nIn each branch, we partition the list of hypotheses by type, and run `linarith` on each class\nin the partition; one of these must succeed in order for `linarith` to succeed on this branch.\nIf `prefType` is given, it will first use the class of proofs of comparisons over that type.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L203-L207","name":"Linarith.findLinarithContradiction","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.findLinarithContradiction","doc":"Given a list `ls` of lists of proofs of comparisons, `findLinarithContradiction cfg ls` will try to\nprove `false` by calling `linarith` on each list in succession. It will stop at the first proof of\n`false`, and fail if no contradiction is found with any list.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L195-L196","name":"Linarith.partitionByType","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.partitionByType","doc":"`partitionByType l` takes a list `l` of proofs of comparisons. It sorts these proofs by\nthe type of the variables in the comparison, e.g. `(a : ℚ) < 1` and `(b : ℤ) > c` will be separated.\nReturns a map from a type to a list of comparisons over that type.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L184-L188","name":"Linarith.ExprMultiMap.insert","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap.insert","doc":"Insert a new value into the map at key `k`. This does a defeq check with all other keys\nin the map. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L175-L180","name":"Linarith.ExprMultiMap.find","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap.find","doc":"Retrieves the list of values at a key, as well as the index of the key for later modification.\n(If the key is not in the map it returns `self.size` as the index.) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L171-L171","name":"Linarith.ExprMultiMap","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap","doc":"A map of keys to values, where the keys are `Expr` up to defeq and one key can be\nassociated to multiple values. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L161-L167","name":"Linarith.applyContrLemma","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.applyContrLemma","doc":"`applyContrLemma` inspects the target to see if it can be moved to a hypothesis by negation.\nFor example, a goal `⊢ a ≤ b` can become `a > b ⊢ false`.\nIf this is the case, it applies the appropriate lemma and introduces the new hypothesis.\nIt returns the type of the terms in the comparison (e.g. the type of `a` and `b` above) and the\nnewly introduced local constant.\nOtherwise returns `none`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Linarith/Frontend.lean#L136-L151","name":"Linarith.getContrLemma","kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.getContrLemma","doc":"If `e` is a comparison `a R b` or the negation of a comparison `¬ a R b`, found in the target,\n`getContrLemma e` returns the name of a lemma that will change the goal to an\nimplication, along with the type of `a` and `b`.\n\nFor example, if `e` is `(a : ℕ) < b`, returns ``(`lt_of_not_ge, ℕ)``.\n"}]}