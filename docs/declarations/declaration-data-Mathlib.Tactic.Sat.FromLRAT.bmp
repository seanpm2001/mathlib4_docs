{"name":"Mathlib.Tactic.Sat.FromLRAT","instances":[{"typeNames":["Sat.Literal"],"name":"Sat.instToExprLiteral","className":"Lean.ToExpr"}],"imports":["Init","Mathlib.Data.List.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L631-L661","name":"Mathlib.Tactic.Sat.termFrom_lrat___","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.termFrom_lrat___","doc":"A macro for producing SAT proofs from CNF / LRAT files.\nThese files are commonly used in the SAT community for writing proofs.\n\nThe input to the `from_lrat` term syntax is two string expressions with\nthe statement (written in CNF format) and the proof (in LRAT format).\nFor example:\n```\ndef foo := from_lrat\n  \"p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0\"\n  \"5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0\"\n```\nproduces a theorem:\n```\nfoo : ∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1\n```\n\n* You can use this term after `have :=` or in `def foo :=` to produce the term\n  without constraining the type.\n* You can use it when a specific type is expected, but it currently does not\n  pay any attention to the shape of the goal and always produces the same theorem,\n  so you can only use this to do alpha renaming.\n* You can use the `include_str` macro in place of the two strings\n  to load CNF / LRAT files from disk.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L579-L611","name":"Mathlib.Tactic.Sat.commandLrat_proof_Example____","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.commandLrat_proof_Example____","doc":"A macro for producing SAT proofs from CNF / LRAT files.\nThese files are commonly used in the SAT community for writing proofs.\n\nThe input to the `lrat_proof` command is the name of the theorem to define,\nand the statement (written in CNF format) and the proof (in LRAT format).\nFor example:\n```\nlrat_proof foo\n  \"p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0\"\n  \"5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0\"\n```\nproduces a theorem:\n```\nfoo : ∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1\n```\n\n* You can see the theorem statement by hovering over the word `foo`.\n* You can use the `example` keyword in place of `foo` to avoid generating a theorem.\n* You can use the `include_str` macro in place of the two strings\n  to load CNF / LRAT files from disk.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L571-L574","name":"Mathlib.Tactic.Sat.fromLRAT","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.fromLRAT","doc":"Main entry point. Given strings `cnf` and `lrat` with unparsed file data, and a name `name`,\nadds `theorem name : type := proof` where `type` is a propositional theorem like\n`∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1`.\n\nAlso creates auxiliaries named `name.ctx_1` (for the CNF formula)\nand `name.proof_1` (for the LRAT proof), with `name` itself containing the reification proof. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L538-L563","name":"Mathlib.Tactic.Sat.fromLRATAux","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.fromLRATAux","doc":"Core of `fromLRAT`. Constructs the context and main proof definitions,\nbut not the reification theorem. Returns:\n\n  * `nvars`: the number of variables specified in the CNF file\n  * `ctx`: The abbreviated formula, a constant like `foo.ctx_1`\n  * `ctx'`: The definitional expansion of the formula, a tree of `Fmla.and` nodes\n  * `proof`: A proof of `ctx.proof []`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L523-L526","name":"Mathlib.Tactic.Sat.Parser.parseLRAT","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseLRAT","doc":"Parse an LRAT file into a list of steps. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L513-L520","name":"Mathlib.Tactic.Sat.Parser.parseDimacs","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseDimacs","doc":"Parse a DIMACS format `.cnf` file.\nThis is not very robust; we assume the file has had comments stripped. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L506-L509","name":"Mathlib.Tactic.Sat.Parser.parseNats","kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseNats","doc":"Parse a list of natural numbers terminated by 0 "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L500-L503","name":"Mathlib.Tactic.Sat.Parser.parseInts","kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseInts","doc":"Parse a list of integers terminated by 0 "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L496-L497","name":"Mathlib.Tactic.Sat.Parser.parseInt","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseInt","doc":"Parse an integer "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L493-L493","name":"Mathlib.Tactic.Sat.Parser.parseNat","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseNat","doc":"Parse a natural number "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L484-L486","name":"Mathlib.Tactic.Sat.buildReify.reifyVar","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyVar","doc":"Returns `a` and `pr : v n ↔ a` given a variable index `n`.\nThese are both lookups into the context\n`(a0 .. a(n-1) : Prop) (v) (h1 : v 0 ↔ a0) ... (hn : v (n-1) ↔ a(n-1))`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L472-L480","name":"Mathlib.Tactic.Sat.buildReify.reifyLiteral","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyLiteral","doc":"Returns `a` and `pr : reify v l a` given a literal `c` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L462-L470","name":"Mathlib.Tactic.Sat.buildReify.reifyClause1","kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyClause1","doc":"Returns `a` and `pr : reify v c a` given a nonempty clause `c` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L457-L460","name":"Mathlib.Tactic.Sat.buildReify.reifyClause","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyClause","doc":"Returns `a` and `pr : reify v c a` given a clause `c` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L443-L455","name":"Mathlib.Tactic.Sat.buildReify.reifyFmla","kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyFmla","doc":"Returns `a` and `pr : reify v f a` given a formula `f` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L441-L441","name":"Mathlib.Tactic.Sat.buildReify.v","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v","doc":"The `v` variable under the `a1 ... an, v, h1 ... hn` context "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L431-L433","name":"Mathlib.Tactic.Sat.buildReify.mkPS","kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.mkPS","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L420-L486","name":"Mathlib.Tactic.Sat.buildReify","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify","doc":"Build the type and value of the reified theorem. This rewrites all the SAT definitions\ninto standard operators on `Prop`, for example if the formula is `[[1, 2], [-1, 2], [-2]]` then\nthis produces a proof of `⊢ ∀ a b : Prop, (a ∧ b) ∨ (¬a ∧ b) ∨ ¬b`. We use the input `nvars` to\ndecide how many quantifiers to use.\n\nMost of the proof is under `2 * nvars + 1` quantifiers\n`a1 .. an : Prop, v : Valuation, h1 : v 0 ↔ a1, ... hn : v (n-1) ↔ an ⊢ ...`, and we do the index\narithmetic by hand.\n\n  1. First, we call `reifyFormula ctx'` which returns `a` and `pr : reify v ctx' a`\n  2. Then we build `fun (v : Valuation) (h1 : v 0 ↔ a1) ... (hn : v (n-1) ↔ an) ↦ pr`\n  3. We have to lower expression `a` from step 1 out of the quantifiers by lowering all variable\n     indices by `nvars+1`. This is okay because `v` and `h1..hn` do not appear in `a`.\n  4. We construct the expression `ps`, which is `a1 .. an : Prop ⊢ [a1, ..., an] : List Prop`\n  5. `refute ctx (hf : ctx.proof []) (fun v h1 .. hn ↦ pr) : a` forces some definitional unfolding\n     since `fun h1 .. hn ↦ pr` should have type `implies v (reify v ctx a) [a1, ..., an] a`,\n     which involves unfolding `implies` n times as well as `ctx ↦ ctx'`.\n  6. Finally, we `intro a1 ... an` so that we have a proof of `∀ a1 ... an, a`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L385-L399","name":"Mathlib.Tactic.Sat.buildProof","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildProof","doc":"Build the main proof of `⊢ ctx.proof []` using the LRAT proof trace.\n\n* `arr`: The input CNF\n* `ctx`: The abbreviated formula, a constant like `foo.ctx_1`\n* `ctx'`: The definitional expansion of the formula, a tree of `Fmla.and` nodes\n* `steps`: The input LRAT proof trace\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L375-L376","name":"Mathlib.Tactic.Sat.LRATStep.del","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep.del","doc":"A (multiple) deletion step, which deletes all the listed clause IDs from the context "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L373-L374","name":"Mathlib.Tactic.Sat.LRATStep.add","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep.add","doc":"An addition step, with the clause ID, the clause literal list, and the proof trace "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L372-L376","name":"Mathlib.Tactic.Sat.LRATStep","kind":"inductive","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep","doc":"An LRAT step is either an addition or a deletion step. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L310-L369","name":"Mathlib.Tactic.Sat.buildProofStep","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildProofStep","doc":"Construct an individual proof step `⊢ ctx.proof c`.\n\n* `db`: the current global context\n* `ns`, `clause`: the new clause\n* `pf`: the LRAT proof trace\n* `ctx`: the main formula\n\nThe proof has three steps:\n\n1. Introduce local assumptions `have h1 : ctx.proof c1 := p1` for each clause `c1`\n   referenced in the proof. We actually do all the introductions at once,\n   as in `(fun h1 h2 h3 ↦ ...) p1 p2 p3`, because we want `p_i` to not be under any binders\n   to avoid the cost of `instantiate` during typechecking and get the benefits of dag-like\n   sharing in the `pi` (which are themselves previous proof steps which may be large terms).\n   The hypotheses are in `gctx`, keyed on the clause ID.\n\n2. Unfold `⊢ ctx.proof [a, b, c]` to\n   `∀ v, v.satisfies_fmla ctx → v.neg a → v.neg b → v.neg c → False` and `intro v hv ha hb hc`,\n   storing each `ha : v.neg a` in `lctx`, keyed on the literal `a`.\n\n3. For each LRAT step `hc : ctx.proof [x, y]`, `hc v hv : v.neg x → v.neg y → False`.\n   We look for a literal that is not falsified in the clause. Since it is a unit propagation\n   step, there can be at most one such literal.\n   * If `x` is the non-falsified clause, let `x'` denote the negated literal of `x`.\n     Then `x'.negate` reduces to `x`, so `hnx : v.neg x'.negate |- hc v hv hnx hy : False`,\n     so we construct the term\n       `by_cases (fun hnx : v.neg x'.negate ↦ hc v hv hnx hy) (fun hx : v.neg x ↦ ...)`\n     and `hx` is added to the local context.\n   * If all clauses are falsified, then we are done: `hc v hv hx hy : False`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L278-L278","name":"Mathlib.Tactic.Sat.LClause.depth","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.depth","doc":"The bound variable index of the hypothesis asserting `⊢ ctx.proof c`,\n_counting from the outside and 1-based_. (We use this numbering because we will need to\nreference the variable from multiple binder depths.) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L274-L274","name":"Mathlib.Tactic.Sat.LClause.expr","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.expr","doc":"The clause expression of type `Clause` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L272-L272","name":"Mathlib.Tactic.Sat.LClause.lits","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.lits","doc":"The list of literals as read from the input file "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L270-L278","name":"Mathlib.Tactic.Sat.LClause","kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause","doc":"A localized clause reference.\nIt is the same as `Clause` except that the proof is now a local variable. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L250-L266","name":"Mathlib.Tactic.Sat.buildClauses","kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildClauses","doc":"Constructs the proofs of `⊢ ctx.proof c` for each clause `c` in `ctx`.\nThe proofs are stashed in a `HashMap` keyed on the clause ID. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L240-L246","name":"Mathlib.Tactic.Sat.buildConj","kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildConj","doc":"Constructs the formula expression from the input CNF, as a balanced tree of `Fmla.and` nodes. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L234-L237","name":"Mathlib.Tactic.Sat.buildClause","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildClause","doc":"Construct the clause expression from the input list. For example `[1, -2]` is translated to\n`Clause.cons (Literal.pos 1) (Clause.cons (Literal.neg 2) Clause.nil)`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L230-L230","name":"Mathlib.Tactic.Sat.Clause.proof","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.proof","doc":"A proof of `⊢ ctx.proof c`.\nNote that we do not use `have` statements to cache these proofs:\nthis is literally the proof expression itself. As a result, the proof terms\nrely heavily on dag-like sharing of the expression, and printing these proof terms\ndirectly is likely to crash lean for larger examples. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L224-L224","name":"Mathlib.Tactic.Sat.Clause.expr","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.expr","doc":"The clause expression of type `Clause` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L222-L222","name":"Mathlib.Tactic.Sat.Clause.lits","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.lits","doc":"The list of literals as read from the input file "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L220-L230","name":"Mathlib.Tactic.Sat.Clause","kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause","doc":"The representation of a global clause. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L213-L213","name":"Sat.Literal.reify_neg","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify_neg","doc":"The reification of a negative literal `¬⟦¬a⟧_v ≡ a`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L210-L210","name":"Sat.Literal.reify_pos","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify_pos","doc":"The reification of a positive literal `¬⟦a⟧_v ≡ ¬a`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L206-L207","name":"Sat.Clause.reify_one","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_one","doc":"The reification of a singleton clause `¬⟦l⟧_v ≡ ¬⟦l⟧_v`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L203-L203","name":"Sat.Clause.reify_zero","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_zero","doc":"The reification of the empty clause is `True`: `¬⟦⊥⟧_v ≡ True`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L198-L200","name":"Sat.Clause.reify_and","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_and","doc":"Negation turns OR into AND, so `¬⟦l ∨ c⟧_v ≡ ¬⟦l⟧_v ∧ ¬⟦c⟧_v`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L195-L195","name":"Sat.Literal.reify.prop","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify.prop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L194-L194","name":"Sat.Literal.reify.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L194-L195","name":"Sat.Literal.reify","kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify","doc":"Asserts that `¬⟦l⟧_v` implies `p`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L190-L191","name":"Sat.Fmla.reify_one","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify_one","doc":"Reification of a single clause formula. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L187-L187","name":"Sat.Clause.reify.prop","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify.prop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L186-L186","name":"Sat.Clause.reify.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L186-L187","name":"Sat.Clause.reify","kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify","doc":"Asserts that `¬⟦c⟧_v` implies `p`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L178-L183","name":"Sat.Fmla.reify_or","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify_or","doc":"Negation turns AND into OR, so `¬⟦f₁ ∧ f₂⟧_v ≡ ¬⟦f₁⟧_v ∨ ¬⟦f₂⟧_v`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L173-L175","name":"Sat.Fmla.refute","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.refute","doc":"If `f` is unsatisfiable, and every `v` which agrees with `ps` implies `¬⟦f⟧_v → p`, then `p`.\nEquivalently, there exists a valuation `v` which agrees with `ps`,\nand every such valuation yields `¬⟦f⟧_v` because `f` is unsatisfiable. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L168-L168","name":"Sat.Fmla.reify.prop","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify.prop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L167-L167","name":"Sat.Fmla.reify.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L167-L168","name":"Sat.Fmla.reify","kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify","doc":"Asserts that `¬⟦f⟧_v` implies `p`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L154-L164","name":"Sat.Valuation.mk_implies","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk_implies","doc":"The fundamental relationship between `mk` and `implies`:\n`(mk ps).implies p ps 0` is equivalent to `p`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L147-L150","name":"Sat.Valuation.mk","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk","doc":"`Valuation.mk [a, b, c]` is a valuation which is `a` at 0, `b` at 1 and `c` at 2, and false\neverywhere else. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L141-L143","name":"Sat.Valuation.implies","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies","doc":"`v.implies p [a, b, c] 0` definitionally unfolds to `(v 0 ↔ a) → (v 1 ↔ b) → (v 2 ↔ c) → p`.\nThis is used to introduce assumptions about the first `n` values of `v` during reification. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L133-L137","name":"Sat.Valuation.by_cases","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.by_cases","doc":"The core unit-propagation step.\n\nWe have a local context of assumptions `¬l'` (sometimes called an assignment)\nand we wish to add `¬l` to the context, that is, we want to prove `l` is also falsified.\nThis is because there is a clause `a ∨ b ∨ ¬l` in the global context\nsuch that all literals in the clause are falsified except for `¬l`;\nso in the context `h₁` where we suppose that `¬l` is falsified,\nthe clause itself is falsified so we can prove `False`.\nWe continue the proof in `h₂`, with the assumption that `l` is falsified. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L121-L122","name":"Sat.Fmla.proof_of_subsumes","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof_of_subsumes","doc":"If `f` subsumes `c` (i.e. `c ∈ f`), then `f.proof c`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L117-L118","name":"Sat.Fmla.proof","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof","doc":"`f.proof c` asserts that `c` is derivable from `f`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L114-L114","name":"Sat.Valuation.satisfies_fmla.prop","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla.prop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L113-L113","name":"Sat.Valuation.satisfies_fmla.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L113-L114","name":"Sat.Valuation.satisfies_fmla","kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla","doc":"`v.satisfies_fmla f` asserts that formula `f` is satisfied by the valuation.\nA formula is satisfied if all clauses in it are satisfied. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L107-L109","name":"Sat.Valuation.satisfies","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies","doc":"`v.satisfies c` asserts that clause `c` satisfied by the valuation.\nIt is written in a negative way: A clause like `a ∨ ¬b ∨ c` is rewritten as\n`¬a → b → ¬c → False`, so we are asserting that it is not the case that\nall literals in the clause are falsified. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L99-L101","name":"Sat.Valuation.neg","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.neg","doc":"`v.neg lit` asserts that literal `lit` is falsified in the valuation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L96-L96","name":"Sat.Valuation","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation","doc":"A valuation is an assignment of values to all the propositional variables. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L92-L93","name":"Sat.Fmla.subsumes_right","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L90-L91","name":"Sat.Fmla.subsumes_left","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L89-L89","name":"Sat.Fmla.subsumes_self","kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_self","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L87-L87","name":"Sat.Fmla.subsumes.prop","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes.prop","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L86-L86","name":"Sat.Fmla.subsumes.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L86-L87","name":"Sat.Fmla.subsumes","kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes","doc":"Formula `f` subsumes `f'` if all the clauses in `f'` are in `f`.\nWe use this to prove that all clauses in the formula are subsumed by it. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L82-L82","name":"Sat.Fmla.and","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and","doc":"A conjunction of formulas. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L79-L79","name":"Sat.Fmla.one","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.one","doc":"A single clause as a formula. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L76-L76","name":"Sat.Fmla","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla","doc":"A formula is a list of clauses, thought of as a conjunction like `(a ∨ b) ∧ c ∧ (¬c ∨ ¬d)`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L73-L73","name":"Sat.Clause.cons","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L72-L72","name":"Sat.Clause.nil","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.nil","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L70-L70","name":"Sat.Clause","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause","doc":"A clause is a list of literals, thought of as a disjunction like `a ∨ b ∨ ¬c`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L63-L67","name":"Sat.instToExprLiteral","kind":"instance","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.instToExprLiteral","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L59-L61","name":"Sat.Literal.negate","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.negate","doc":"Swap the polarity of a literal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L55-L56","name":"Sat.Literal.ofInt","kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.ofInt","doc":"Construct a literal. Positive numbers are translated to positive literals,\nand negative numbers become negative literals. The input is assumed to be nonzero. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L51-L51","name":"Sat.Literal.neg","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L50-L50","name":"Sat.Literal.pos","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.pos","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L49-L51","name":"Sat.Literal","kind":"inductive","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal","doc":"A literal is a positive or negative occurrence of an atomic propositional variable.\nNote that unlike DIMACS, 0 is a valid variable index. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L1-L1","name":"Mathlib.Tactic.Sat.Clause.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Sat/FromLRAT.lean#L1-L1","name":"Mathlib.Tactic.Sat.LClause.mk","kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.mk","doc":""}]}