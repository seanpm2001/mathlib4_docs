{"name":"Mathlib.Tactic.Classical","instances":[],"imports":["Init","Lean.Elab.ElabRules"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Classical.lean#L27-L51","name":"Mathlib.Tactic.tacticClassical_","kind":"def","docLink":"./Mathlib/Tactic/Classical.html#Mathlib.Tactic.tacticClassical_","doc":"`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority\nlocal instance. It differs from `classical!` in that `classical!` uses a local variable,\nwhich has high priority:\n```\nnoncomputable def foo : Bool := by\n  classical!\n  have := ∀ p, decide p -- uses the classical instance\n  exact decide (0 < 1) -- uses the classical instance even though `0 < 1` is decidable\n\ndef bar : Bool := by\n  classical\n  have := ∀ p, decide p -- uses the classical instance\n  exact decide (0 < 1) -- uses the decidable instance\n```\nNote that (unlike lean 3) `classical` is a scoping tactic - it adds the instance only within the\nscope of the tactic.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/Classical.lean#L24-L25","name":"Mathlib.Tactic.classical!","kind":"def","docLink":"./Mathlib/Tactic/Classical.html#Mathlib.Tactic.classical!","doc":"`classical!` adds a proof of `Classical.propDecidable` as a local variable, which makes it\navailable for instance search and effectively makes all propositions decidable.\n```\nnoncomputable def foo : Bool := by\n  classical!\n  have := ∀ p, decide p -- uses the classical instance\n  exact decide (0 < 1) -- uses the classical instance even though `0 < 1` is decidable\n```\nConsider using `classical` instead if you want to use the decidable instance when available.\n"}]}