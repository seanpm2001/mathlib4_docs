{"name":"Mathlib.Tactic.ProxyType","instances":[],"imports":["Init","Lean","Mathlib.Tactic.Core","Mathlib.Logic.Equiv.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L277-L284","name":"Mathlib.ProxyType.elab_proxy_equiv","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elab_proxy_equiv","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L249-L274","name":"Mathlib.ProxyType.proxy_equiv","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.proxy_equiv","doc":"The term elaborator `proxy_equiv% α` for a type `α` elaborates to an equivalence `β ≃ α`\nfor a \"proxy type\" `β` composed out of basic type constructors `Unit`, `PLift`, `Sigma`,\n`Empty`, and `Sum`.\n\nThis only works for inductive types `α` that are neither recursive nor have indices.\nIf `α` is an inductive type with name `I`, then as a side effect this elaborator defines\n`I.proxyType` and `I.proxyTypeEquiv`.\n\nThe elaborator makes use of the expected type, so `(proxy_equiv% _ : _ ≃ α)` works.\n\nFor example, given this inductive type\n```\ninductive foo (n : Nat) (α : Type)\n  | a\n  | b : Bool → foo n α\n  | c (x : Fin n) : Fin x → foo n α\n  | d : Bool → α → foo n α\n```\nthe proxy type it generates is `Unit ⊕ Bool ⊕ (x : Fin n) × Fin x ⊕ (_ : Bool) × α` and\nin particular we have that\n```\nproxy_equiv% (foo n α) : Unit ⊕ Bool ⊕ (x : Fin n) × Fin x ⊕ (_ : Bool) × α ≃ foo n α\n```\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L235-L247","name":"Mathlib.ProxyType.elabProxyEquiv","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elabProxyEquiv","doc":"Helper function for `proxy_equiv% type : expectedType` elaborators.\n\nElaborate `type` and get its `InductiveVal`. Uses the `expectedType`, where the\nexpected type should be of the form `_ ≃ type`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L150-L229","name":"Mathlib.ProxyType.ensureProxyEquiv","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ensureProxyEquiv","doc":"Generates a proxy type for the inductive type and an equivalence from the proxy type to the type.\n\nIf the declarations already exist, there is a check that they are correct.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L139-L143","name":"Mathlib.ProxyType.ProxyEquivConfig.default","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.default","doc":"Default configuration. Defines `proxyType` and `proxyTypeEquiv` in the namespace\nof the inductive type. Uses `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L126-L135","name":"Mathlib.ProxyType.defaultMkProxyType.wrapSumAccess","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType.wrapSumAccess","doc":"Navigates into the sum type that we create in `mkCType` for the given constructor index. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L117-L124","name":"Mathlib.ProxyType.defaultMkProxyType.mkCType","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType.mkCType","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L105-L135","name":"Mathlib.ProxyType.defaultMkProxyType","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType","doc":"Create a `Sum` of types, mildly optimized to not have a trailing `Empty`.\n\nThe `decorateSum` function is to wrap the `Sum` a decorator such as `Lex`.\nIt should yield a definitionally equal type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L78-L99","name":"Mathlib.ProxyType.defaultMkCtorProxyType","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkCtorProxyType","doc":"Returns a proxy type for a constructor and a pattern to use to match against it.\n\nInput: a list of pairs associated to each argument of the constructor consisting\nof (1) an fvar for this argument and (2) a name to use for this argument in patterns.\n\nFor example, given `#[(a, x), (b, y)]` with `x : Nat` and `y : Fin x`, then this function\nreturns `Sigma (fun x => Fin x)` and `⟨a, b⟩`.\n\nAlways returns a `Type _`. Uses `Unit`, `PLift`, and `Sigma`. Avoids using `PSigma` since\nthe `Fintype` instances for it go through `Sigma`s anyway.\n\nThe `decorateSigma` function is to wrap the `Sigma` a decorator such as `Lex`.\nIt should yield a definitionally equal type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L63-L63","name":"Mathlib.ProxyType.ProxyEquivConfig.mkProxyType","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkProxyType","doc":"Given (constructor name, proxy constructor type, proxy constructor pattern) triples\nconstructed using `mkCtorProxyType`, return (1) the total proxy type (a `Type _`),\n(2) patterns to use for each constructor, and (3) a proof to use to prove `left_inv` for\n`proxy_type ≃ type` (this proof starts with `intro x`). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L58-L58","name":"Mathlib.ProxyType.ProxyEquivConfig.mkCtorProxyType","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkCtorProxyType","doc":"Returns a proxy type for a constructor and a pattern to use to match against it,\ngiven a list of fvars for the constructor arguments and pattern names to use for the arguments.\nThe proxy type is expected to be a `Type _`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L54-L54","name":"Mathlib.ProxyType.ProxyEquivConfig.proxyEquivName","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.proxyEquivName","doc":"Name to use for the declaration for the equivalence `proxyType ≃ type`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L52-L52","name":"Mathlib.ProxyType.ProxyEquivConfig.proxyName","kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.proxyName","doc":"Name to use for the declaration for a type that is `Equiv` to the given type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L50-L63","name":"Mathlib.ProxyType.ProxyEquivConfig","kind":"structure","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig","doc":"Configuration used by `mkProxyEquiv`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ProxyType.lean#L1-L1","name":"Mathlib.ProxyType.ProxyEquivConfig.mk","kind":"ctor","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mk","doc":""}]}