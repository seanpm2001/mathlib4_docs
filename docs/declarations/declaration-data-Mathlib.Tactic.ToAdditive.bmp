{"name":"Mathlib.Tactic.ToAdditive","instances":[{"typeNames":["ToAdditive.Config"],"name":"ToAdditive.instReprConfig","className":"Repr"}],"imports":["Init","Mathlib.Init.Data.Nat.Notation","Mathlib.Data.String.Defs","Mathlib.Data.Array.Defs","Mathlib.Data.KVMap","Mathlib.Lean.Expr.ReplaceRec","Mathlib.Lean.EnvExtension","Mathlib.Lean.Meta.Simp","Std.Lean.NameMapAttribute","Std.Data.Option.Basic","Std.Tactic.CoeExt","Std.Tactic.Ext.Attr","Std.Tactic.Lint","Mathlib.Tactic.Relation.Rfl","Mathlib.Tactic.Relation.Symm","Mathlib.Tactic.Relation.Trans","Mathlib.Tactic.Eqns","Mathlib.Tactic.Simps.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L999-L1041","name":"ToAdditive.addToAdditiveAttr","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.addToAdditiveAttr","doc":"`addToAdditiveAttr src cfg` adds a `@[to_additive]` attribute to `src` with configuration `cfg`.\nSee the attribute implementation for more details.\nIt returns an array with names of additive declarations (usually 1, but more if there are nested\n`to_additive` calls. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L991-L993","name":"ToAdditive.transformDecl","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.transformDecl","doc":"Make a new copy of a declaration, replacing fragments of the names of identifiers in the type and\nthe body using the `translations` dictionary.\nThis is used to implement `@[to_additive]`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L972-L984","name":"ToAdditive.copyMetaData","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.copyMetaData","doc":"Copies equation lemmas and attributes from `src` to `tgt`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L901-L967","name":"ToAdditive.applyAttributes","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyAttributes","doc":"Apply attributes to the multiplicative and additive declarations. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L873-L897","name":"ToAdditive.elabToAdditive","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.elabToAdditive","doc":"Elaboration of the configuration options for `to_additive`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L861-L870","name":"ToAdditive.proceedFields","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.proceedFields","doc":"Add the structure fields of `src` to the translations dictionary\nso that future uses of `to_additive` will map them to the corresponding `tgt` fields. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L848-L857","name":"ToAdditive.proceedFieldsAux","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.proceedFieldsAux","doc":"if `f src = #[a_1, ..., a_n]` and `f tgt = #[b_1, ... b_n]` then `proceedFieldsAux src tgt f`\nwill insert translations from `src.a_i` to `tgt.b_i`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L827-L844","name":"ToAdditive.targetName","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.targetName","doc":"Return the provided target name or autogenerate one if one was not provided. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L818-L824","name":"ToAdditive.guessName","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.guessName","doc":"Autogenerate additive name.\nThis runs in several steps:\n1) Split according to capitalisation rule and at `_`.\n2) Apply word-by-word translation rules.\n3) Fix up abbreviations that are not word-by-word translations, like \"addComm\" or \"Nonneg\".\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L753-L809","name":"ToAdditive.fixAbbreviation","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.fixAbbreviation","doc":"There are a few abbreviations we use. For example \"Nonneg\" instead of \"ZeroLE\"\nor \"addComm\" instead of \"commAdd\".\nNote: The input to this function is case sensitive!\nTodo: A lot of abbreviations here are manual fixes and there might be room to\n      improve the naming logic to reduce the size of `fixAbbreviation`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L742-L744","name":"ToAdditive.applyNameDict","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyNameDict","doc":"Turn each element to lower-case, apply the `nameDict` and\ncapitalize the output like the input.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L710-L736","name":"ToAdditive.nameDict","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.nameDict","doc":"Dictionary used by `guessName` to autogenerate names.\n\nNote: `guessName` capitalizes first element of the output according to\ncapitalization of the input. Input and first element should therefore be lower-case,\n2nd element should be capitalized properly.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L699-L701","name":"ToAdditive.capitalizeFirstLike","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.capitalizeFirstLike","doc":"Capitalize First element of a list like `s`.\nNote that we need to capitalize multiple characters in some cases,\nin examples like `HMul` or `hAdd`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L693-L694","name":"ToAdditive.capitalizeLike","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.capitalizeLike","doc":"Capitalizes `s` char-by-char like `r`. If `s` is longer, it leaves the tail untouched. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L680-L690","name":"ToAdditive.capitalizeLikeAux","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.capitalizeLikeAux","doc":"Helper for `capitalizeLike`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L660-L677","name":"ToAdditive.firstMultiplicativeArg","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.firstMultiplicativeArg","doc":"Find the first argument of `nm` that has a multiplicative type-class on it.\nReturns 1 if there are no types with a multiplicative class as arguments.\nE.g. `Prod.Group` returns 1, and `Pi.One` returns 2.\nNote: we only consider the first argument of each type-class.\nE.g. `[Pow A N]` is a multiplicative type-class on `A`, not on `N`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L642-L651","name":"ToAdditive.additivizeLemmas","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additivizeLemmas","doc":"`runAndAdditivize names desc t` runs `t` on all elements of `names`\nand adds translations between the generated lemmas (the output of `t`).\n`names` must be non-empty. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L635-L637","name":"ToAdditive.warnParametricAttr","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.warnParametricAttr","doc":"Warn the user when the multiplicative declaration has a parametric attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L630-L632","name":"ToAdditive.warnAttr","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.warnAttr","doc":"Warn the user when the multiplicative declaration has a simple scoped attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L617-L627","name":"ToAdditive.warnExt","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.warnExt","doc":"Warn the user when the multiplicative declaration has an attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L609-L614","name":"ToAdditive.copyInstanceAttribute","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.copyInstanceAttribute","doc":"Copy the instance attribute in a `to_additive`\n\n[todo] it seems not to work when the `to_additive` is added as an attribute later. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L538-L604","name":"ToAdditive.transformDeclAux","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.transformDeclAux","doc":"transform the declaration `src` and all declarations `pre._proof_i` occurring in `src`\nusing the transforms dictionary.\n`replace_all`, `trace`, `ignore` and `reorder` are configuration options.\n`pre` is the declaration that got the `@[to_additive]` attribute and `tgt_pre` is the target of this\ndeclaration. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L525-L531","name":"ToAdditive.findAuxDecls","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.findAuxDecls","doc":"Returns a `NameSet` of all auxiliary constants in `e` that might have been generated\nwhen adding `pre` to the environment.\nExamples include `pre.match_5`, `Mathlib.MyFile._auxLemma.3` and\n`_private.Mathlib.MyFile.someOtherNamespace.someOtherDeclaration._eq_2`.\nThe last two examples may or may not have been generated by this declaration.\nThe last example may or may not be the equation lemma of a declaration with the `@[to_additive]`\nattribute. We will only translate it has the `@[to_additive]` attribute.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L496-L515","name":"ToAdditive.findTargetName","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.findTargetName","doc":"Find the target name of `pre` and all created auxiliary declarations. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L481-L493","name":"ToAdditive.updateDecl","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.updateDecl","doc":"Run applyReplacementFun on the given `srcDecl` to make a new declaration with name `tgt` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L474-L478","name":"ToAdditive.reorderLambda","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.reorderLambda","doc":"Reorder lambda-binders. See doc of `reorderAttr` for the interpretation of the argument "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L467-L471","name":"ToAdditive.reorderForall","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.reorderForall","doc":"Reorder pi-binders. See doc of `reorderAttr` for the interpretation of the argument "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L440-L464","name":"ToAdditive.expand","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.expand","doc":"`e.expand` eta-expands all expressions that have as head a constant `n` in\n`reorder`. They are expanded until they are applied to one more argument than the maximum in\n`reorder.find n`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L434-L435","name":"ToAdditive.etaExpandN","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.etaExpandN","doc":"Eta expands `e` at most `n` times."},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L360-L431","name":"ToAdditive.applyReplacementFun.aux","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyReplacementFun.aux","doc":"Implementation of `applyReplacementFun`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L352-L431","name":"ToAdditive.applyReplacementFun","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyReplacementFun","doc":"`applyReplacementFun e` replaces the expression `e` with its additive counterpart.\nIt translates each identifier (inductive type, defined function etc) in an expression, unless\n* The identifier occurs in an application with first argument `arg`; and\n* `test arg` is false.\nHowever, if `f` is in the dictionary `relevant`, then the argument `relevant.find f`\nis tested, instead of the first argument.\n\nIt will also reorder arguments of certain functions, using `reorderFn`:\ne.g. `g x₁ x₂ x₃ ... xₙ` becomes `g x₂ x₁ x₃ ... xₙ` if `reorderFn g = some [1]`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L337-L339","name":"ToAdditive.changeNumeral","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.changeNumeral","doc":"Change the numeral `nat_lit 1` to the numeral `nat_lit 0`.\nLeave all other expressions unchanged. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L330-L333","name":"List.swapFirstTwo","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#List.swapFirstTwo","doc":"Swap the first two elements of a list "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L325-L327","name":"ToAdditive.additiveTest","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additiveTest","doc":"`additiveTest e` tests whether the expression `e` contains no constant\n`nm` that is not applied to any arguments, and such that `translations.find?[nm] = none`.\nThis is used in `@[to_additive]` for deciding which subexpressions to transform: we only transform\nconstants if `additiveTest` applied to their first argument returns `true`.\nThis means we will replace expression applied to e.g. `α` or `α × β`, but not when applied to\ne.g. `ℕ` or `ℝ × α`.\nWe ignore all arguments specified by the `ignore` `NameMap`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L290-L313","name":"ToAdditive.additiveTestUnsafe.visit","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additiveTestUnsafe.visit","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L287-L314","name":"ToAdditive.additiveTestUnsafe","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additiveTestUnsafe","doc":"Implementation function for `additiveTest`.\nWe cache previous applications of the function, using the same method that `Expr.find?` uses,\nto avoid visiting the same subexpression many times. Note that we only need to cache the\nexpressions without taking the value of `inApp` into account, since `inApp` only matters when\nthe expression is a constant. However, for this reason we have to make sure that we never\ncache constant expressions, so that's why the `if`s in the implementation are in this order.\n\nNote that this function is still called many times by `applyReplacementFun`\nand we're not remembering the cache between these calls. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L273-L273","name":"ToAdditive.instReprConfig","kind":"instance","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.instReprConfig","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L272-L272","name":"ToAdditive.Config.existing","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.existing","doc":"An optional flag stating whether the additive declaration already exists.\nIf this flag is set but wrong about whether the additive declaration exists, `to_additive` will\nraise a linter error.\nNote: the linter will never raise an error for inductive types and structures. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L267-L267","name":"ToAdditive.Config.ref","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.ref","doc":"The `Syntax` element corresponding to the original multiplicative declaration\n(or the `to_additive` attribute if it is added later),\nwhich we need for adding definition ranges. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L263-L263","name":"ToAdditive.Config.attrs","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.attrs","doc":"The attributes which we want to give to both the multiplicative and additive versions.\nFor certain attributes (such as `simp` and `simps`) this will also add generated lemmas to the\ntranslation dictionary. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L259-L259","name":"ToAdditive.Config.reorder","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.reorder","doc":"The arguments that should be reordered by `to_additive`, using cycle notation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L257-L257","name":"ToAdditive.Config.allowAutoName","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.allowAutoName","doc":"If `allowAutoName` is `false` (default) then\n`@[to_additive]` will check whether the given name can be auto-generated. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L254-L254","name":"ToAdditive.Config.doc","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.doc","doc":"An optional doc string."},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L252-L252","name":"ToAdditive.Config.tgt","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.tgt","doc":"The name of the target (the additive declaration)."},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L250-L250","name":"ToAdditive.Config.trace","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.trace","doc":"View the trace of the to_additive procedure.\nEquivalent to `set_option trace.to_additive true`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L247-L273","name":"ToAdditive.Config","kind":"structure","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config","doc":"`Config` is the type of the arguments that can be provided to `to_additive`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L236-L244","name":"ToAdditive.insertTranslation","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.insertTranslation","doc":"Add a (multiplicative → additive) name translation to the translations map. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L232-L233","name":"ToAdditive.findTranslation?","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.findTranslation?","doc":"Get the multiplicative → additive translation for the given name. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L228-L229","name":"ToAdditive.translations","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.translations","doc":"Maps multiplicative names to their additive counterparts. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L203-L226","name":"ToAdditive.changeNumeralAttr","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.changeNumeralAttr","doc":"An attribute that stores all the declarations that deal with numeric literals on variable types.\n\nNumeral literals occur in expressions without type information, so in order to decide whether `1`\nneeds to be changed to `0`, the context around the numeral is relevant.\nMost numerals will be in an `OfNat.ofNat` application, though tactics can add numeral literals\ninside arbitrary functions. By default we assume that we do not change numerals, unless it is\nin a function application with the `to_additive_change_numeral` attribute.\n\n`@[to_additive_change_numeral n₁ ...]` should be added to all functions that take one or more\nnumerals as argument that should be changed if `additiveTest` succeeds on the first argument,\ni.e. when the numeral is only translated if the first argument is a variable\n(or consists of variables).\nThe arguments `n₁ ...` are the positions of the numeral arguments (starting counting from 1).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L174-L201","name":"ToAdditive.relevantArgAttr","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.relevantArgAttr","doc":"An attribute that is automatically added to declarations tagged with `@[to_additive]`, if needed.\n\nThis attribute tells which argument is the type where this declaration uses the multiplicative\nstructure. If there are multiple argument, we typically tag the first one.\nIf this argument contains a fixed type, this declaration will note be additivized.\nSee the Heuristics section of `to_additive.attr` for more details.\n\nIf a declaration is not tagged, it is presumed that the first argument is relevant.\n`@[to_additive]` uses the function `to_additive.first_multiplicative_arg` to automatically tag\ndeclarations. It is ok to update it manually if the automatic tagging made an error.\n\nImplementation note: we only allow exactly 1 relevant argument, even though some declarations\n(like `prod.group`) have multiple arguments with a multiplicative structure on it.\nThe reason is that whether we additivize a declaration is an all-or-nothing decision, and if\nwe will not be able to additivize declarations that (e.g.) talk about multiplication on `ℕ × α`\nanyway.\n\nWarning: interactions between this and the `(reorder := ...)` argument are not well-tested.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L152-L172","name":"ToAdditive.reorderAttr","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.reorderAttr","doc":"An attribute that stores all the declarations that needs their arguments reordered when\napplying `@[to_additive]`. It is applied automatically by the `(reorder := ...)` syntax of\n`to_additive`, and should not usually be added manually.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L135-L150","name":"ToAdditive.ignoreArgsAttr","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.ignoreArgsAttr","doc":"An attribute that tells `@[to_additive]` that certain arguments of this definition are not\ninvolved when using `@[to_additive]`.\nThis helps the heuristic of `@[to_additive]` by also transforming definitions if `ℕ` or another\nfixed type occurs as one of these arguments.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L127-L132","name":"ToAdditive.linter.toAdditiveExisting","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.toAdditiveExisting","doc":"Linter to check whether the user correctly specified that the additive declaration already\nexists "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L121-L125","name":"ToAdditive.linter.toAdditiveGenerateName","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.toAdditiveGenerateName","doc":"Linter to check that the `to_additive` attribute is not given manually "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L114-L119","name":"ToAdditive.linter.existingAttributeWarning","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.existingAttributeWarning","doc":"Linter, mostly used by `@[to_additive]`, that checks that the source declaration doesn't have\ncertain attributes "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L109-L112","name":"ToAdditive.linter.toAdditiveReorder","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.toAdditiveReorder","doc":"Linter to check that the `reorder` attribute is not given manually "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L80-L102","name":"String.splitCase","kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#String.splitCase","doc":"This function takes a String and splits it into separate parts based on the following\n(naming conventions)[https://github.com/leanprover-community/mathlib4/wiki#naming-convention].\n\nE.g. `#eval  \"InvHMulLEConjugate₂SMul_ne_top\".splitCase` yields\n`[\"Inv\", \"HMul\", \"LE\", \"Conjugate₂\", \"SMul\", \"_\", \"ne\", \"_\", \"top\"]`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L68-L71","name":"endCapitalNames","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#endCapitalNames","doc":"A set of strings of names that end in a capital letter.\n* If the string contains a lowercase letter, the string should be split between the first occurrence\n  of a lower-case letter followed by an upper-case letter.\n* If multiple strings have the same prefix, they should be grouped by prefix\n* In this case, the second list should be prefix-free\n  (no element can be a prefix of a later element)\n\nTodo: automate the translation from `String` to an element in this `RBMap`\n  (but this would require having something similar to the `rb_lmap` from Lean 3). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L57-L57","name":"attrTo_additive?_","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#attrTo_additive?_","doc":"The `to_additive` attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L53-L54","name":"to_additive","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#to_additive","doc":"The `to_additive` attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L51-L52","name":"toAdditiveRest","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#toAdditiveRest","doc":"Remaining arguments of `to_additive`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L49-L50","name":"toAdditiveOption","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#toAdditiveOption","doc":"Options to `to_additive`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L47-L48","name":"toAdditiveParenthesizedOption","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#toAdditiveParenthesizedOption","doc":"Options to `to_additive`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L45-L46","name":"toAdditiveReorderOption","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#toAdditiveReorderOption","doc":"A `reorder := ...` option for `to_additive`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L43-L44","name":"toAdditiveAttrOption","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#toAdditiveAttrOption","doc":"An `attr := ...` option for `to_additive`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L41-L42","name":"to_additive_change_numeral","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#to_additive_change_numeral","doc":"The  `to_additive_change_numeral` attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L39-L40","name":"to_additive_reorder","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#to_additive_reorder","doc":"The  `to_additive_reorder` attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L37-L38","name":"to_additive_relevant_arg","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#to_additive_relevant_arg","doc":"The  `to_additive_relevant_arg` attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L35-L36","name":"to_additive_ignore_args","kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#to_additive_ignore_args","doc":"The  `to_additive_ignore_args` attribute. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/ToAdditive.lean#L1-L1","name":"ToAdditive.Config.mk","kind":"ctor","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.mk","doc":""}]}