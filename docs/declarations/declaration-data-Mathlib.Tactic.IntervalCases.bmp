{"name":"Mathlib.Tactic.IntervalCases","instances":[],"imports":["Init","Mathlib.Tactic.NormNum","Mathlib.Tactic.FinCases","Mathlib.Data.Set.Intervals.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L331-L353","name":"Mathlib.Tactic.intervalCases","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.intervalCases","doc":"`interval_cases n` searches for upper and lower bounds on a variable `n`,\nand if bounds are found,\nsplits into separate cases for each possible value of `n`.\n\nAs an example, in\n```\nexample (n : ℕ) (w₁ : n ≥ 3) (w₂ : n < 5) : n = 3 ∨ n = 4 := by\n  interval_cases n\n  all_goals simp\n```\nafter `interval_cases n`, the goals are `3 = 3 ∨ 3 = 4` and `4 = 3 ∨ 4 = 4`.\n\nYou can also explicitly specify a lower and upper bound to use,\nas `interval_cases using hl, hu`.\nThe hypotheses should be in the form `hl : a ≤ n` and `hu : n < b`,\nin which case `interval_cases` calls `fin_cases` on the resulting fact `n ∈ Set.Ico a b`.\n\nYou can specify a name `h` for the new hypothesis,\nas `interval_cases h : n` or `interval_cases h : n using hl, hu`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L283-L325","name":"Mathlib.Tactic.IntervalCases.intervalCases","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.intervalCases","doc":"`intervalCases` proves goal `g` by splitting into cases for each integer between the given bounds.\n\nParameters:\n* `g`: the goal, which can have any type `⊢ tgt` (it works in both proofs and programs)\n* `e`: the scrutinee, the expression we are proving is bounded between integers\n* `e'`: a version of `e` used for error messages. (This is used by the `interval_cases` frontend\n  tactic because it uses a fresh variable for `e`, so it is more helpful to show the\n  pre-generalized expression in error messages.)\n* `lbs`: A list of candidate lower bound expressions.\n  The tactic will automatically pick the best lower bound it can find from the list.\n* `ubs`: A list of candidate upper bound expressions.\n  The tactic will automatically pick the best upper bound it can find from the list.\n* `mustUseBounds`: If true, the tactic will fail if it is unable to parse any of the\n  given `ubs` or `lbs` into bounds. If false (the default), these will be silently skipped\n  and an error message is only produced if we could not find any bounds (including those supplied\n  by the type itself, e.g. if we are working over `Nat` or `Fin n`).\n\nReturns an array of `IntervalCasesSubgoal`, one per subgoal. A subgoal has the following fields:\n* `rhs`: the numeral expression for this case\n* `value`: the integral value of `rhs`\n* `goal`: the subgoal of type `⊢ e = rhs → tgt`\n\nNote that this tactic does not perform any substitution or introduction steps -\nall subgoals are in the same context as `goal` itself.\n "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L245-L255","name":"Mathlib.Tactic.IntervalCases.intMethods","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.intMethods","doc":"A `Methods` implementation for `ℤ`.\nThis tells `interval_cases` how to work on integers. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L240-L241","name":"Int.le_sub_one_of_not_le","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Int.le_sub_one_of_not_le","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L238-L239","name":"Int.add_one_le_of_not_le","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Int.add_one_le_of_not_le","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L224-L236","name":"Mathlib.Tactic.IntervalCases.natMethods","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.natMethods","doc":"A `Methods` implementation for `ℕ`.\nThis tells `interval_cases` how to work on natural numbers. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L200-L220","name":"Mathlib.Tactic.IntervalCases.Methods.bisect","kind":"opaque","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.bisect","doc":"Given `(z1, e1, p1)` a lower bound on `e` and `(z2, e2, p2)` an upper bound on `e`, such that the\ndistance between the bounds matches the number of `cases` in the subarray (which must be positive),\nproves the goal `g` using the metavariables in the array by recursive bisection.\nThis is the core of the tactic, producing a case tree of if statements which bottoms out\nat the `cases`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L177-L191","name":"Mathlib.Tactic.IntervalCases.Methods.inconsistentBounds","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.inconsistentBounds","doc":"Given `(z1, e1, p1)` a lower bound on `e` and `(z2, e2, p2)` an upper bound on `e`,\nsuch that the distance between the bounds is negative, returns a proof of `False`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L170-L171","name":"Mathlib.Tactic.IntervalCases.le_of_not_le_of_le","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.le_of_not_le_of_le","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L148-L168","name":"Mathlib.Tactic.IntervalCases.Methods.getBound","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.getBound","doc":"Given a proof `pf`, attempts to parse it as an upper (`lb = false`) or lower (`lb = true`)\nbound on `n`. If successful, it returns `(bound, n, pf')` where `n` is a numeral and\n`pf'` proves `n ≤ e` or `n ≱ e` (as described by `bound`).\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L141-L141","name":"Mathlib.Tactic.IntervalCases.of_le_right","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_le_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L140-L140","name":"Mathlib.Tactic.IntervalCases.of_le_left","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_le_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L139-L139","name":"Mathlib.Tactic.IntervalCases.of_lt_right","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_lt_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L138-L138","name":"Mathlib.Tactic.IntervalCases.of_lt_left","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_lt_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L137-L137","name":"Mathlib.Tactic.IntervalCases.of_not_le_right","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_le_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L136-L136","name":"Mathlib.Tactic.IntervalCases.of_not_le_left","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_le_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L135-L135","name":"Mathlib.Tactic.IntervalCases.of_not_lt_right","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_lt_right","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L134-L134","name":"Mathlib.Tactic.IntervalCases.of_not_lt_left","kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_lt_left","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L132-L132","name":"Mathlib.Tactic.IntervalCases.Methods.mkNumeral","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.mkNumeral","doc":"Construct the canonical numeral for integer `z`, or fail if `z` is out of range. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L130-L130","name":"Mathlib.Tactic.IntervalCases.Methods.eval","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.eval","doc":"Given `e`, return `(z, n, p)` where `p : e = n` and `n` is a numeral\nappropriate for the type denoting the integer `z`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L127-L127","name":"Mathlib.Tactic.IntervalCases.Methods.roundDown","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.roundDown","doc":"Given `a, b, b', p` where `p` proves `a ≱ b` and `b' := b-1`, prove `a ≤ b'`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L125-L125","name":"Mathlib.Tactic.IntervalCases.Methods.roundUp","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.roundUp","doc":"Given `a, b, a', p` where `p` proves `a ≱ b` and `a' := a+1`, prove `a' ≤ b`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L123-L123","name":"Mathlib.Tactic.IntervalCases.Methods.proveLT","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.proveLT","doc":"Given `a, b`, prove `a ≱ b` or fail. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L121-L121","name":"Mathlib.Tactic.IntervalCases.Methods.proveLE","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.proveLE","doc":"Given `a, b`, prove `a ≤ b` or fail. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L119-L119","name":"Mathlib.Tactic.IntervalCases.Methods.initUB","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.initUB","doc":"Given `e`, construct `(bound, n, p)` where `p` is a proof of `e ≤ n` or `e < n`\n(characterized by `bound`), or `failure` if the type is not upper-bounded. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L116-L116","name":"Mathlib.Tactic.IntervalCases.Methods.initLB","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.initLB","doc":"Given `e`, construct `(bound, n, p)` where `p` is a proof of `n ≤ e` or `n < e`\n(characterized by `bound`), or `failure` if the type is not lower-bounded. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L113-L132","name":"Mathlib.Tactic.IntervalCases.Methods","kind":"structure","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods","doc":"A \"typeclass\" (not actually a class) of methods for the type-specific handling of\n`interval_cases`. To add support for a new type, you have to implement this interface and add\na dispatch case for it in `intervalCases`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L95-L108","name":"Mathlib.Tactic.IntervalCases.parseBound","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.parseBound","doc":"Given a type `ty` (the type of a hypothesis in the context or a provided expression),\nattempt to parse it as an inequality, and return `(a, b, strict, positive)`, where\n`positive` means it is a negated inequality and `strict` means it is a strict inequality\n(`a < b` or `a ≱ b`). `a` is always the lesser argument and `b` the greater one.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L85-L87","name":"Mathlib.Tactic.IntervalCases.Bound.asUpper","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asUpper","doc":"Assuming `Bound` represents an upper bound, this returns the (inclusive)\ngreatest integer value which is allowed. So `e ≤ 3` means the lower bound is 3 and\n`e < 3` means the upper bound is `2`. Note that in the case of `e < 0` on `Nat`\nthe upper bound is `-1`, which is not representable as a `Nat`;\nthis is why we have to treat the `.lt` and `.le` cases separately instead of normalizing\neverything to `.le` bounds.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L73-L75","name":"Mathlib.Tactic.IntervalCases.Bound.asLower","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asLower","doc":"Assuming `Bound` represents a lower bound, this returns the (inclusive)\nleast integer value which is allowed. So `3 ≤ e` means the lower bound is 3 and\n`3 < e` means the lower bound is `4`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L65-L66","name":"Mathlib.Tactic.IntervalCases.Bound.le","kind":"ctor","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.le","doc":"A less-than-or-equal lower bound `n ≤ e` or upper bound `e ≤ n`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L61-L64","name":"Mathlib.Tactic.IntervalCases.Bound.lt","kind":"ctor","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.lt","doc":"A strictly less-than lower bound `n ≱ e` or upper bound `e ≱ n`. (`interval_cases` uses\nless-equal exclusively, so less-than bounds are actually written as not-less-equal\nwith flipped arguments.) "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L60-L66","name":"Mathlib.Tactic.IntervalCases.Bound","kind":"inductive","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound","doc":"A `Bound` represents the result of analyzing a lower or upper bound expression.\nIf `e` is the scrutinee expression, then a lower bound expression like `3 < e`\nis normalized to `¬e ≤ 3` and represented as `.lt 3`, and an upper bound expression\nlike `e ≤ 5` is represented as `.le 5`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L52-L52","name":"Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.goal","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.goal","doc":"The new subgoal, of the form `⊢ x = rhs → tgt` "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L50-L50","name":"Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.value","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.value","doc":"The numeric value of the target expression "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L48-L48","name":"Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.rhs","kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.rhs","doc":"The target expression, a numeral in the input type "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L46-L52","name":"Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal","kind":"structure","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal","doc":"The result of `interval_cases` is a list of goals,\none for each integer value between the bounds. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L1-L1","name":"Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.mk","kind":"ctor","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/IntervalCases.lean#L1-L1","name":"Mathlib.Tactic.IntervalCases.Methods.mk","kind":"ctor","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.mk","doc":""}]}