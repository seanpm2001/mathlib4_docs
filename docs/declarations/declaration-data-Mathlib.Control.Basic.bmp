{"name":"Mathlib.Control.Basic","instances":[{"typeNames":["Sum"],"name":"Sum.instMonadSum","className":"Monad"},{"typeNames":["Sum","Applicative.toFunctor","Sum","Monad.toApplicative","Sum.instMonadSum"],"name":"Sum.instLawfulFunctorSumToFunctorToApplicativeInstMonadSum","className":"LawfulFunctor"},{"typeNames":["Sum","Sum.instMonadSum"],"name":"Sum.instLawfulMonadSumInstMonadSum","className":"LawfulMonad"}],"imports":["Init","Mathlib.Control.SimpSet","Mathlib.Init.Control.Combinators","Mathlib.Tactic.CasesM"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L267-L275","name":"CommApplicative.commutative_map","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#CommApplicative.commutative_map","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L259-L259","name":"CommApplicative.commutative_prod","kind":"def","docLink":"./Mathlib/Control/Basic.html#CommApplicative.commutative_prod","doc":"Computations performed first on `a : α` and then on `b : β` are equal to those performed in\nthe reverse order. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L256-L256","name":"CommApplicative.mk","kind":"ctor","docLink":"./Mathlib/Control/Basic.html#CommApplicative.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L256-L260","name":"CommApplicative","kind":"class","docLink":"./Mathlib/Control/Basic.html#CommApplicative","doc":"A `CommApplicative` functor `m` is a (lawful) applicative functor which behaves identically on\n`α × β` and `β × α`, so computations can occur in either order. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L229-L250","name":"Sum.instLawfulMonadSumInstMonadSum","kind":"instance","docLink":"./Mathlib/Control/Basic.html#Sum.instLawfulMonadSumInstMonadSum","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L226-L227","name":"Sum.instLawfulFunctorSumToFunctorToApplicativeInstMonadSum","kind":"instance","docLink":"./Mathlib/Control/Basic.html#Sum.instLawfulFunctorSumToFunctorToApplicativeInstMonadSum","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L222-L224","name":"Sum.instMonadSum","kind":"instance","docLink":"./Mathlib/Control/Basic.html#Sum.instMonadSum","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L216-L218","name":"Sum.bind","kind":"def","docLink":"./Mathlib/Control/Basic.html#Sum.bind","doc":"The monadic `bind` operation for `Sum`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L205-L206","name":"guard_false","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#guard_false","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L201-L201","name":"guard_true","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#guard_true","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L197-L198","name":"try?","kind":"def","docLink":"./Mathlib/Control/Basic.html#try?","doc":"Attempts to perform the computation, and returns `none` if it doesn't succeed. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L192-L193","name":"tryM","kind":"def","docLink":"./Mathlib/Control/Basic.html#tryM","doc":"Attempts to perform the computation, but fails silently if it doesn't succeed. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L187-L188","name":"succeeds","kind":"def","docLink":"./Mathlib/Control/Basic.html#succeeds","doc":"Returns `pure true` if the computation succeeds and `pure false` otherwise. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L175-L176","name":"joinM_pure","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#joinM_pure","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L170-L171","name":"joinM_map_pure","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#joinM_map_pure","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L165-L166","name":"joinM_map_joinM","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#joinM_map_joinM","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L160-L162","name":"joinM_map_map","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#joinM_map_map","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L146-L151","name":"List.mapAccumLM","kind":"def","docLink":"./Mathlib/Control/Basic.html#List.mapAccumLM","doc":"Takes a value `β` and `List α` and accumulates pairs according to a monadic function `f`.\nAccumulation occurs from the left (i.e., starting from the head of the list). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L136-L141","name":"List.mapAccumRM","kind":"def","docLink":"./Mathlib/Control/Basic.html#List.mapAccumRM","doc":"Takes a value `β` and `List α` and accumulates pairs according to a monadic function `f`.\nAccumulation occurs from the right (i.e., starting from the tail of the list). "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L125-L127","name":"fish_assoc","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#fish_assoc","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L120-L120","name":"fish_pipe","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#fish_pipe","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L116-L116","name":"fish_pure","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#fish_pure","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L106-L109","name":"seq_bind_eq","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#seq_bind_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L101-L103","name":"map_bind","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#map_bind","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L93-L98","name":"List.partitionM","kind":"def","docLink":"./Mathlib/Control/Basic.html#List.partitionM","doc":"A generalization of `List.partition` which partitions the list according to a monadic\npredicate. `List.partition` corresponds to the case where `f = Id`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L75-L77","name":"map_seq","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#map_seq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L67-L71","name":"seq_map_assoc","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#seq_map_assoc","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L60-L61","name":"pure_id'_seq","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#pure_id'_seq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L49-L52","name":"zipWithM'","kind":"def","docLink":"./Mathlib/Control/Basic.html#zipWithM'","doc":"Like `zipWithM` but evaluates the result as it traverses the lists using `*>`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L43-L45","name":"zipWithM","kind":"def","docLink":"./Mathlib/Control/Basic.html#zipWithM","doc":"A generalization of `List.zipWith` which combines list elements with an `Applicative`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Control/Basic.lean#L27-L28","name":"Functor.map_map","kind":"theorem","docLink":"./Mathlib/Control/Basic.html#Functor.map_map","doc":""}]}