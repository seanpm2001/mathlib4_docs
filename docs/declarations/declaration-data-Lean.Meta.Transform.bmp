{"name":"Lean.Meta.Transform","instances":[],"imports":["Init","Lean.Meta.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L165-L166","name":"Lean.Meta.erasePatternRefAnnotations","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Meta.erasePatternRefAnnotations","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L162-L163","name":"Lean.Meta.eraseInaccessibleAnnotations","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Meta.eraseInaccessibleAnnotations","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L143-L160","name":"Lean.Meta.unfoldDeclsFrom","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Meta.unfoldDeclsFrom","doc":"Unfold definitions and theorems in `e` that are not in the current environment, but are in `biggerEnv`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L128-L140","name":"Lean.Meta.zetaReduce","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Meta.zetaReduce","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L104-L109","name":"Lean.Meta.transform.visit.visitLet","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitLet","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L98-L103","name":"Lean.Meta.transform.visit.visitForall","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L92-L97","name":"Lean.Meta.transform.visit.visitLambda","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitLambda","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L87-L91","name":"Lean.Meta.transform.visit.visitPost","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitPost","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L85-L125","name":"Lean.Meta.transform.visit","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L77-L126","name":"Lean.Meta.transform","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform","doc":"Similar to `Core.transform`, but terms provided to `pre` and `post` do not contain loose bound variables.\nSo, it is safe to use any `MetaM` method at `pre` and `post`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L67-L68","name":"Lean.Core.betaReduce","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Core.betaReduce","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L47-L51","name":"Lean.Core.transform.visit.visitPost","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform.visit.visitPost","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L45-L64","name":"Lean.Core.transform.visit","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L38-L65","name":"Lean.Core.transform","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform","doc":"Transform the expression `input` using `pre` and `post`.\n- First `pre` is invoked with the current expression and recursion is continued according to the `TransformStep` result.\n  In all cases, the expression contained in the result, if any, must be definitionally equal to the current expression.\n- After recursion, if any, `post` is invoked on the resulting expression.\n\nThe term `s` in both `pre s` and `post s` may contain loose bound variables. So, this method is not appropriate for\nif one needs to apply operations (e.g., `whnf`, `inferType`) that do not handle loose bound variables.\nConsider using `Meta.transform` to avoid loose bound variables.\n\nThis method is useful for applying transformations such as beta-reduction and delta-reduction.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L18-L22","name":"Lean.TransformStep.continue","kind":"ctor","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.continue","doc":"Continue transformation with the given expression (defaults to current expression).\nFor `pre`, this means visiting the children of the expression.\nFor `post`, this is equivalent to returning `done`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L13-L17","name":"Lean.TransformStep.visit","kind":"ctor","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.visit","doc":"Visit expression (which should be different from current expression) instead.\nThe new expression `e` is passed to `pre` again.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L11-L12","name":"Lean.TransformStep.done","kind":"ctor","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.done","doc":"Return expression without visiting any subexpressions. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/a44dd71ad62a1760e32b0e8a12449e560ddcf492/src/Lean/Meta/Transform.lean#L10-L22","name":"Lean.TransformStep","kind":"inductive","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep","doc":""}]}