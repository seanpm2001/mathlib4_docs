{"name":"Mathlib.Tactic.NormNum.Core","instances":[{"typeNames":["Mathlib.Meta.NormNum.Result'"],"name":"Mathlib.Meta.NormNum.instInhabitedResult'","className":"Inhabited"},{"typeNames":["Mathlib.Meta.NormNum.Result"],"name":"Mathlib.Meta.NormNum.instInhabitedResult","className":"Inhabited"},{"typeNames":["Mathlib.Meta.NormNum.Result"],"name":"Mathlib.Meta.NormNum.instToMessageDataResult","className":"Lean.ToMessageData"},{"typeNames":["Mathlib.Meta.NormNum.NormNums"],"name":"Mathlib.Meta.NormNum.instInhabitedNormNums","className":"Inhabited"}],"imports":["Init","Std.Lean.Parser","Std.Lean.Meta.DiscrTree","Mathlib.Algebra.Invertible","Mathlib.Data.Rat.Cast","Mathlib.Data.Nat.Basic","Mathlib.Data.Int.Basic","Mathlib.Tactic.Conv","Mathlib.Util.Qq"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L898-L900","name":"Mathlib.Tactic.normNumCmd","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.normNumCmd","doc":"The basic usage is `#norm_num e`, where `e` is an expression,\nwhich will print the `norm_num` form of `e`.\n\nSyntax: `#norm_num` (`only`)? (`[` simp lemma list `]`)? `:`? expression\n\nThis accepts the same options as the `#simp` command.\nYou can specify additional simp lemmas as usual, for example using `#norm_num [f, g] : e`.\n(The colon is optional but helpful for the parser.)\nThe `only` restricts `norm_num` to using only the provided lemmas, and so\n`#norm_num only : e` behaves similarly to `norm_num1`.\n\nUnlike `norm_num`, this command does not fail when no simplifications are made.\n\n`#norm_num` understands local variables, so you can use them to introduce parameters.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L878-L880","name":"Mathlib.Tactic.elabNormNumConv","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.elabNormNumConv","doc":"Elaborator for `norm_num` conv tactic. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L875-L875","name":"Mathlib.Tactic.normNumConv","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.normNumConv","doc":"Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `⁻¹` `^` and `%`\nover numerical types such as `ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,\nand can prove goals of the form `A = B`, `A ≠ B`, `A < B` and `A ≤ B`, where `A` and `B` are\nnumerical expressions. It also has a relatively simple primality prover.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L871-L873","name":"Mathlib.Tactic.elabNormNum1Conv","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.elabNormNum1Conv","doc":"Elaborator for `norm_num1` conv tactic. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L868-L868","name":"Mathlib.Tactic.normNum1Conv","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.normNum1Conv","doc":"Basic version of `norm_num` that does not call `simp`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L862-L864","name":"Mathlib.Tactic.normNum1","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.normNum1","doc":"Basic version of `norm_num` that does not call `simp`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L853-L860","name":"Mathlib.Tactic.normNum","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.normNum","doc":"Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `⁻¹` `^` and `%`\nover numerical types such as `ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,\nand can prove goals of the form `A = B`, `A ≠ B`, `A < B` and `A ≤ B`, where `A` and `B` are\nnumerical expressions. It also has a relatively simple primality prover.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L837-L846","name":"Mathlib.Meta.NormNum.elabNormNum","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.elabNormNum","doc":"Elaborates a call to `norm_num only? [args]` or `norm_num1`.\n* `args`: the `(simpArgs)?` syntax for simp arguments\n* `loc`: the `(location)?` syntax for the optional location argument\n* `simpOnly`: true if `only` was used in `norm_num`\n* `useSimp`: false if `norm_num1` was used, in which case only the structural parts\n  of `simp` will be used, not any of the post-processing that `simp only` does without lemmas\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L814-L825","name":"Mathlib.Meta.NormNum.getSimpContext","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.getSimpContext","doc":"Constructs a simp context from the simp argument syntax. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L773-L809","name":"Mathlib.Meta.NormNum.normNumAt","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.normNumAt","doc":"The core of `norm_num` as a tactic in `MetaM`.\n\n* `g`: The goal to simplify\n* `ctx`: The simp context, constructed by `mkSimpContext` and\n  containing any additional simp rules we want to use\n* `fvarIdsToSimp`: The selected set of hypotheses used in the location argument\n* `simplifyTarget`: true if the target is selected in the location argument\n* `useSimp`: true if we used `norm_num` instead of `norm_num1`\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L758-L759","name":"Mathlib.Meta.NormNum.deriveSimp","kind":"opaque","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.deriveSimp","doc":"Traverses the given expression using simp and normalises any numbers it finds. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L744-L755","name":"Mathlib.Meta.NormNum.methods","kind":"opaque","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.methods","doc":"A `Methods` implementation which calls `norm_num`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L741-L741","name":"Mathlib.Meta.NormNum.discharge","kind":"opaque","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.discharge","doc":"A discharger which calls `norm_num`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L730-L736","name":"Lean.Meta.Simp.Result.ofTrue","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Lean.Meta.Simp.Result.ofTrue","doc":"Constructs a proof that the original expression is true\ngiven a simp result which simplifies the target to `True`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L722-L724","name":"Mathlib.Meta.NormNum.tryNormNum?","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.tryNormNum?","doc":"A simp plugin which calls `NormNum.eval`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L689-L693","name":"Mathlib.Meta.NormNum.NormNums.erase","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNums.erase","doc":"Erase a name marked as a `norm_num` attribute.\n\nCheck that it does in fact have the `norm_num` attribute by making sure it names a `NormNumExt`\nfound somewhere in the state's tree, and is not erased.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L680-L681","name":"Mathlib.Meta.NormNum.NormNums.eraseCore","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNums.eraseCore","doc":"Erases a name marked `norm_num` by adding it to the state's `erased` field and\nremoving it from the state's list of `Entry`s. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L673-L676","name":"Mathlib.Meta.NormNum.eval","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.eval","doc":"Run each registered `norm_num` extension on an expression,\nreturning a `Simp.Result`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L666-L669","name":"Mathlib.Meta.NormNum.isNormalForm","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.isNormalForm","doc":"Test if an expression represents an explicit number written in normal form. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L658-L663","name":"Mathlib.Meta.NormNum.deriveBoolOfIff","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.deriveBoolOfIff","doc":"Run each registered `norm_num` extension on a typed expression `p : Prop`,\nand returning the truth or falsity of `p' : Prop` from an equivalence `p ↔ p'`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L652-L654","name":"Mathlib.Meta.NormNum.Result.ofBoolResult","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.ofBoolResult","doc":"Obtain a `Result` from a `BoolResult`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L647-L649","name":"Mathlib.Meta.NormNum.deriveBool","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.deriveBool","doc":"Run each registered `norm_num` extension on a typed expression `p : Prop`,\nand returning the truth or falsity of `p' : Prop` from an equivalence `p ↔ p'`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L642-L643","name":"Mathlib.Meta.NormNum.BoolResult","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.BoolResult","doc":"Given `Mathlib.Meta.NormNum.Result.isBool p b`, this is the type of `p`.\nNote that `BoolResult p b` is definitionally equal to `Expr`, and if you write `match b with ...`,\nthen in the `true` branch `BoolResult p true` is reducibly equal to `Q($p)` and\nin the `false` branch it is reducibly equal to `Q(¬ $p)`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L626-L635","name":"Mathlib.Meta.NormNum.isRatLit","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.isRatLit","doc":"Extract the numerator `n : ℤ` and denominator `d : ℕ` if the expression is either\nan integer literal, or the division of one integer literal by another. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L618-L622","name":"Mathlib.Meta.NormNum.isIntLit","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.isIntLit","doc":"Extract the integer `i` if the expression is either a natural number literal\nor the negation of one. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L611-L614","name":"Mathlib.Meta.NormNum.isNatLit","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.isNatLit","doc":"Extract the natural number `n` if the expression is of the form `OfNat.ofNat n`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L604-L608","name":"Mathlib.Meta.NormNum.deriveRat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.deriveRat","doc":"Run each registered `norm_num` extension on a typed expression `e : α`,\nreturning a rational number, typed expressions `n : ℚ` and `d : ℚ` for the numerator and\ndenominator, and a proof of `IsRat e n d` in expression form. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L595-L599","name":"Mathlib.Meta.NormNum.deriveInt","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.deriveInt","doc":"Run each registered `norm_num` extension on a typed expression `e : α`,\nreturning a typed expression `lit : ℤ`, and a proof of `IsInt e lit` in expression form. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L587-L591","name":"Mathlib.Meta.NormNum.deriveNat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.deriveNat","doc":"Run each registered `norm_num` extension on a typed expression `e : α`,\nreturning a typed expression `lit : ℕ`, and a proof of `isNat e lit`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L580-L583","name":"Mathlib.Meta.NormNum.deriveNat'","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.deriveNat'","doc":"Run each registered `norm_num` extension on a typed expression `e : α`,\nreturning a typed expression `lit : ℕ`, and a proof of `isNat e lit`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L558-L576","name":"Mathlib.Meta.NormNum.derive","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.derive","doc":"Run each registered `norm_num` extension on an expression, returning a `NormNum.Result`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L543-L555","name":"Mathlib.Meta.NormNum.normNumExt","kind":"opaque","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.normNumExt","doc":"Environment extensions for `norm_num` declarations "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L541-L541","name":"Mathlib.Meta.NormNum.instInhabitedNormNums","kind":"instance","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instInhabitedNormNums","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L540-L540","name":"Mathlib.Meta.NormNum.NormNums.erased","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNums.erased","doc":"Erased `norm_num`s. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L538-L538","name":"Mathlib.Meta.NormNum.NormNums.tree","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNums.tree","doc":"The tree of `norm_num` extensions. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L536-L541","name":"Mathlib.Meta.NormNum.NormNums","kind":"structure","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNums","doc":"The state of the `norm_num` extension environment "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L533-L533","name":"Mathlib.Meta.NormNum.Entry","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Entry","doc":"Each `norm_num` extension is labelled with a collection of patterns\nwhich determine the expressions to which it should be applied. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L527-L529","name":"Mathlib.Meta.NormNum.mkNormNumExt","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.mkNormNumExt","doc":"Read a `norm_num` extension from a declaration of the right type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L524-L524","name":"Mathlib.Meta.NormNum.NormNumExt.name","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt.name","doc":"The name of the `norm_num` extension. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L522-L522","name":"Mathlib.Meta.NormNum.NormNumExt.eval","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt.eval","doc":"Attempts to prove an expression is equal to some explicit number of the relevant type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L520-L520","name":"Mathlib.Meta.NormNum.NormNumExt.post","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt.post","doc":"The extension should be run in the `post` phase when used as simp plugin. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L518-L518","name":"Mathlib.Meta.NormNum.NormNumExt.pre","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt.pre","doc":"The extension should be run in the `pre` phase when used as simp plugin. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L516-L524","name":"Mathlib.Meta.NormNum.NormNumExt","kind":"structure","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt","doc":"An extension for `norm_num`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L492-L511","name":"Mathlib.Meta.NormNum.Result.toSimpResult","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.toSimpResult","doc":"Convert a `Result` to a `Simp.Result`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L468-L489","name":"Mathlib.Meta.NormNum.mkOfNat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.mkOfNat","doc":"Constructs an `ofNat` application `a'` with the canonical instance, together with a proof that\nthe instance is equal to the result of `Nat.cast` on the given `AddMonoidWithOne` instance.\n\nThis function is performance-critical, as many higher level tactics have to construct numerals.\nSo rather than using typeclass search we hardcode the (relatively small) set of solutions\nto the typeclass problem.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L454-L458","name":"Mathlib.Meta.NormNum.Result.toRatNZ","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.toRatNZ","doc":"Returns the rational number that is the result of `norm_num` evaluation, along with a proof\nthat the denominator is nonzero in the `isRat` case. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L444-L450","name":"Mathlib.Meta.NormNum.Result.isRat'","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.isRat'","doc":"The result depends on whether `q : ℚ` happens to be an integer, in which case the result is\n`.isInt ..` whereas otherwise it's `.isRat ..`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L433-L440","name":"Mathlib.Meta.NormNum.Result.ofRawRat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.ofRawRat","doc":"Constructs a `Result` out of a raw rat cast.\nAssumes `e` is a raw rat cast expression denoting `n`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L424-L429","name":"Mathlib.Meta.NormNum.Result.ofRawInt","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.ofRawInt","doc":"Constructs a `Result` out of a raw int cast.\nAssumes `e` is a raw int cast expression denoting `n`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L418-L420","name":"Mathlib.Meta.NormNum.Result.ofRawNat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.ofRawNat","doc":"Constructs a `Result` out of a raw nat cast. Assumes `e` is a raw nat cast expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L411-L415","name":"Mathlib.Meta.NormNum.Result.toRawIntEq","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.toRawIntEq","doc":"`Result.toRawEq` but providing an integer. Given a `NormNum.Result e` for something known to be an\ninteger (which uses `IsNat` or `IsInt` to express equality to an integer numeral), converts it to\nan equality `e = Nat.rawCast n` or `e = Int.rawCast n` to a raw cast expression, so it can be used\nfor rewriting. Gives `none` if not an integer.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L394-L403","name":"Mathlib.Meta.NormNum.Result.toRawEq","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.toRawEq","doc":"Given a `NormNum.Result e` (which uses `IsNat`, `IsInt`, `IsRat` to express equality to a rational\nnumeral), converts it to an equality `e = Nat.rawCast n`, `e = Int.rawCast n`, or\n`e = Rat.rawCast n d` to a raw cast expression, so it can be used for rewriting.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L381-L387","name":"Mathlib.Meta.NormNum.instToMessageDataResult","kind":"instance","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instToMessageDataResult","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L368-L379","name":"Mathlib.Meta.NormNum.Result.toRat'","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.toRat'","doc":"Extract from a `Result` the rational value (as both a term and an expression),\nand the proof that the original expression is equal to this rational number.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L356-L362","name":"Mathlib.Meta.NormNum.Result.toInt","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.toInt","doc":"Extract from a `Result` the integer value (as both a term and an expression),\nand the proof that the original expression is equal to this integer.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L349-L350","name":"Mathlib.Meta.NormNum.inferRatCast","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferRatCast","doc":"Helper function to synthesize a typed `RatCast α` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L344-L346","name":"Mathlib.Meta.NormNum.inferCharZeroOfDivisionRing?","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferCharZeroOfDivisionRing?","doc":"Helper function to synthesize a typed `CharZero α` expression given `DivisionRing α`, if it\nexists. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L338-L340","name":"Mathlib.Meta.NormNum.inferOfScientific","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferOfScientific","doc":"Helper function to synthesize a typed `OfScientific α` expression given `DivisionRing α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L332-L335","name":"Mathlib.Meta.NormNum.inferCharZeroOfDivisionRing","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferCharZeroOfDivisionRing","doc":"Helper function to synthesize a typed `CharZero α` expression given `DivisionRing α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L326-L329","name":"Mathlib.Meta.NormNum.inferCharZeroOfAddMonoidWithOne?","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferCharZeroOfAddMonoidWithOne?","doc":"Helper function to synthesize a typed `CharZero α` expression given `AddMonoidWithOne α`, if it\nexists. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L319-L322","name":"Mathlib.Meta.NormNum.inferCharZeroOfAddMonoidWithOne","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferCharZeroOfAddMonoidWithOne","doc":"Helper function to synthesize a typed `CharZero α` expression given `AddMonoidWithOne α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L314-L316","name":"Mathlib.Meta.NormNum.inferCharZeroOfRing?","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferCharZeroOfRing?","doc":"Helper function to synthesize a typed `CharZero α` expression given `Ring α`, if it exists. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L308-L311","name":"Mathlib.Meta.NormNum.inferCharZeroOfRing","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferCharZeroOfRing","doc":"Helper function to synthesize a typed `CharZero α` expression given `Ring α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L303-L305","name":"Mathlib.Meta.NormNum.inferLinearOrderedField","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferLinearOrderedField","doc":"Helper function to synthesize a typed `LinearOrderedField α` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L299-L300","name":"Mathlib.Meta.NormNum.inferOrderedRing","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferOrderedRing","doc":"Helper function to synthesize a typed `OrderedRing α` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L294-L296","name":"Mathlib.Meta.NormNum.inferOrderedSemiring","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferOrderedSemiring","doc":"Helper function to synthesize a typed `OrderedSemiring α` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L290-L291","name":"Mathlib.Meta.NormNum.inferDivisionRing","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferDivisionRing","doc":"Helper function to synthesize a typed `DivisionRing α` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L286-L287","name":"Mathlib.Meta.NormNum.inferRing","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferRing","doc":"Helper function to synthesize a typed `Ring α` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L282-L283","name":"Mathlib.Meta.NormNum.inferSemiring","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferSemiring","doc":"Helper function to synthesize a typed `Semiring α` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L277-L279","name":"Mathlib.Meta.NormNum.inferAddMonoidWithOne","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.inferAddMonoidWithOne","doc":"Helper function to synthesize a typed `AddMonoidWithOne α` expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L272-L274","name":"Lean.LOption.toOption","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Lean.LOption.toOption","doc":"Convert `undef` to `none` to make an `LOption` into an `Option`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L263-L267","name":"Mathlib.Meta.NormNum.Result.toRat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.toRat","doc":"Returns the rational number that is the result of `norm_num` evaluation. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L253-L260","name":"Mathlib.Meta.NormNum.Result.isInt","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.isInt","doc":"The result is `z : ℤ` and `proof : isNat x z`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L248-L248","name":"Mathlib.Meta.NormNum.instRing","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instRing","doc":"A shortcut (non)instance for `Ring α` from `DivisionRing α` to shrink generated proofs. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L245-L245","name":"Mathlib.Meta.NormNum.instAddMonoidWithOne'","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instAddMonoidWithOne'","doc":"A shortcut (non)instance for `AddMonoidWithOne α` from `DivisionRing α` to shrink generated\nproofs. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L241-L241","name":"Mathlib.Meta.NormNum.instAddMonoidWithOne","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instAddMonoidWithOne","doc":"A shortcut (non)instance for `AddMonoidWithOne α` from `Ring α` to shrink generated proofs. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L236-L238","name":"Mathlib.Meta.NormNum.Result.isRat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.isRat","doc":"The result is `proof : isRat x n d`, where `n` is either `.ofNat lit` or `.negOfNat lit`\nwith `lit` a raw nat literal and `d` is a raw nat literal (not 0 or 1),\nand `q` is the value of `n / d`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L229-L231","name":"Mathlib.Meta.NormNum.Result.isNegNat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.isNegNat","doc":"The result is `-lit` where `lit` is a raw nat literal\nand `proof : isInt x (.negOfNat lit)`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L223-L225","name":"Mathlib.Meta.NormNum.Result.isNat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.isNat","doc":"The result is `lit : ℕ` (a raw nat literal) and `proof : isNat x lit`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L219-L220","name":"Mathlib.Meta.NormNum.Result.isFalse","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.isFalse","doc":"The result is `proof : ¬x`, where `x` is a (false) proposition. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L215-L216","name":"Mathlib.Meta.NormNum.Result.isTrue","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result.isTrue","doc":"The result is `proof : x`, where `x` is a (true) proposition. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L212-L212","name":"Mathlib.Meta.NormNum.instInhabitedResult","kind":"instance","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instInhabitedResult","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L210-L210","name":"Mathlib.Meta.NormNum.Result","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result","doc":"The result of `norm_num` running on an expression `x` of type `α`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L204-L204","name":"Mathlib.Meta.NormNum.instInhabitedResult'","kind":"instance","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instInhabitedResult'","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L202-L203","name":"Mathlib.Meta.NormNum.Result'.isRat","kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result'.isRat","doc":"Untyped version of `Result.isRat`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L200-L201","name":"Mathlib.Meta.NormNum.Result'.isNegNat","kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result'.isNegNat","doc":"Untyped version of `Result.isNegNat`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L198-L199","name":"Mathlib.Meta.NormNum.Result'.isNat","kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result'.isNat","doc":"Untyped version of `Result.isNat`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L196-L197","name":"Mathlib.Meta.NormNum.Result'.isBool","kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result'.isBool","doc":"Untyped version of `Result.isBool`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L195-L204","name":"Mathlib.Meta.NormNum.Result'","kind":"inductive","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.Result'","doc":"The result of `norm_num` running on an expression `x` of type `α`.\nUntyped version of `Result`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L191-L191","name":"Mathlib.Meta.NormNum.instDivisionRingRat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instDivisionRingRat","doc":"A shortcut (non)instance for `DivisionRing ℚ` to shrink generated proofs. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L188-L188","name":"Mathlib.Meta.NormNum.instRingRat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instRingRat","doc":"A shortcut (non)instance for `Ring ℚ` to shrink generated proofs. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L182-L185","name":"Mathlib.Meta.NormNum.mkRawRatLit","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.mkRawRatLit","doc":"Represent an integer as a typed expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L178-L179","name":"Mathlib.Meta.NormNum.IsRat.den_nz","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsRat.den_nz","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L173-L176","name":"Mathlib.Meta.NormNum.IsRat.of_raw","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsRat.of_raw","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L169-L171","name":"Mathlib.Meta.NormNum.IsRat.nonneg_to_eq","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsRat.nonneg_to_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L165-L167","name":"Mathlib.Meta.NormNum.IsRat.neg_to_eq","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsRat.neg_to_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L162-L163","name":"Mathlib.Meta.NormNum.IsRat.to_raw_eq","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsRat.to_raw_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L159-L160","name":"Mathlib.Meta.NormNum.IsInt.to_isRat","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsInt.to_isRat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L156-L157","name":"Mathlib.Meta.NormNum.IsRat.to_isInt","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsRat.to_isInt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L153-L154","name":"Mathlib.Meta.NormNum.IsNat.to_isRat","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsNat.to_isRat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L150-L151","name":"Mathlib.Meta.NormNum.IsRat.to_isNat","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsRat.to_isNat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L148-L148","name":"Rat.rawCast","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Rat.rawCast","doc":"A \"raw rat cast\" is an expression of the form:\n\n* `(Nat.rawCast lit : α)` where `lit` is a raw natural number literal\n* `(Int.rawCast (Int.negOfNat lit) : α)` where `lit` is a nonzero raw natural number literal\n* `(Rat.rawCast n d : α)` where `n` is a raw int cast, `d` is a raw nat cast, and `d` is not 1 or 0.\n\nThis representation is used by tactics like `ring` to decrease the number of typeclass arguments\nrequired in each use of a number literal at type `α`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L135-L135","name":"Mathlib.Meta.NormNum.IsRat.mk","kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsRat.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L134-L135","name":"Mathlib.Meta.NormNum.IsRat","kind":"inductive","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsRat","doc":"Assert that an element of a ring is equal to `num / denom`\n(and `denom` is invertible so that this makes sense).\nWe will usually also have `num` and `denom` coprime,\nalthough this is not part of the definition.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L126-L126","name":"Mathlib.Meta.NormNum.instRingInt","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instRingInt","doc":"A shortcut (non)instance for `Ring ℤ` to shrink generated proofs. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L123-L123","name":"Mathlib.Meta.NormNum.instAddMonoidWithOneNat","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.instAddMonoidWithOneNat","doc":"A shortcut (non)instance for `AddMonoidWithOne ℕ` to shrink generated proofs. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L112-L120","name":"Mathlib.Meta.NormNum.rawIntLitNatAbs","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.rawIntLitNatAbs","doc":"Extract the raw natlit representing the absolute value of a raw integer literal\n(of the type produced by `Mathlib.Meta.NormNum.mkRawIntLit`) along with an equality proof. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L102-L108","name":"Lean.Expr.intLit!","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Lean.Expr.intLit!","doc":"Extract the integer from a raw integer literal, as produced by\n`Mathlib.Meta.NormNum.mkRawIntLit`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L96-L98","name":"Mathlib.Meta.NormNum.mkRawIntLit","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.mkRawIntLit","doc":"Represent an integer as a typed expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L92-L93","name":"Mathlib.Meta.NormNum.IsInt.nonneg_to_eq","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsInt.nonneg_to_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L88-L90","name":"Mathlib.Meta.NormNum.IsInt.neg_to_eq","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsInt.neg_to_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L86-L86","name":"Mathlib.Meta.NormNum.IsInt.of_raw","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsInt.of_raw","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L83-L84","name":"Mathlib.Meta.NormNum.IsInt.to_raw_eq","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsInt.to_raw_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L80-L81","name":"Mathlib.Meta.NormNum.IsNat.to_isInt","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsNat.to_isInt","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L77-L78","name":"Mathlib.Meta.NormNum.IsInt.to_isNat","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsInt.to_isNat","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L75-L75","name":"Int.rawCast","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Int.rawCast","doc":"A \"raw int cast\" is an expression of the form:\n\n* `(Nat.rawCast lit : α)` where `lit` is a raw natural number literal\n* `(Int.rawCast (Int.negOfNat lit) : α)` where `lit` is a nonzero raw natural number literal\n\n(That is, we only actually use this function for negative integers.) This representation is used by\ntactics like `ring` to decrease the number of typeclass arguments required in each use of a number\nliteral at type `α`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L63-L63","name":"Mathlib.Meta.NormNum.IsInt.out","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsInt.out","doc":"The element is equal to the coercion of the integer. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L61-L61","name":"Mathlib.Meta.NormNum.IsInt.mk","kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsInt.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L61-L63","name":"Mathlib.Meta.NormNum.IsInt","kind":"structure","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsInt","doc":"Assert that an element of a ring is equal to the coercion of some integer. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L57-L58","name":"Mathlib.Meta.NormNum.isNat.natElim","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.isNat.natElim","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L54-L54","name":"Mathlib.Meta.NormNum.IsNat.of_raw","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsNat.of_raw","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L51-L52","name":"Mathlib.Meta.NormNum.IsNat.to_raw_eq","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsNat.to_raw_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L48-L49","name":"Mathlib.Meta.NormNum.IsNat.to_eq","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsNat.to_eq","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L46-L46","name":"Nat.rawCast","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Nat.rawCast","doc":"A \"raw nat cast\" is an expression of the form `(Nat.rawCast lit : α)` where `lit` is a raw\nnatural number literal. These expressions are used by tactics like `ring` to decrease the number\nof typeclass arguments required in each use of a number literal at type `α`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L39-L39","name":"Mathlib.Meta.NormNum.IsNat.raw_refl","kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsNat.raw_refl","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L37-L37","name":"Mathlib.Meta.NormNum.IsNat.out","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsNat.out","doc":"The element is equal to the coercion of the natural number. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L35-L35","name":"Mathlib.Meta.NormNum.IsNat.mk","kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsNat.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L35-L37","name":"Mathlib.Meta.NormNum.IsNat","kind":"structure","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.IsNat","doc":"Assert that an element of a semiring is equal to the coercion of some natural number. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L26-L27","name":"norm_num","kind":"def","docLink":"./Mathlib/Tactic/NormNum/Core.html#norm_num","doc":"Attribute for identifying `norm_num` extensions. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L1-L1","name":"Mathlib.Meta.NormNum.NormNums.mk","kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNums.mk","doc":""},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/NormNum/Core.lean#L1-L1","name":"Mathlib.Meta.NormNum.NormNumExt.mk","kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt.mk","doc":""}]}