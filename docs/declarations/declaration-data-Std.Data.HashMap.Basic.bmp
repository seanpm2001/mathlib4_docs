{"name":"Std.Data.HashMap.Basic","instances":[{"typeNames":["Std.HashMap"],"name":"Std.HashMap.instInhabitedHashMap","className":"Inhabited"},{"typeNames":["Std.HashMap"],"name":"Std.HashMap.instEmptyCollectionHashMap","className":"EmptyCollection"},{"typeNames":["Std.HashMap","Option","Std.HashMap","True"],"name":"Std.HashMap.instGetElemHashMapOptionTrue","className":"GetElem"}],"imports":["Init","Std.Data.AssocList","Std.Data.Nat.Basic","Std.Classes.BEq"],"declarations":[{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L367-L371","name":"Std.HashMap.ofListWith","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.ofListWith","doc":"Variant of `ofList` which accepts a function that combines values of duplicated keys. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L363-L364","name":"Std.HashMap.ofList","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.ofList","doc":"Builds a `HashMap` from a list of key-value pairs.\nValues of duplicated keys are replaced by their respective last occurrences.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L357-L357","name":"Std.HashMap.numBuckets","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.numBuckets","doc":"The number of buckets in the hash map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L353-L354","name":"Std.HashMap.toArray","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.toArray","doc":"Converts the map into an array of key-value pairs. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L350-L350","name":"Std.HashMap.toList","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.toList","doc":"Converts the map into a list of key-value pairs. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L347-L347","name":"Std.HashMap.forM","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.forM","doc":"Runs a monadic function over the elements in the map (in arbitrary order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L338-L344","name":"Std.HashMap.mergeWith","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.mergeWith","doc":"Combines two hashmaps using function `f` to combine two values at a key. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L330-L335","name":"Std.HashMap.mergeWithM","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.mergeWithM","doc":"Combines two hashmaps using a monadic function `f` to combine two values at a key. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L327-L327","name":"Std.HashMap.fold","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.fold","doc":"Folds a function over the elements in the map (in arbitrary order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L323-L324","name":"Std.HashMap.foldM","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.foldM","doc":"Folds a monadic function over the elements in the map (in arbitrary order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L320-L320","name":"Std.HashMap.contains","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.contains","doc":"Returns true if the element `a` is in the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L316-L317","name":"Std.HashMap.instGetElemHashMapOptionTrue","kind":"instance","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.instGetElemHashMapOptionTrue","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L313-L314","name":"Std.HashMap.find!","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.find!","doc":"Looks up an element in the map with key `a`. Panics if the element is not found. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L310-L310","name":"Std.HashMap.findD","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.findD","doc":"Looks up an element in the map with key `a`. Returns `b₀` if the element is not found. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L307-L307","name":"Std.HashMap.find?","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.find?","doc":"Looks up an element in the map with key `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L304-L304","name":"Std.HashMap.findEntry?","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.findEntry?","doc":"Given a key `a`, returns a key-value pair in the map whose key compares equal to `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L300-L301","name":"Std.HashMap.modify","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.modify","doc":"Performs an in-place edit of the value, ensuring that the value is used linearly.\nThe function `f` is passed the original key of the entry, along with the value in the map.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L294-L294","name":"Std.HashMap.erase","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.erase","doc":"Removes key `a` from the map. If it does not exist in the map, the map is returned unchanged.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L285-L289","name":"Std.HashMap.insert'","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.insert'","doc":"Similar to `insert`, but also returns a boolean flag indicating whether an existing entry has been\nreplaced with `a ↦ b`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L279-L279","name":"Std.HashMap.insert","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.insert","doc":"Inserts key-value pair `a, b` into the map.\nIf an element equal to `a` is already in the map, it is replaced by `b`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L273-L273","name":"Std.HashMap.isEmpty","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.isEmpty","doc":"Is the map empty? "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L270-L270","name":"Std.HashMap.size","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.size","doc":"The number of elements in the hash map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L265-L265","name":"Std.HashMap.empty","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.empty","doc":"Make a new empty hash map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L262-L262","name":"Std.HashMap.instEmptyCollectionHashMap","kind":"instance","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.instEmptyCollectionHashMap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L259-L260","name":"Std.HashMap.instInhabitedHashMap","kind":"instance","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.instInhabitedHashMap","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L256-L257","name":"Std.mkHashMap","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.mkHashMap","doc":"Make a new hash map with the specified capacity. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L251-L251","name":"Std.HashMap","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap","doc":"`HashMap α β` is a key-value map which stores elements in an array using a hash function\nto find the values. This allows it to have very good performance for lookups\n(average `O(1)` for a perfectly random hash function), but it is not a persistent data structure,\nmeaning that one should take care to use the map linearly when performing updates.\nCopies are `O(n)`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L240-L240","name":"Std.HashMap.Imp.WF.empty","kind":"theorem","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.WF.empty","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L237-L238","name":"Std.HashMap.Imp.WF.modify","kind":"ctor","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.WF.modify","doc":"Replacing an element in a well formed hash map yields a well formed hash map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L235-L236","name":"Std.HashMap.Imp.WF.erase","kind":"ctor","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.WF.erase","doc":"Removing an element from a well formed hash map yields a well formed hash map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L233-L234","name":"Std.HashMap.Imp.WF.insert","kind":"ctor","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.WF.insert","doc":"Inserting into a well formed hash map yields a well formed hash map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L231-L232","name":"Std.HashMap.Imp.WF.empty'","kind":"ctor","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.WF.empty'","doc":"The empty hash map is well formed. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L226-L230","name":"Std.HashMap.Imp.WF.mk","kind":"ctor","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.WF.mk","doc":"The real well-formedness invariant:\n* The `size` field should match the actual number of elements in the map\n* The bucket array should be well-formed, meaning that if the hashable instance\n  is lawful then every element hashes to its index. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L225-L238","name":"Std.HashMap.Imp.WF","kind":"inductive","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.WF","doc":"The well-formedness invariant for a hash map. The first constructor is the real invariant,\nand the others allow us to \"cheat\" in this file and define `insert` and `erase`,\nwhich have more complex proofs that are delayed to `Std.Data.HashMap.Lemmas`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L217-L218","name":"Std.HashMap.Imp.filter","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.filter","doc":"Constructs a map with the set of all pairs `a, b` such that `f` returns true. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L210-L214","name":"Std.HashMap.Imp.filterMap.go","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.filterMap.go","doc":"Inner loop of `filterMap`. Note that this reverses the bucket lists,\nbut this is fine since bucket lists are unordered. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L199-L214","name":"Std.HashMap.Imp.filterMap","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.filterMap","doc":"Applies `f` to each key-value pair `a, b` in the map. If it returns `some c` then\n`a, c` is pushed into the new map; else the key is removed from the map.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L188-L193","name":"Std.HashMap.Imp.modify","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.modify","doc":"Performs an in-place edit of the value, ensuring that the value is used linearly. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L184-L185","name":"Std.HashMap.Imp.mapVal","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.mapVal","doc":"Map a function over the values in the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L177-L181","name":"Std.HashMap.Imp.erase","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.erase","doc":"Removes key `a` from the map. If it does not exist in the map, the map is returned unchanged.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L160-L172","name":"Std.HashMap.Imp.insert","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.insert","doc":"Inserts key-value pair `a, b` into the map.\nIf an element equal to `a` is already in the map, it is replaced by `b`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L144-L153","name":"Std.HashMap.Imp.expand.go","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.expand.go","doc":"Inner loop of `expand`. Copies elements `source[i:]` into `target`,\ndestroying `source` in the process. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L138-L154","name":"Std.HashMap.Imp.expand","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.expand","doc":"Copies all the entries from `buckets` into a new hash map with a larger capacity. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L132-L135","name":"Std.HashMap.Imp.contains","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.contains","doc":"Returns true if the element `a` is in the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L126-L129","name":"Std.HashMap.Imp.find?","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.find?","doc":"Looks up an element in the map with key `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L120-L123","name":"Std.HashMap.Imp.findEntry?","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.findEntry?","doc":"Given a key `a`, returns a key-value pair in the map whose key compares equal to `a`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L116-L117","name":"Std.HashMap.Imp.forM","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.forM","doc":"Runs a monadic function over the elements in the map (in arbitrary order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L112-L113","name":"Std.HashMap.Imp.fold","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.fold","doc":"Folds a function over the elements in the map (in arbitrary order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L108-L109","name":"Std.HashMap.Imp.foldM","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.foldM","doc":"Folds a monadic function over the elements in the map (in arbitrary order). "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L102-L105","name":"Std.HashMap.Imp.reinsertAux","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.reinsertAux","doc":"Inserts a key-value pair into the bucket array. This function assumes that the data is not\nalready in the array, which is appropriate when reinserting elements into the array after a resize.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L95-L96","name":"Std.HashMap.Imp.mkIdx","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.mkIdx","doc":"Calculates the bucket index from a hash value `u`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L87-L92","name":"Std.HashMap.Imp.empty","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.empty","doc":"Constructs an empty hash map with the specified target capacity. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L83-L84","name":"Std.HashMap.Imp.empty'","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.empty'","doc":"Constructs an empty hash map with the specified nonzero number of buckets. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L79-L80","name":"Std.HashMap.Imp.numBucketsForCapacity","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.numBucketsForCapacity","doc":"Given a desired capacity, this returns the number of buckets we should reserve.\nA \"load factor\" of 0.75 is the usual standard for hash maps, so we return `capacity * 4 / 3`.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L71-L71","name":"Std.HashMap.Imp.buckets","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.buckets","doc":"The bucket array of the `HashMap`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L69-L69","name":"Std.HashMap.Imp.size","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.size","doc":"The number of elements stored in the `HashMap`.\nWe cache this both so that we can implement `.size` in `O(1)`, and also because we\nuse the size to determine when to resize the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L65-L65","name":"Std.HashMap.Imp.mk","kind":"ctor","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.mk","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L65-L71","name":"Std.HashMap.Imp","kind":"structure","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp","doc":"`HashMap.Imp α β` is the internal implementation type of `HashMap α β`. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L58-L58","name":"Std.HashMap.Imp.Bucket.WF.hash_self","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.Bucket.WF.hash_self","doc":"Every element in a bucket should hash to its location. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L55-L55","name":"Std.HashMap.Imp.Bucket.WF.distinct","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.Bucket.WF.distinct","doc":"The elements of a bucket are all distinct according to the `BEq` relation. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L53-L53","name":"Std.HashMap.Imp.Bucket.WF.mk","kind":"ctor","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.Bucket.WF.mk","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L53-L59","name":"Std.HashMap.Imp.Bucket.WF","kind":"structure","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.Bucket.WF","doc":"The well-formedness invariant for the bucket array says that every element hashes to its index\n(assuming the hash is lawful - otherwise there are no promises about where elements are located).\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L46-L47","name":"Std.HashMap.Imp.Bucket.mapVal","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.Bucket.mapVal","doc":"Map a function over the values in the map. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L42-L43","name":"Std.HashMap.Imp.Bucket.update_size","kind":"theorem","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.Bucket.update_size","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L40-L40","name":"Std.HashMap.Imp.Bucket.size","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.Bucket.size","doc":"The number of elements in the bucket array.\nNote: this is marked `noncomputable` because it is only intended for specification.\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L32-L34","name":"Std.HashMap.Imp.Bucket.update","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.Bucket.update","doc":"Update one bucket in the bucket array with a new value. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L28-L29","name":"Std.HashMap.Imp.Bucket.mk","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.Bucket.mk","doc":"Construct a new empty bucket array with the specified capacity. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L23-L23","name":"Std.HashMap.Imp.Bucket","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.Imp.Bucket","doc":"The bucket array of a `HashMap` is a nonempty array of `AssocList`s.\n(This type is an internal implementation detail of `HashMap`.)\n"},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L15-L15","name":"Std.HashMap.LawfulHashable.hash_eq","kind":"def","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.LawfulHashable.hash_eq","doc":"Two elements which compare equal under the `BEq` instance have equal hash. "},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L13-L13","name":"Std.HashMap.LawfulHashable.mk","kind":"ctor","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.LawfulHashable.mk","doc":""},{"sourceLink":"https://github.com/leanprover/std4/blob/e68aa8f5fe47aad78987df45f99094afbcb5e936/Std/Data/HashMap/Basic.lean#L13-L15","name":"Std.HashMap.LawfulHashable","kind":"class","docLink":"./Std/Data/HashMap/Basic.html#Std.HashMap.LawfulHashable","doc":"A hash is lawful if elements which compare equal under `==` have equal hash. "}]}