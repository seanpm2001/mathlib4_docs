{"name":"Mathlib.Lean.Meta","instances":[],"imports":["Init","Lean.Elab","Lean.Meta.Tactic.Assert","Lean.Meta.Tactic.Clear","Std.Data.Option.Basic","Std.Data.List.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L187-L207","name":"Lean.Elab.Tactic.run_for","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.Elab.Tactic.run_for","doc":"Copy of `Lean.Elab.Tactic.run` that can return a value. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L174-L175","name":"Lean.Elab.Tactic.liftMetaFinishingTactic","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.Elab.Tactic.liftMetaFinishingTactic","doc":"Analogue of `liftMetaTactic` for tactics that do not return any goals. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L170-L171","name":"Lean.Elab.Tactic.liftMetaTactic'","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.Elab.Tactic.liftMetaTactic'","doc":"Analogue of `liftMetaTactic` for tactics that return a single goal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L160-L161","name":"Lean.MVarId.getType''","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.getType''","doc":"Get the type the given metavariable after instantiating metavariables and cleaning up\nannotations. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L154-L155","name":"Lean.Meta.mapForallTelescope","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.Meta.mapForallTelescope","doc":"Given a monadic function `F` that takes a term and produces a new term,\nlifts this to the monadic function that opens a `∀` telescope, applies `F` to the body,\nand then builds the lambda telescope term for the new term.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L145-L147","name":"Lean.Meta.mapForallTelescope'","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.Meta.mapForallTelescope'","doc":"Given a monadic function `F` that takes a type and a term of that type and produces a new term,\nlifts this to the monadic function that opens a `∀` telescope, applies `F` to the body,\nand then builds the lambda telescope term for the new term.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L136-L138","name":"Lean.Meta.countLocalHypsUsed","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.Meta.countLocalHypsUsed","doc":"Count how many local hypotheses appear in an expression. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L129-L133","name":"Lean.Meta.getLocalHyps","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.Meta.getLocalHyps","doc":"Return local hypotheses which are not \"implementation detail\", as `Expr`s. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L106-L122","name":"Lean.MVarId.independent?","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.independent?","doc":"Check if a goal is \"independent\" of a list of other goals.\nWe say a goal is independent of other goals if assigning a value to it\ncan not change the solvability of the other goals.\n\nThis function only calculates an approximation of this condition\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L92-L97","name":"Lean.MVarId.subsingleton?","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.subsingleton?","doc":"Check if a goal is of a subsingleton type. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L84-L89","name":"Lean.MVarId.intros!.run","kind":"opaque","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.intros!.run","doc":"Implementation of `intros!`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L80-L89","name":"Lean.MVarId.intros!","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.intros!","doc":"Applies `intro` repeatedly until it fails. We use this instead of\n`Lean.MVarId.intros` to allowing unfolding.\nFor example, if we want to do introductions for propositions like `¬p`,\nthe `¬` needs to be unfolded into `→ False`, and `intros` does not do such unfolding. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L67-L74","name":"Lean.MVarId.existsi","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.existsi","doc":"Has the effect of `refine ⟨e₁,e₂,⋯, ?_⟩`.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L62-L63","name":"Lean.MVarId.applyConst","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.applyConst","doc":"Short-hand for applying a constant to the goal. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L57-L59","name":"Lean.MVarId.let","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.let","doc":"Add the hypothesis `h : t`, given `v : t`, and return the new `FVarId`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L52-L54","name":"Lean.MVarId.note","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.note","doc":"Add the hypothesis `h : t`, given `v : t`, and return the new `FVarId`. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L42-L49","name":"Lean.MVarId.replace.findMaxFVar","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.replace.findMaxFVar","doc":"Finds the `LocalDecl` for the FVar in `e` with the highest index. "},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L29-L49","name":"Lean.MVarId.replace","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.replace","doc":"Replace hypothesis `hyp` in goal `g` with `proof : typeNew`.\nThe new hypothesis is given the same user name as the original,\nit attempts to avoid reordering hypotheses, and the original is cleared if possible.\n"},{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Lean/Meta.lean#L20-L21","name":"Lean.MVarId.synthInstance","kind":"def","docLink":"./Mathlib/Lean/Meta.html#Lean.MVarId.synthInstance","doc":"Solve a goal by synthesizing an instance. "}]}