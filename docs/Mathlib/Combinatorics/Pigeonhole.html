<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Combinatorics.Pigeonhole</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Combinatorics.Pigeonhole";</script><script type="module" src="../.././search.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Combinatorics</span>.<span class="name">Pigeonhole</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">Mathlib</span>.<span class="name">Combinatorics</span>.<span class="name">Pigeonhole</span></a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Algebra/BigOperators/Order.html">Mathlib.Algebra.BigOperators.Order</a></li><li><a href="../.././Mathlib/Algebra/Module/Basic.html">Mathlib.Algebra.Module.Basic</a></li><li><a href="../.././Mathlib/Algebra/Module/BigOperators.html">Mathlib.Algebra.Module.BigOperators</a></li><li><a href="../.././Mathlib/Data/Nat/ModEq.html">Mathlib.Data.Nat.ModEq</a></li><li><a href="../.././Mathlib/Data/Set/Finite.html">Mathlib.Data.Set.Finite</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Combinatorics.Pigeonhole" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum"><span class="name">Finset</span>.<span class="name">exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul"><span class="name">Finset</span>.<span class="name">exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum"><span class="name">Finset</span>.<span class="name">exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul"><span class="name">Finset</span>.<span class="name">exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum"><span class="name">Finset</span>.<span class="name">exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul"><span class="name">Finset</span>.<span class="name">exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum"><span class="name">Finset</span>.<span class="name">exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul"><span class="name">Finset</span>.<span class="name">exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to"><span class="name">Finset</span>.<span class="name">exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to"><span class="name">Finset</span>.<span class="name">exists_lt_card_fiber_of_mul_lt_card_of_maps_to</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_card_fiber_lt_of_card_lt_nsmul"><span class="name">Finset</span>.<span class="name">exists_card_fiber_lt_of_card_lt_nsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_card_fiber_lt_of_card_lt_mul"><span class="name">Finset</span>.<span class="name">exists_card_fiber_lt_of_card_lt_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_le_card_fiber_of_nsmul_le_card_of_maps_to"><span class="name">Finset</span>.<span class="name">exists_le_card_fiber_of_nsmul_le_card_of_maps_to</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_le_card_fiber_of_mul_le_card_of_maps_to"><span class="name">Finset</span>.<span class="name">exists_le_card_fiber_of_mul_le_card_of_maps_to</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_card_fiber_le_of_card_le_nsmul"><span class="name">Finset</span>.<span class="name">exists_card_fiber_le_of_card_le_nsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.exists_card_fiber_le_of_card_le_mul"><span class="name">Finset</span>.<span class="name">exists_card_fiber_le_of_card_le_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_lt_sum_fiber_of_nsmul_lt_sum"><span class="name">Fintype</span>.<span class="name">exists_lt_sum_fiber_of_nsmul_lt_sum</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_le_sum_fiber_of_nsmul_le_sum"><span class="name">Fintype</span>.<span class="name">exists_le_sum_fiber_of_nsmul_le_sum</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_sum_fiber_lt_of_sum_lt_nsmul"><span class="name">Fintype</span>.<span class="name">exists_sum_fiber_lt_of_sum_lt_nsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_sum_fiber_le_of_sum_le_nsmul"><span class="name">Fintype</span>.<span class="name">exists_sum_fiber_le_of_sum_le_nsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_lt_card_fiber_of_nsmul_lt_card"><span class="name">Fintype</span>.<span class="name">exists_lt_card_fiber_of_nsmul_lt_card</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_lt_card_fiber_of_mul_lt_card"><span class="name">Fintype</span>.<span class="name">exists_lt_card_fiber_of_mul_lt_card</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_card_fiber_lt_of_card_lt_nsmul"><span class="name">Fintype</span>.<span class="name">exists_card_fiber_lt_of_card_lt_nsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_card_fiber_lt_of_card_lt_mul"><span class="name">Fintype</span>.<span class="name">exists_card_fiber_lt_of_card_lt_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_le_card_fiber_of_nsmul_le_card"><span class="name">Fintype</span>.<span class="name">exists_le_card_fiber_of_nsmul_le_card</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_le_card_fiber_of_mul_le_card"><span class="name">Fintype</span>.<span class="name">exists_le_card_fiber_of_mul_le_card</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_card_fiber_le_of_card_le_nsmul"><span class="name">Fintype</span>.<span class="name">exists_card_fiber_le_of_card_le_nsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Fintype.exists_card_fiber_le_of_card_le_mul"><span class="name">Fintype</span>.<span class="name">exists_card_fiber_le_of_card_le_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.exists_lt_modEq_of_infinite"><span class="name">Nat</span>.<span class="name">exists_lt_modEq_of_infinite</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Pigeonhole-principles">Pigeonhole principles <a class="hover-link" href="#Pigeonhole-principles">#</a></h1><p>Given pigeons (possibly infinitely many) in pigeonholes, the
pigeonhole principle states that, if there are more pigeons than
pigeonholes, then there is a pigeonhole with two or more pigeons.</p><p>There are a few variations on this statement, and the conclusion can
be made stronger depending on how many pigeons you know you might
have.</p><p>The basic statements of the pigeonhole principle appear in the
following locations:</p><ul>
<li><code>Data.Finset.Basic</code> has <code><a href="../.././Mathlib/Data/Finset/Card.html#Finset.exists_ne_map_eq_of_card_lt_of_maps_to">Finset.exists_ne_map_eq_of_card_lt_of_maps_to</a></code></li>
<li><code>Data.Fintype.Basic</code> has <code><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.exists_ne_map_eq_of_card_lt">Fintype.exists_ne_map_eq_of_card_lt</a></code></li>
<li><code>Data.Fintype.Basic</code> has <code><a href="../.././Mathlib/Data/Fintype/Card.html#Finite.exists_ne_map_eq_of_infinite">Finite.exists_ne_map_eq_of_infinite</a></code></li>
<li><code>Data.Fintype.Basic</code> has <code><a href="../.././Mathlib/Data/Fintype/Card.html#Finite.exists_infinite_fiber">Finite.exists_infinite_fiber</a></code></li>
<li><code>Data.Set.<a href="../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a></code> has <code>Set.infinite.exists_ne_map_eq_of_mapsTo</code></li>
</ul><p>This module gives access to these pigeonhole principles along with 20 more.
The versions vary by:</p><ul>
<li>using a function between <code><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a></code>s or a function between possibly infinite types restricted to
<code><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>s;</li>
<li>counting pigeons by a general weight function (<code>∑ x in s, w x</code>) or by heads (<code><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> s</code>);</li>
<li>using strict or non-strict inequalities;</li>
<li>establishing upper or lower estimate on the number (or the total weight) of the pigeons in one
pigeonhole;</li>
<li>in case when we count pigeons by some weight function <code>w</code> and consider a function <code>f</code> between
<code><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>s <code>s</code> and <code>t</code>, we can either assume that each pigeon is in one of the pigeonholes
(<code>∀ x ∈ s, f x ∈ t</code>), or assume that for <code>y ∉ t</code>, the total weight of the pigeons in this
pigeonhole <code>∑ x in s.filter (fun x ↦ f x = y), w x</code> is nonpositive or nonnegative depending on
the inequality we are proving.</li>
</ul><p>Lemma names follow <code>mathlib</code> convention (e.g.,
<code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum">Finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum</a></code>); "pigeonhole principle" is mentioned in the
docstrings instead of the names.</p><h2 class="markdown-heading" id="See-also">See also <a class="hover-link" href="#See-also">#</a></h2><ul>
<li>
<p><code>Ordinal.infinite_pigeonhole</code>: pigeonhole principle for cardinals, formulated using cofinality;</p>
</li>
<li>
<p><code>MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure</code>,
<code>MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_sum_measure</code>: pigeonhole principle in a
measure space.</p>
</li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>pigeonhole principle</p></div><div class="mod_doc"><h3 class="markdown-heading" id="The-pigeonhole-principles-on-Finsets-pigeons-counted-by-weight">The pigeonhole principles on <code><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>s, pigeons counted by weight <a class="hover-link" href="#The-pigeonhole-principles-on-Finsets-pigeons-counted-by-weight">#</a></h3><p>In this section we prove the following version of the pigeonhole principle: if the total weight of a
finite set of pigeons is greater than <code>n • b</code>, and they are sorted into <code>n</code> pigeonholes, then for
some pigeonhole, the total weight of the pigeons in this pigeonhole is greater than <code>b</code>, and a few
variations of this theorem.</p><p>The principle is formalized in the following way, see
<code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum">Finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum</a></code>: if <code>f : α → β</code> is a function which maps all
elements of <code>s : <a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> α</code> to <code>t : <a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> β</code> and <code>card t • b < ∑ x in s, w x</code>, where <code>w : α → M</code> is
a weight function taking values in a <code><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a></code>, then for
some <code>y ∈ t</code>, the sum of the weights of all <code>x ∈ s</code> such that <code>f x = y</code> is greater than <code>b</code>.</p><p>There are a few bits we can change in this theorem:</p><ul>
<li>reverse all inequalities, with obvious adjustments to the name;</li>
<li>replace the assumption <code>∀ a ∈ s, f a ∈ t</code> with
<code>∀ y ∉ t, (∑ x in s.filter (fun x ↦ f x = y), w x) ≤ 0</code>,
and replace <code>of_maps_to</code> with <code>of_sum_fiber_nonpos</code> in the name;</li>
<li>use non-strict inequalities assuming <code>t</code> is nonempty.</li>
</ul><p>We can do all these variations independently, so we have eight versions of the theorem.</p></div><div class="mod_doc"><h4 class="markdown-heading" id="Strict-inequality-versions">Strict inequality versions <a class="hover-link" href="#Strict-inequality-versions">#</a></h4></div><div class="decl" id="Finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L120-L122">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum"><span class="name">Finset</span>.<span class="name">exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">s</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:
if the total weight of a finite set of pigeons is greater than <code>n • b</code>, and they are sorted into
<code>n</code> pigeonholes, then for some pigeonhole, the total weight of the pigeons in this pigeonhole is
greater than <code>b</code>.</p></div></div><div class="decl" id="Finset.exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L129-L131">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul"><span class="name">Finset</span>.<span class="name">exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">s</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">b</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:
if the total weight of a finite set of pigeons is less than <code>n • b</code>, and they are sorted into <code>n</code>
pigeonholes, then for some pigeonhole, the total weight of the pigeons in this pigeonhole is less
than <code>b</code>.</p></div></div><div class="decl" id="Finset.exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L139-L146">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum"><span class="name">Finset</span>.<span class="name">exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(ht : <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span> → <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">0</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">s</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:
if the total weight of a finite set of pigeons is greater than <code>n • b</code>, they are sorted into some
pigeonholes, and for all but <code>n</code> pigeonholes the total weight of the pigeons there is nonpositive,
then for at least one of these <code>n</code> pigeonholes, the total weight of the pigeons in this pigeonhole
is greater than <code>b</code>.</p></div></div><div class="decl" id="Finset.exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L154-L157">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul"><span class="name">Finset</span>.<span class="name">exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(ht : <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span> → <span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">s</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">b</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:
if the total weight of a finite set of pigeons is less than <code>n • b</code>, they are sorted into some
pigeonholes, and for all but <code>n</code> pigeonholes the total weight of the pigeons there is nonnegative,
then for at least one of these <code>n</code> pigeonholes, the total weight of the pigeons in this pigeonhole
is less than <code>b</code>.</p></div></div><div class="mod_doc"><h4 class="markdown-heading" id="Non-strict-inequality-versions">Non-strict inequality versions <a class="hover-link" href="#Non-strict-inequality-versions">#</a></h4></div><div class="decl" id="Finset.exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L169-L171">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum"><span class="name">Finset</span>.<span class="name">exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">s</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality
version: if the total weight of a finite set of pigeons is greater than or equal to <code>n • b</code>, and
they are sorted into <code>n > 0</code> pigeonholes, then for some pigeonhole, the total weight of the pigeons
in this pigeonhole is greater than or equal to <code>b</code>.</p></div></div><div class="decl" id="Finset.exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L178-L180">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul"><span class="name">Finset</span>.<span class="name">exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">s</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality
version: if the total weight of a finite set of pigeons is less than or equal to <code>n • b</code>, and they
are sorted into <code>n > 0</code> pigeonholes, then for some pigeonhole, the total weight of the pigeons in
this pigeonhole is less than or equal to <code>b</code>.</p></div></div><div class="decl" id="Finset.exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L188-L195">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum"><span class="name">Finset</span>.<span class="name">exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span> → <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">0</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">s</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality
version: if the total weight of a finite set of pigeons is greater than or equal to <code>n • b</code>, they
are sorted into some pigeonholes, and for all but <code>n > 0</code> pigeonholes the total weight of the
pigeons there is nonpositive, then for at least one of these <code>n</code> pigeonholes, the total weight of
the pigeons in this pigeonhole is greater than or equal to <code>b</code>.</p></div></div><div class="decl" id="Finset.exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L203-L206">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul"><span class="name">Finset</span>.<span class="name">exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span> → <span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">s</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality
version: if the total weight of a finite set of pigeons is less than or equal to <code>n • b</code>, they are
sorted into some pigeonholes, and for all but <code>n > 0</code> pigeonholes the total weight of the pigeons
there is nonnegative, then for at least one of these <code>n</code> pigeonholes, the total weight of the
pigeons in this pigeonhole is less than or equal to <code>b</code>.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="The-pigeonhole-principles-on-Finsets-pigeons-counted-by-heads">The pigeonhole principles on <code><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>s, pigeons counted by heads <a class="hover-link" href="#The-pigeonhole-principles-on-Finsets-pigeons-counted-by-heads">#</a></h3><p>In this section we formalize a few versions of the following pigeonhole principle: there is a
pigeonhole with at least as many pigeons as the ceiling of the average number of pigeons across all
pigeonholes.</p><p>First, we can use strict or non-strict inequalities. While the versions with non-strict inequalities
are weaker than those with strict inequalities, sometimes it might be more convenient to apply the
weaker version. Second, we can either state that there exists a pigeonhole with at least <code>n</code>
pigeons, or state that there exists a pigeonhole with at most <code>n</code> pigeons. In the latter case we do
not need the assumption <code>∀ a ∈ s, f a ∈ t</code>.</p><p>So, we prove four theorems: <code>Finset.exists_lt_card_fiber_of_maps_to_of_mul_lt_card</code>,
<code>Finset.exists_le_card_fiber_of_maps_to_of_mul_le_card</code>,
<code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_card_fiber_lt_of_card_lt_mul">Finset.exists_card_fiber_lt_of_card_lt_mul</a></code>, and <code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_card_fiber_le_of_card_le_mul">Finset.exists_card_fiber_le_of_card_le_mul</a></code>.</p></div><div class="decl" id="Finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L233-L236">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to"><span class="name">Finset</span>.<span class="name">exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommSemiring">LinearOrderedCommSemiring</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">s</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>)</span>)</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with
at least as many pigeons as the ceiling of the average number of pigeons across all pigeonholes.</p></div></div><div class="decl" id="Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L246-L248">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to"><span class="name">Finset</span>.<span class="name">exists_lt_card_fiber_of_mul_lt_card_of_maps_to</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hn : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">n</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>)</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with
at least as many pigeons as the ceiling of the average number of pigeons across all pigeonholes.
("The maximum is at least the mean" specialized to integers.)</p><p>More formally, given a function between finite sets <code>s</code> and <code>t</code> and a natural number <code>n</code> such that
<code>card t * n < card s</code>, there exists <code>y ∈ t</code> such that its preimage in <code>s</code> has more than <code>n</code>
elements.</p></div></div><div class="decl" id="Finset.exists_card_fiber_lt_of_card_lt_nsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L253-L258">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_card_fiber_lt_of_card_lt_nsmul"><span class="name">Finset</span>.<span class="name">exists_card_fiber_lt_of_card_lt_nsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommSemiring">LinearOrderedCommSemiring</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(ht : <span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">s</span></span>)</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>)</span>)</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">b</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with
at most as many pigeons as the floor of the average number of pigeons across all pigeonholes.</p></div></div><div class="decl" id="Finset.exists_card_fiber_lt_of_card_lt_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L268-L270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_card_fiber_lt_of_card_lt_mul"><span class="name">Finset</span>.<span class="name">exists_card_fiber_lt_of_card_lt_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hn : <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>)</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">n</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with
at most as many pigeons as the floor of the average number of pigeons across all pigeonholes.  ("The
minimum is at most the mean" specialized to integers.)</p><p>More formally, given a function <code>f</code>, a finite sets <code>s</code> in its domain, a finite set <code>t</code> in its
codomain, and a natural number <code>n</code> such that <code>card s < card t * n</code>, there exists <code>y ∈ t</code> such that
its preimage in <code>s</code> has less than <code>n</code> elements.</p></div></div><div class="decl" id="Finset.exists_le_card_fiber_of_nsmul_le_card_of_maps_to"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L277-L280">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_le_card_fiber_of_nsmul_le_card_of_maps_to"><span class="name">Finset</span>.<span class="name">exists_le_card_fiber_of_nsmul_le_card_of_maps_to</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommSemiring">LinearOrderedCommSemiring</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">s</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>)</span>)</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by heads: given a function between
finite sets <code>s</code> and <code>t</code> and a number <code>b</code> such that <code>card t • b ≤ card s</code>, there exists <code>y ∈ t</code> such
that its preimage in <code>s</code> has at least <code>b</code> elements.
See also <code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to">Finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to</a></code> for a stronger statement.</p></div></div><div class="decl" id="Finset.exists_le_card_fiber_of_mul_le_card_of_maps_to"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L287-L289">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_le_card_fiber_of_mul_le_card_of_maps_to"><span class="name">Finset</span>.<span class="name">exists_le_card_fiber_of_mul_le_card_of_maps_to</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hn : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">n</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>)</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by heads: given a function between
finite sets <code>s</code> and <code>t</code> and a natural number <code>b</code> such that <code>card t * n ≤ card s</code>, there exists
<code>y ∈ t</code> such that its preimage in <code>s</code> has at least <code>n</code> elements. See also
<code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to">Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to</a></code> for a stronger statement.</p></div></div><div class="decl" id="Finset.exists_card_fiber_le_of_card_le_nsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L296-L301">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_card_fiber_le_of_card_le_nsmul"><span class="name">Finset</span>.<span class="name">exists_card_fiber_le_of_card_le_nsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommSemiring">LinearOrderedCommSemiring</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">s</span></span>)</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>)</span>)</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by heads: given a function <code>f</code>, a
finite sets <code>s</code> and <code>t</code>, and a number <code>b</code> such that <code>card s ≤ card t • b</code>, there exists <code>y ∈ t</code> such
that its preimage in <code>s</code> has no more than <code>b</code> elements.
See also <code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_card_fiber_lt_of_card_lt_nsmul">Finset.exists_card_fiber_lt_of_card_lt_nsmul</a></code> for a stronger statement.</p></div></div><div class="decl" id="Finset.exists_card_fiber_le_of_card_le_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L308-L310">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_card_fiber_le_of_card_le_mul"><span class="name">Finset</span>.<span class="name">exists_card_fiber_le_of_card_le_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hn : <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">s</span></span>)</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons counted by heads: given a function <code>f</code>, a
finite sets <code>s</code> in its domain, a finite set <code>t</code> in its codomain, and a natural number <code>n</code> such that
<code>card s ≤ card t * n</code>, there exists <code>y ∈ t</code> such that its preimage in <code>s</code> has no more than <code>n</code>
elements. See also <code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Finset.exists_card_fiber_lt_of_card_lt_mul">Finset.exists_card_fiber_lt_of_card_lt_mul</a></code> for a stronger statement.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="The-pigeonhole-principles-on-Fintypess-pigeons-counted-by-weight">The pigeonhole principles on <code>Fintypes</code>s, pigeons counted by weight <a class="hover-link" href="#The-pigeonhole-principles-on-Fintypess-pigeons-counted-by-weight">#</a></h3><p>In this section we specialize theorems from the previous section to the special case of functions
between <code><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a></code>s and <code>s = univ</code>, <code>t = univ</code>. In this case the assumption <code>∀ x ∈ s, f x ∈ t</code> always
holds, so we have four theorems instead of eight.</p></div><div class="decl" id="Fintype.exists_lt_sum_fiber_of_nsmul_lt_sum"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L336-L339">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_lt_sum_fiber_of_nsmul_lt_sum"><span class="name">Fintype</span>.<span class="name">exists_lt_sum_fiber_of_nsmul_lt_sum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">Finset.univ</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons of different weights, strict inequality
version: there is a pigeonhole with the total weight of pigeons in it greater than <code>b</code> provided that
the total number of pigeonholes times <code>b</code> is less than the total weight of all pigeons.</p></div></div><div class="decl" id="Fintype.exists_le_sum_fiber_of_nsmul_le_sum"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L346-L350">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_le_sum_fiber_of_nsmul_le_sum"><span class="name">Fintype</span>.<span class="name">exists_le_sum_fiber_of_nsmul_le_sum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">Finset.univ</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons of different weights, non-strict inequality
version: there is a pigeonhole with the total weight of pigeons in it greater than or equal to <code>b</code>
provided that the total number of pigeonholes times <code>b</code> is less than or equal to the total weight of
all pigeons.</p></div></div><div class="decl" id="Fintype.exists_sum_fiber_lt_of_sum_lt_nsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L356-L358">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_sum_fiber_lt_of_sum_lt_nsmul"><span class="name">Fintype</span>.<span class="name">exists_sum_fiber_lt_of_sum_lt_nsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">Finset.univ</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">b</span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons of different weights, strict inequality
version: there is a pigeonhole with the total weight of pigeons in it less than <code>b</code> provided that
the total number of pigeonholes times <code>b</code> is greater than the total weight of all pigeons.</p></div></div><div class="decl" id="Fintype.exists_sum_fiber_le_of_sum_le_nsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L365-L367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_sum_fiber_le_of_sum_le_nsmul"><span class="name">Fintype</span>.<span class="name">exists_sum_fiber_le_of_sum_le_nsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><span class="fn">α</span> → <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Cancel/Defs.html#LinearOrderedCancelAddCommMonoid">LinearOrderedCancelAddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> <span class="fn">Finset.univ</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn">(<span class="fn"><a href="../.././Mathlib/Algebra/BigOperators/Basic.html#Finset.sum">Finset.sum</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">w</span> <span class="fn">x</span></span></span></span>) <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span></span></div></div><p>The pigeonhole principle for finitely many pigeons of different weights, non-strict inequality
version: there is a pigeonhole with the total weight of pigeons in it less than or equal to <code>b</code>
provided that the total number of pigeonholes times <code>b</code> is greater than or equal to the total weight
of all pigeons.</p></div></div><div class="decl" id="Fintype.exists_lt_card_fiber_of_nsmul_lt_card"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L377-L380">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_lt_card_fiber_of_nsmul_lt_card"><span class="name">Fintype</span>.<span class="name">exists_lt_card_fiber_of_nsmul_lt_card</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommSemiring">LinearOrderedCommSemiring</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>)</span>)</span></span></span></div></div><p>The strong pigeonhole principle for finitely many pigeons and pigeonholes. There is a pigeonhole
with at least as many pigeons as the ceiling of the average number of pigeons across all
pigeonholes.</p></div></div><div class="decl" id="Fintype.exists_lt_card_fiber_of_mul_lt_card"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L391-L393">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_lt_card_fiber_of_mul_lt_card"><span class="name">Fintype</span>.<span class="name">exists_lt_card_fiber_of_mul_lt_card</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hn : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn">n</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>)</span></span></span></div></div><p>The strong pigeonhole principle for finitely many pigeons and pigeonholes.
There is a pigeonhole with at least as many pigeons as
the ceiling of the average number of pigeons across all pigeonholes.
("The maximum is at least the mean" specialized to integers.)</p><p>More formally, given a function <code>f</code> between finite types <code>α</code> and <code>β</code> and a number <code>n</code> such that
<code>card β * n < card α</code>, there exists an element <code>y : β</code> such that its preimage has more than <code>n</code>
elements.</p></div></div><div class="decl" id="Fintype.exists_card_fiber_lt_of_card_lt_nsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L399-L402">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_card_fiber_lt_of_card_lt_nsmul"><span class="name">Fintype</span>.<span class="name">exists_card_fiber_lt_of_card_lt_nsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommSemiring">LinearOrderedCommSemiring</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span>)</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>)</span>)</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">b</span></span></span></div></div><p>The strong pigeonhole principle for finitely many pigeons and pigeonholes. There is a pigeonhole
with at most as many pigeons as the floor of the average number of pigeons across all pigeonholes.</p></div></div><div class="decl" id="Fintype.exists_card_fiber_lt_of_card_lt_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L413-L415">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_card_fiber_lt_of_card_lt_mul"><span class="name">Fintype</span>.<span class="name">exists_card_fiber_lt_of_card_lt_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hn : <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>)</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">n</span></span></span></div></div><p>The strong pigeonhole principle for finitely many pigeons and pigeonholes.
There is a pigeonhole with at most as many pigeons as
the floor of the average number of pigeons across all pigeonholes.
("The minimum is at most the mean" specialized to integers.)</p><p>More formally, given a function <code>f</code> between finite types <code>α</code> and <code>β</code> and a number <code>n</code> such that
<code>card α < card β * n</code>, there exists an element <code>y : β</code> such that its preimage has less than <code>n</code>
elements.</p></div></div><div class="decl" id="Fintype.exists_le_card_fiber_of_nsmul_le_card"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L422-L426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_le_card_fiber_of_nsmul_le_card"><span class="name">Fintype</span>.<span class="name">exists_le_card_fiber_of_nsmul_le_card</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommSemiring">LinearOrderedCommSemiring</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>)</span>)</span></span></span></div></div><p>The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function <code>f</code>
between finite types <code>α</code> and <code>β</code> and a number <code>b</code> such that <code>card β • b ≤ card α</code>, there exists an
element <code>y : β</code> such that its preimage has at least <code>b</code> elements.
See also <code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_lt_card_fiber_of_nsmul_lt_card">Fintype.exists_lt_card_fiber_of_nsmul_lt_card</a></code> for a stronger statement.</p></div></div><div class="decl" id="Fintype.exists_le_card_fiber_of_mul_le_card"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L433-L435">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_le_card_fiber_of_mul_le_card"><span class="name">Fintype</span>.<span class="name">exists_le_card_fiber_of_mul_le_card</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hn : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn">n</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>)</span></span></span></div></div><p>The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function <code>f</code>
between finite types <code>α</code> and <code>β</code> and a number <code>n</code> such that <code>card β * n ≤ card α</code>, there exists an
element <code>y : β</code> such that its preimage has at least <code>n</code> elements. See also
<code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_lt_card_fiber_of_mul_lt_card">Fintype.exists_lt_card_fiber_of_mul_lt_card</a></code> for a stronger statement.</p></div></div><div class="decl" id="Fintype.exists_card_fiber_le_of_card_le_nsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L442-L445">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_card_fiber_le_of_card_le_nsmul"><span class="name">Fintype</span>.<span class="name">exists_card_fiber_le_of_card_le_nsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommSemiring">LinearOrderedCommSemiring</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span>)</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>)</span>)</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span></span></div></div><p>The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function <code>f</code>
between finite types <code>α</code> and <code>β</code> and a number <code>b</code> such that <code>card α ≤ card β • b</code>, there exists an
element <code>y : β</code> such that its preimage has at most <code>b</code> elements.
See also <code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_card_fiber_lt_of_card_lt_nsmul">Fintype.exists_card_fiber_lt_of_card_lt_nsmul</a></code> for a stronger statement.</p></div></div><div class="decl" id="Fintype.exists_card_fiber_le_of_card_le_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L452-L454">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_card_fiber_le_of_card_le_mul"><span class="name">Fintype</span>.<span class="name">exists_card_fiber_le_of_card_le_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hn : <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">y</span>, <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset.filter">Finset.filter</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>) <span class="fn">Finset.univ</span></span>)</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></span></span></div></div><p>The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function <code>f</code>
between finite types <code>α</code> and <code>β</code> and a number <code>n</code> such that <code>card α ≤ card β * n</code>, there exists an
element <code>y : β</code> such that its preimage has at most <code>n</code> elements. See also
<code><a href="../.././Mathlib/Combinatorics/Pigeonhole.html#Fintype.exists_card_fiber_lt_of_card_lt_mul">Fintype.exists_card_fiber_lt_of_card_lt_mul</a></code> for a stronger statement.</p></div></div><div class="decl" id="Nat.exists_lt_modEq_of_infinite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Combinatorics/Pigeonhole.lean#L465-L468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Combinatorics/Pigeonhole.html#Nat.exists_lt_modEq_of_infinite"><span class="name">Nat</span>.<span class="name">exists_lt_modEq_of_infinite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Init/Set.html#Set">Set</a> <a href="../.././Init/Prelude.html#Nat">ℕ</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hs : <span class="fn"><a href="../.././Mathlib/Data/Set/Finite.html#Set.Infinite">Set.Infinite</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hk : <span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">k</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">m</span>, <span class="fn"><span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∃ <span class="fn">n</span>, <span class="fn"><span class="fn"><span class="fn">n</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">n</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">m</span> <a href="../.././Mathlib/Data/Nat/ModEq.html#Nat.ModEq">≡</a> <span class="fn">n</span> <a href="../.././Mathlib/Data/Nat/ModEq.html#Nat.ModEq">[MOD</a> <span class="fn">k</span><a href="../.././Mathlib/Data/Nat/ModEq.html#Nat.ModEq">]</a></span></span></span></span></span></span></div></div><p>If <code>s</code> is an infinite set of natural numbers and <code>k > 0</code>, then <code>s</code> contains two elements <code>m < n</code>
that are equal mod <code>k</code>.</p></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>