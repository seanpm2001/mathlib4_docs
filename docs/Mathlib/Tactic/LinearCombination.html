<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.LinearCombination</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.LinearCombination";</script><script type="module" src="../.././search.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span></a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Tactic/Ring.html">Mathlib.Tactic.Ring</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.LinearCombination" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.pf_add_c"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">pf_add_c</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.c_add_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">c_add_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.add_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">add_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.pf_sub_c"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">pf_sub_c</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.c_sub_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">c_sub_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.sub_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">sub_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.neg_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">neg_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.pf_mul_c"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">pf_mul_c</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.c_mul_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">c_mul_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.mul_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">mul_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.inv_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">inv_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.pf_div_c"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">pf_div_c</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.c_div_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">c_div_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.div_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">div_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.expandLinearCombo"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">expandLinearCombo</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.Config"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.instInhabitedConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">instInhabitedConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.elabConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">elabConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.eq_trans₃"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">eq_trans₃</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.eq_of_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">eq_of_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.elabLinearCombination"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">elabLinearCombination</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.normStx"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">normStx</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.linearCombination"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">linearCombination</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.LinearCombination.tacticLinear_combination2____"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">tacticLinear_combination2____</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="linear-combination-Tactic">linear_combination Tactic <a class="hover-link" href="#linear-combination-Tactic">#</a></h1><p>In this file, the <code>linear_combination</code> tactic is created.  This tactic, which
works over <code><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a></code>s, attempts to simplify the target by creating a linear combination
of a list of equalities and subtracting it from the target.  This file also includes a
definition for <code>linear_combination_config</code>.  A <code>linear_combination_config</code>
object can be passed into the tactic, allowing the user to specify a
normalization tactic.</p><h2 class="markdown-heading" id="Implementation-Notes">Implementation Notes <a class="hover-link" href="#Implementation-Notes">#</a></h2><p>This tactic works by creating a weighted sum of the given equations with the
given coefficients.  Then, it subtracts the right side of the weighted sum
from the left side so that the right side equals 0, and it does the same with
the target.  Afterwards, it sets the goal to be the equality between the
lefthand side of the new goal and the lefthand side of the new weighted sum.
Lastly, calls a normalization tactic on this target.</p><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F.20tactics/topic/Linear.20algebra.20tactic/near/213928196">https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F.20tactics/topic/Linear.20algebra.20tactic/near/213928196</a></li>
</ul></div><div class="decl" id="Mathlib.Tactic.LinearCombination.pf_add_c"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L37-L37">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.pf_add_c"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">pf_add_c</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Add">Add</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.c_add_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L38-L38">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.c_add_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">c_add_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Add">Add</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.add_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L39-L39">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.add_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">add_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Add">Add</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p₁ : <span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p₂ : <span class="fn"><span class="fn">a₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.pf_sub_c"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L40-L40">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.pf_sub_c"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">pf_sub_c</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Sub">Sub</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.c_sub_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L41-L41">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.c_sub_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">c_sub_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Sub">Sub</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.sub_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L42-L42">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.sub_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">sub_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Sub">Sub</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p₁ : <span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p₂ : <span class="fn"><span class="fn">a₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">a₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b₁</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.neg_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L43-L43">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.neg_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">neg_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Neg">Neg</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.pf_mul_c"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L44-L44">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.pf_mul_c"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">pf_mul_c</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.c_mul_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L45-L45">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.c_mul_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">c_mul_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.mul_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L46-L46">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.mul_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">mul_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p₁ : <span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p₂ : <span class="fn"><span class="fn">a₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b₁</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.inv_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L47-L47">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.inv_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">inv_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Inv">Inv</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span><a href="../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b</span><a href="../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.pf_div_c"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L48-L48">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.pf_div_c"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">pf_div_c</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Div">Div</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.c_div_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L49-L49">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.c_div_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">c_div_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Div">Div</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.div_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L50-L50">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.div_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">div_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Div">Div</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p₁ : <span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p₂ : <span class="fn"><span class="fn">a₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">a₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b₁</span> <a href="../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">b₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.expandLinearCombo"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L61-L105">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.expandLinearCombo"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">expandLinearCombo</span></a></span><span class="decl_args">
<span class="fn">(stx : <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> (<span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span>)</span></div></div><p>Performs macro expansion of a linear combination expression,
using <code>+</code>/<code>-</code>/<code>*</code>/<code>/</code> on equations and values.</p><ul>
<li><code>some p</code> means that <code>p</code> is a syntax corresponding to a proof of an equation.
For example, if <code>h : a = b</code> then <code><a href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.expandLinearCombo">expandLinearCombo</a> (2 * h)</code> returns <code>some (c_add_pf 2 h)</code>
which is a proof of <code>2 * a = 2 * b</code>.</li>
<li><code>none</code> means that the input expression is not an equation but a value;
the input syntax itself is used in this case.</li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L108-L116">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">Config</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Mathlib.Tactic.LinearCombination.Config.mk"><li id="Mathlib.Tactic.LinearCombination.Config.normalize" class="structure_field"><div class="structure_field_doc"><p>whether or not the normalization step should be used</p></div><div class="structure_field_info">normalize : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Mathlib.Tactic.LinearCombination.Config.twoGoals" class="structure_field"><div class="structure_field_doc"><p>whether to make separate subgoals for both sides or just one for <code>lhs - rhs = 0</code></p></div><div class="structure_field_info">twoGoals : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Mathlib.Tactic.LinearCombination.Config.normTac" class="structure_field"><div class="structure_field_doc"><p>the tactic used for normalization when checking
if the weighted sum is equivalent to the goal (when <code><a href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config.normalize">normalize</a></code> is <code>true</code>).</p></div><div class="structure_field_info">normTac : <a href="../.././Init/Meta.html#Lean.Syntax.Tactic">Lean.Syntax.Tactic</a></div></li></ul><p>A configuration object for <code>linear_combination</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Mathlib.Tactic.LinearCombination.Config" class="instances-for-list"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.instInhabitedConfig"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L116-L116">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.instInhabitedConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">instInhabitedConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config">Mathlib.Tactic.LinearCombination.Config</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.instInhabitedConfig">Mathlib.Tactic.LinearCombination.instInhabitedConfig</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">normalize</span> := <span class="fn">default</span>, <span class="fn">twoGoals</span> := <span class="fn">default</span>, <span class="fn">normTac</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.elabConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L118-L119">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.elabConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">elabConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config">Mathlib.Tactic.LinearCombination.Config</a></span></span></div></div><p>Function elaborating <code><a href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config">LinearCombination.Config</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Mathlib.Tactic.LinearCombination.elabConfig" class="instances-for-list"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.eq_trans₃"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L121-L121">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.eq_trans₃"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">eq_trans₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.eq_of_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L123-L124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.eq_of_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">eq_of_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddGroup">AddGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b'</span></span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> (<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.elabLinearCombination"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L127-L143">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.elabLinearCombination"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">elabLinearCombination</span></a></span><span class="decl_args">
<span class="fn">(norm? : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Init/Meta.html#Lean.Syntax.Tactic">Lean.Syntax.Tactic</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(input : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(twoGoals : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">Lean.Elab.Tactic.TacticM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Implementation of <code>linear_combination</code> and <code>linear_combination2</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Mathlib.Tactic.LinearCombination.elabLinearCombination" class="instances-for-list"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.normStx"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L145-L150">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.normStx"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">normStx</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>(norm := $tac)</code> syntax says to use <code>tac</code> as a normalization postprocessor for
<code>linear_combination</code>. The default normalizer is <code>ring1</code>, but you can override it with <code>ring_nf</code>
to get subgoals from <code>linear_combination</code> or with <code>skip</code> to disable normalization.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Mathlib.Tactic.LinearCombination.normStx" class="instances-for-list"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.linearCombination"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L152-L219">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.linearCombination"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">linearCombination</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>linear_combination</code> attempts to simplify the target by creating a linear combination
of a list of equalities and subtracting it from the target.
The tactic will create a linear
combination by adding the equalities together from left to right, so the order
of the input hypotheses does matter.  If the <code><a href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config.normalize">normalize</a></code> field of the
configuration is set to false, then the tactic will simply set the user up to
prove their target using the linear combination instead of normalizing the subtraction.</p><p>Note: The left and right sides of all the equalities should have the same
type, and the coefficients should also have this type.  There must be
instances of <code><a href="../.././Init/Prelude.html#Mul">Mul</a></code> and <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddGroup">AddGroup</a></code> for this type.</p><ul>
<li>The input <code>e</code> in <code>linear_combination e</code> is a linear combination of proofs of equalities,
given as a sum/difference of coefficients multiplied by expressions.
The coefficients may be arbitrary expressions.
The expressions can be arbitrary proof terms proving equalities.
Most commonly they are hypothesis names <code>h1, h2, ...</code>.</li>
<li><code>linear_combination (norm := tac) e</code> runs the "normalization tactic" <code>tac</code>
on the subgoal(s) after constructing the linear combination.
<ul>
<li>The default normalization tactic is <code>ring1</code>, which closes the goal or fails.</li>
<li>To get a subgoal in the case that it is not immediately provable, use
<code>ring_nf</code> as the normalization tactic.</li>
<li>To avoid normalization entirely, use <code>skip</code> as the normalization tactic.</li>
</ul>
</li>
<li><code>linear_combination2 e</code> is the same as <code>linear_combination e</code> but it produces two
subgoals instead of one: rather than proving that <code>(a - b) - (a' - b') = 0</code> where
<code>a' = b'</code> is the linear combination from <code>e</code> and <code>a = b</code> is the goal,
it instead attempts to prove <code>a = a'</code> and <code>b = b'</code>.
Because it does not use subtraction, this form is applicable also to semirings.
<ul>
<li>Note that a goal which is provable by <code>linear_combination e</code> may not be provable
by <code>linear_combination2 e</code>; in general you may need to add a coefficient to <code>e</code>
to make both sides match, as in <code>linear_combination2 e + c</code>.</li>
<li>You can also reverse equalities using <code>← h</code>, so for example if <code>h₁ : a = b</code>
then <code>2 * (← h)</code> is a proof of <code>2 * b = 2 * a</code>.</li>
</ul>
</li>
</ul><p>Example Usage:</p><pre><code>example (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by
  linear_combination 1*h1 - 2*h2

example (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by
  linear_combination h1 - 2*h2

example (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by
  linear_combination (norm := ring_nf) -2*h2
  /- Goal: x * y + x * 2 - 1 = 0 -/

example (x y z : ℝ) (ha : x + 2*y - z = 4) (hb : 2*x + y + z = -2)
    (hc : x + 2*y + z = 2) :
    -3*x - 3*y - 4*z = 2 := by
  linear_combination ha - hb - 2*hc

example (x y : ℚ) (h1 : x + y = 3) (h2 : 3*x = 7) :
    x*x*y + y*x*y + 6*x = 3*x*y + 14 := by
  linear_combination x*y*h1 + 2*h2

example (x y : ℤ) (h1 : x = -3) (h2 : y = 10) : 2*x = -6 := by
  linear_combination (norm := skip) 2*h1
  simp

axiom qc : ℚ
axiom hqc : qc = 2*qc

example (a b : ℚ) (h : ∀ p q : ℚ, p = q) : 3*a + qc = 3*b + 2*qc := by
  linear_combination 3 * h a b + hqc
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Mathlib.Tactic.LinearCombination.linearCombination" class="instances-for-list"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.LinearCombination.tacticLinear_combination2____"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/Tactic/LinearCombination.lean#L223-L224">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.tacticLinear_combination2____"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">LinearCombination</span>.<span class="name">tacticLinear_combination2____</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>linear_combination</code> attempts to simplify the target by creating a linear combination
of a list of equalities and subtracting it from the target.
The tactic will create a linear
combination by adding the equalities together from left to right, so the order
of the input hypotheses does matter.  If the <code><a href="../.././Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Config.normalize">normalize</a></code> field of the
configuration is set to false, then the tactic will simply set the user up to
prove their target using the linear combination instead of normalizing the subtraction.</p><p>Note: The left and right sides of all the equalities should have the same
type, and the coefficients should also have this type.  There must be
instances of <code><a href="../.././Init/Prelude.html#Mul">Mul</a></code> and <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddGroup">AddGroup</a></code> for this type.</p><ul>
<li>The input <code>e</code> in <code>linear_combination e</code> is a linear combination of proofs of equalities,
given as a sum/difference of coefficients multiplied by expressions.
The coefficients may be arbitrary expressions.
The expressions can be arbitrary proof terms proving equalities.
Most commonly they are hypothesis names <code>h1, h2, ...</code>.</li>
<li><code>linear_combination (norm := tac) e</code> runs the "normalization tactic" <code>tac</code>
on the subgoal(s) after constructing the linear combination.
<ul>
<li>The default normalization tactic is <code>ring1</code>, which closes the goal or fails.</li>
<li>To get a subgoal in the case that it is not immediately provable, use
<code>ring_nf</code> as the normalization tactic.</li>
<li>To avoid normalization entirely, use <code>skip</code> as the normalization tactic.</li>
</ul>
</li>
<li><code>linear_combination2 e</code> is the same as <code>linear_combination e</code> but it produces two
subgoals instead of one: rather than proving that <code>(a - b) - (a' - b') = 0</code> where
<code>a' = b'</code> is the linear combination from <code>e</code> and <code>a = b</code> is the goal,
it instead attempts to prove <code>a = a'</code> and <code>b = b'</code>.
Because it does not use subtraction, this form is applicable also to semirings.
<ul>
<li>Note that a goal which is provable by <code>linear_combination e</code> may not be provable
by <code>linear_combination2 e</code>; in general you may need to add a coefficient to <code>e</code>
to make both sides match, as in <code>linear_combination2 e + c</code>.</li>
<li>You can also reverse equalities using <code>← h</code>, so for example if <code>h₁ : a = b</code>
then <code>2 * (← h)</code> is a proof of <code>2 * b = 2 * a</code>.</li>
</ul>
</li>
</ul><p>Example Usage:</p><pre><code>example (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by
  linear_combination 1*h1 - 2*h2

example (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by
  linear_combination h1 - 2*h2

example (x y : ℤ) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by
  linear_combination (norm := ring_nf) -2*h2
  /- Goal: x * y + x * 2 - 1 = 0 -/

example (x y z : ℝ) (ha : x + 2*y - z = 4) (hb : 2*x + y + z = -2)
    (hc : x + 2*y + z = 2) :
    -3*x - 3*y - 4*z = 2 := by
  linear_combination ha - hb - 2*hc

example (x y : ℚ) (h1 : x + y = 3) (h2 : 3*x = 7) :
    x*x*y + y*x*y + 6*x = 3*x*y + 14 := by
  linear_combination x*y*h1 + 2*h2

example (x y : ℤ) (h1 : x = -3) (h2 : y = 10) : 2*x = -6 := by
  linear_combination (norm := skip) 2*h1
  simp

axiom qc : ℚ
axiom hqc : qc = 2*qc

example (a b : ℚ) (h : ∀ p q : ℚ, p = q) : 3*a + qc = 3*b + 2*qc := by
  linear_combination 3 * h a b + hqc
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Mathlib.Tactic.LinearCombination.tacticLinear_combination2____" class="instances-for-list"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>