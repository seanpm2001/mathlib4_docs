<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Filtered</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Filtered";</script><script type="module" src="../.././search.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Filtered</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Filtered</span></a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/CategoryTheory/FinCategory.html">Mathlib.CategoryTheory.FinCategory</a></li><li><a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html">Mathlib.CategoryTheory.Adjunction.Basic</a></li><li><a href="../.././Mathlib/CategoryTheory/Category/Preorder.html">Mathlib.CategoryTheory.Category.Preorder</a></li><li><a href="../.././Mathlib/CategoryTheory/Category/ULift.html">Mathlib.CategoryTheory.Category.ULift</a></li><li><a href="../.././Mathlib/CategoryTheory/Limits/Cones.html">Mathlib.CategoryTheory.Limits.Cones</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Filtered" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_semilatticeSup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_semilatticeSup_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_directed_le"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_directed_le</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_directed_le_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_directed_le_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredDiscretePUnitDiscreteCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.max"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.leftToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">leftToMax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.rightToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">rightToMax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeqHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeqHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_right_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_isRightAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_objs_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.toSup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.toSup_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup_commutes</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.cocone"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_right_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isRightAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.max₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.firstToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">firstToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.secondToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">secondToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.thirdToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">thirdToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃Hom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃Hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₁"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₁</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₂"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.span"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">span</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">bowtie</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.tulip"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">tulip</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_semilatticeInf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_semilatticeInf_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_directed_ge</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_directed_ge_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_directed_ge_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredDiscretePUnitDiscreteCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.min"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">min</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.minToLeft"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.minToRight"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eqHom"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eqHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cospan</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.ranges_directed"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">ranges_directed</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_left_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_isLeftAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_objs_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.infTo"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.infTo_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo_commutes</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cone"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_left_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isLeftAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_op_of_isFilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_op_of_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_of_isFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_op_of_isCofilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_op_of_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_of_isCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_isFilteredOrEmpty_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_isCofilteredOrEmpty_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_isFiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_isFiltered_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_isCofiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_isCofiltered_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredULiftUliftCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftUliftCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredULiftUliftCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftUliftCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredULiftHomCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftHomCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredULiftHomCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftHomCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredAsSmallInstSmallCategoryAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredAsSmallInstSmallCategoryAsSmall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredAsSmallInstSmallCategoryAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredAsSmallInstSmallCategoryAsSmall</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Filtered-categories">Filtered categories <a class="hover-link" href="#Filtered-categories">#</a></h1><p>A category is filtered if every finite diagram admits a cocone.
We give a simple characterisation of this condition as</p><ol>
<li>for every pair of objects there exists another object "to the right",</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><p>Filtered colimits are often better behaved than arbitrary colimits.
See <code>CategoryTheory/Limits/Types</code> for some details.</p><p>Filtered categories are nice because colimits indexed by filtered categories tend to be
easier to describe than general colimits (and more often preserved by functors).</p><p>In this file we show that any functor from a finite category to a filtered category admits a cocone:</p><ul>
<li><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.cocone_nonempty">cocone_nonempty</a> [FinCategory J] [IsFiltered C] (F : J ⥤ C) : <a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> (Cocone F)</code>
More generally,
for any finite collection of objects and morphisms between them in a filtered category
(even if not closed under composition) there exists some object <code>Z</code> receiving maps from all of them,
so that all the triangles (one edge from the finite set, two from morphisms to <code>Z</code>) commute.
This formulation is often more useful in practice and is available via <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.sup_exists">sup_exists</a></code>,
which takes a finset of objects, and an indexed family (indexed by source and target)
of finsets of morphisms.</li>
</ul><p>Furthermore, we give special support for two diagram categories: The <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.bowtie">bowtie</a></code> and the <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.tulip">tulip</a></code>.
This is because these shapes show up in the proofs that forgetful functors of algebraic categories
(e.g. <code>MonCat</code>, <code>CommRingCat</code>, ...) preserve filtered colimits.</p><p>All of the above API, except for the <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.bowtie">bowtie</a></code> and the <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.tulip">tulip</a></code>, is also provided for cofiltered
categories.</p><h2 class="markdown-heading" id="See-also">See also <a class="hover-link" href="#See-also">#</a></h2><p>In <code>CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit</code> we show that filtered colimits
commute with finite limits.</p></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L71-L76">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><ul class="structure_fields" id="CategoryTheory.IsFilteredOrEmpty.mk"><li id="CategoryTheory.IsFilteredOrEmpty.cocone_objs" class="structure_field"><div class="structure_field_doc"><p>for every pair of objects there exists another object "to the right"</p></div><div class="structure_field_info">cocone_objs : <span class="fn">∀ (<span class="fn">X </span>Y : <span class="fn">C</span>), <span class="fn">∃ <span class="fn">Z</span> <span class="fn">x</span> <span class="fn">x</span>, <a href="../.././Init/Prelude.html#True">True</a></span></span></div></li><li id="CategoryTheory.IsFilteredOrEmpty.cocone_maps" class="structure_field"><div class="structure_field_doc"><p>for every pair of parallel morphisms there exists a morphism to the right
so the compositions are equal</p></div><div class="structure_field_info">cocone_maps : <span class="fn">∀ ⦃<span class="fn">X </span>Y : <span class="fn">C</span>⦄ (<span class="fn">f </span>g : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn">∃ <span class="fn">Z</span> <span class="fn">h</span>, <span class="fn"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">h</span></span></span></span></span></div></li></ul><p>A category <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a></code> if</p><ol>
<li>for every pair of objects there exists another object "to the right", and</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal.</li>
</ol><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsFilteredOrEmpty" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L87-L89">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><ul class="structure_fields" id="CategoryTheory.IsFiltered.mk"><li id="CategoryTheory.IsFiltered.Nonempty" class="structure_field"><div class="structure_field_doc"><p>a filtered category must be non empty</p></div><div class="structure_field_info">Nonempty : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">C</span></span></div></li></ul><p>A category <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code> if</p><ol>
<li>for every pair of objects there exists another object "to the right",</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><p>See <a href="https://stacks.math.columbia.edu/tag/002V">https://stacks.math.columbia.edu/tag/002V</a>. (They also define a diagram being filtered.)</p><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsFiltered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L92-L98">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_semilatticeSup</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Order/Lattice.html#SemilatticeSup">SemilatticeSup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup">CategoryTheory.isFilteredOrEmpty_of_semilatticeSup</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup.proof_1">CategoryTheory.isFilteredOrEmpty_of_semilatticeSup.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L101-L102">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_semilatticeSup_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Order/Lattice.html#SemilatticeSup">SemilatticeSup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFiltered_of_semilatticeSup_nonempty">CategoryTheory.isFiltered_of_semilatticeSup_nonempty</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFiltered_of_semilatticeSup_nonempty.proof_1">CategoryTheory.isFiltered_of_semilatticeSup_nonempty.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_directed_le"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L105-L112">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFilteredOrEmpty_of_directed_le"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_directed_le</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Init/Algebra/Order.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun <span class="fn">x</span> <span class="fn">x_1</span> =&gt <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFilteredOrEmpty_of_directed_le">CategoryTheory.isFilteredOrEmpty_of_directed_le</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFilteredOrEmpty_of_directed_le.proof_1">CategoryTheory.isFilteredOrEmpty_of_directed_le.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFiltered_of_directed_le_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L115-L116">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFiltered_of_directed_le_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_directed_le_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Init/Algebra/Order.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun <span class="fn">x</span> <span class="fn">x_1</span> =&gt <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFiltered_of_directed_le_nonempty">CategoryTheory.isFiltered_of_directed_le_nonempty</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFiltered_of_directed_le_nonempty.proof_1">CategoryTheory.isFiltered_of_directed_le_nonempty.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L124-L129">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredDiscretePUnitDiscreteCategory</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory">CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory.proof_1">CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.max"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L152-L153">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">max</a> j j'</code> is an arbitrary choice of object to the right of both <code>j</code> and <code>j'</code>,
whose existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ <span class="fn">Z</span> <span class="fn">x</span> <span class="fn">x</span>, <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.max" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.leftToMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L159-L160">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.leftToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">leftToMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j</span> <span class="fn">j'</span></span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.leftToMax">leftToMax</a> j j'</code> is an arbitrary choice of morphism from <code>j</code> to <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">max</a> j j'</code>,
whose existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.leftToMax">CategoryTheory.IsFiltered.leftToMax</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ <span class="fn">x</span> <span class="fn">x</span>, <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.leftToMax" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.rightToMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L166-L167">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.rightToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">rightToMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j</span> <span class="fn">j'</span></span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.rightToMax">rightToMax</a> j j'</code> is an arbitrary choice of morphism from <code>j'</code> to <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">max</a> j j'</code>,
whose existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.rightToMax">CategoryTheory.IsFiltered.rightToMax</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ <span class="fn">x</span>, <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.rightToMax" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L175-L176">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' : j' ⟶ <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code> such that
<code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> : f ≫ <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.
Its existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq">CategoryTheory.IsFiltered.coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ <span class="fn">Z</span> <span class="fn">h</span>, <span class="fn"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f'</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">h</span></span></span></span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.coeq" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeqHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L184-L185">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeqHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq">CategoryTheory.IsFiltered.coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of morphism
<code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' : j' ⟶ <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code> such that
<code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> : f ≫ <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.
Its existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ <span class="fn">h</span>, <span class="fn"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f'</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">h</span></span></span></span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.coeqHom" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq_condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L192-L192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq">CategoryTheory.IsFiltered.coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">h</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f'</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq_condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L193-L194">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f'</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span></span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is the proof that
<code>f ≫ <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L211-L216">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_right_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered or emtpy, and we have a functor <code>R : C ⥤ D</code> with a left adjoint, then <code>D</code> is
filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L220-L221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_isRightAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(R : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.IsRightAdjoint">CategoryTheory.IsRightAdjoint</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered or empty, and we have a right adjoint functor <code>R : C ⥤ D</code>, then <code>D</code> is
filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L224-L225">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>Being filtered or empty is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup_objs_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L240-L249">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.sup_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_objs_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">S</span>, <span class="fn">∀ {<span class="fn">X</span> : <span class="fn">C</span>}, <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span></span></span></div></div><p>Any finite collection of objects in a filtered category has an object "to the right".</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L259-L288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.sup_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' (<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">S</span> <span class="fn">T</span>,
  <span class="fn">∀ {<span class="fn">X </span>Y : <span class="fn">C</span>} (<span class="fn">mX</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) (<span class="fn">mY</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) {<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>},
    <span class="fn"><span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">X</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">Y</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mX</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mY</span>, <span class="fn">snd</span> := <span class="fn">f</span> }</span> }</span> }</span> }</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><span class="fn">T</span> <span class="fn">Y</span> <span class="fn">mY</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">T</span> <span class="fn">X</span> <span class="fn">mX</span></span></span></span></span></span></div></div><p>Given any <code><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code> of objects <code>{X, ...}</code> and
indexed collection of <code><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>s of morphisms <code>{f, ...}</code> in <code>C</code>,
there exists an object <code>S</code>, with a morphism <code>T X : X ⟶ S</code> from each <code>X</code>,
such that the triangles commute: <code>f ≫ T Y = T X</code>, for <code>f : X ⟶ Y</code> in the <code><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L295-L296">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.sup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' (<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>An arbitrary choice of object "to the right"
of a finite collection of objects <code>O</code> and morphisms <code>H</code>,
making all the triangles commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.sup" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.toSup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L301-L302">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.toSup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' (<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.sup">CategoryTheory.IsFiltered.sup</a> <span class="fn">O</span> <span class="fn">H</span></span></span></div></div><p>The morphisms to <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.sup">sup</a> O H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.toSup" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.toSup_commutes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L307-L310">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.toSup_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup_commutes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' (<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mX : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(mY : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mf : <span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">X</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">Y</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mX</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mY</span>, <span class="fn">snd</span> := <span class="fn">f</span> }</span> }</span> }</span> }</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.toSup">CategoryTheory.IsFiltered.toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mY</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.toSup">CategoryTheory.IsFiltered.toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mX</span></span></span></div></div><p>The triangles of consisting of a morphism in <code>H</code> and the maps to <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.sup">sup</a> O H</code> commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L318-L333">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/FinCategory.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">J</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></div></div><p>If we have <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a> C</code>, then for any functor <code>F : J ⥤ C</code> with <code>FinCategory J</code>,
there exists a cocone over <code>F</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.cocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L338-L339">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.cocone"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/FinCategory.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">J</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>An arbitrary choice of cocone over <code>F : J ⥤ C</code>, for <code>FinCategory J</code> and <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a> C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.cocone">CategoryTheory.IsFiltered.cocone</a> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">(_ : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.cocone" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_right_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L346-L348">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_right_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered, and we have a functor <code>R : C ⥤ D</code> with a left adjoint, then <code>D</code> is filtered.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_isRightAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L352-L353">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isRightAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(R : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.IsRightAdjoint">CategoryTheory.IsRightAdjoint</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered, and we have a right adjoint functor <code>R : C ⥤ D</code>, then <code>D</code> is filtered.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L357-L358">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">D</span></span></div></div><p>Being filtered is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.max₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L371-L372">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code> is an arbitrary choice of object to the right of <code>j₁</code>, <code>j₂</code> and <code>j₃</code>,
whose existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j₁</span> <span class="fn">j₂</span></span>) <span class="fn">j₃</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.max₃" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.firstToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L378-L379">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.firstToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">firstToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.firstToMax₃">firstToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₁</code> to <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.firstToMax₃">CategoryTheory.IsFiltered.firstToMax₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.leftToMax">CategoryTheory.IsFiltered.leftToMax</a> <span class="fn">j₁</span> <span class="fn">j₂</span></span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.leftToMax">CategoryTheory.IsFiltered.leftToMax</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j₁</span> <span class="fn">j₂</span></span>) <span class="fn">j₃</span></span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.firstToMax₃" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.secondToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L385-L386">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.secondToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">secondToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₂</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.secondToMax₃">secondToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₂</code> to <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.secondToMax₃">CategoryTheory.IsFiltered.secondToMax₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.rightToMax">CategoryTheory.IsFiltered.rightToMax</a> <span class="fn">j₁</span> <span class="fn">j₂</span></span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.leftToMax">CategoryTheory.IsFiltered.leftToMax</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j₁</span> <span class="fn">j₂</span></span>) <span class="fn">j₃</span></span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.secondToMax₃" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.thirdToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L392-L393">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.thirdToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">thirdToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₃</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.thirdToMax₃">thirdToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₃</code> to <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.thirdToMax₃">CategoryTheory.IsFiltered.thirdToMax₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.rightToMax">CategoryTheory.IsFiltered.rightToMax</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j₁</span> <span class="fn">j₂</span></span>) <span class="fn">j₃</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.thirdToMax₃" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L401-L403">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code>, for morphisms <code>f g h : j₁ ⟶ j₂</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> f g h : j₂ ⟶ <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code> such that
<code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃_condition₁">coeq₃_condition₁</a></code>, <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃_condition₂">coeq₃_condition₂</a></code> and <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃_condition₃">coeq₃_condition₃</a></code> are satisfied.
Its existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.coeq₃" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃Hom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L410-L414">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃Hom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃Hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₂</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃">CategoryTheory.IsFiltered.coeq₃</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> f g h</code>, for morphisms <code>f g h : j₁ ⟶ j₂</code>, is an arbitrary choice of morphism
<code>j₂ ⟶ <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code> such that <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃_condition₁">coeq₃_condition₁</a></code>, <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃_condition₂">coeq₃_condition₂</a></code> and <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃_condition₃">coeq₃_condition₃</a></code>
are satisfied. Its existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsFiltered.coeq₃Hom" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₁"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L417-L418">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃_condition₁"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L421-L427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃_condition₂"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">g</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">h</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₃"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L430-L431">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃_condition₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">h</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.span"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L436-L440">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.span"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">span</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">i</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">i</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">k</span> <span class="fn">g</span> <span class="fn">g'</span>, <span class="fn"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">g</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f'</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">g'</span></span></span></span></div></div><p>For every span <code>j ⟵ i ⟶ j'</code>, there
exists a cocone <code>j ⟶ k ⟵ j'</code> such that the square commutes.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.bowtie"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L456-L461">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">bowtie</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f₁ : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₁ : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₂ : <span class="fn"><span class="fn">j₂</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₂ : <span class="fn"><span class="fn">j₂</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">s</span> <span class="fn">α</span> <span class="fn">β</span>, <span class="fn"><span class="fn"><span class="fn"><span class="fn">f₁</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g₁</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">β</span></span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">f₂</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g₂</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">β</span></span></span></span></span></div></div><p>Given a "bowtie" of morphisms</p><pre><code> j₁   j₂
 |\  /|
 | \/ |
 | /\ |
 |/  \∣
 vv  vv
 k₁  k₂
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and two morphisms from <code>k₁</code> and <code>k₂</code> to <code>s</code>,
making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.tulip"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L481-L488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered.tulip"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">tulip</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₃ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₂ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f₁ : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₂ : <span class="fn"><span class="fn">j₂</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₃ : <span class="fn"><span class="fn">j₂</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₄ : <span class="fn"><span class="fn">j₃</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₁ : <span class="fn"><span class="fn">j₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₂ : <span class="fn"><span class="fn">j₃</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">s</span> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">γ</span>, <span class="fn"><span class="fn"><span class="fn"><span class="fn">f₁</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g₁</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">β</span></span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f₂</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f₃</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">γ</span></span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">f₄</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">γ</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g₂</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">β</span></span></span></span></span></span></div></div><p>Given a "tulip" of morphisms</p><pre><code> j₁    j₂    j₃
 |\   / \   / |
 | \ /   \ /  |
 |  vv    vv  |
 \  k₁    k₂ /
  \         /
   \       /
    \     /
     \   /
      v v
       l
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and three morphisms from <code>k₁</code>, <code>k₂</code> and <code>l</code>
to <code>s</code>, making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L500-L505">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><ul class="structure_fields" id="CategoryTheory.IsCofilteredOrEmpty.mk"><li id="CategoryTheory.IsCofilteredOrEmpty.cone_objs" class="structure_field"><div class="structure_field_doc"><p>for every pair of objects there exists another object "to the left"</p></div><div class="structure_field_info">cone_objs : <span class="fn">∀ (<span class="fn">X </span>Y : <span class="fn">C</span>), <span class="fn">∃ <span class="fn">W</span> <span class="fn">x</span> <span class="fn">x</span>, <a href="../.././Init/Prelude.html#True">True</a></span></span></div></li><li id="CategoryTheory.IsCofilteredOrEmpty.cone_maps" class="structure_field"><div class="structure_field_doc"><p>for every pair of parallel morphisms there exists a morphism to the left
so the compositions are equal</p></div><div class="structure_field_info">cone_maps : <span class="fn">∀ ⦃<span class="fn">X </span>Y : <span class="fn">C</span>⦄ (<span class="fn">f </span>g : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn">∃ <span class="fn">W</span> <span class="fn">h</span>, <span class="fn"><span class="fn"><span class="fn">h</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">h</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">g</span></span></span></span></span></div></li></ul><p>A category <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a></code> if</p><ol>
<li>for every pair of objects there exists another object "to the left", and</li>
<li>for every pair of parallel morphisms there exists a morphism to the left so the compositions
are equal.</li>
</ol><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCofilteredOrEmpty" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L516-L518">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><ul class="structure_fields" id="CategoryTheory.IsCofiltered.mk"><li id="CategoryTheory.IsCofiltered.Nonempty" class="structure_field"><div class="structure_field_doc"><p>a cofiltered category must be non empty</p></div><div class="structure_field_info">Nonempty : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">C</span></span></div></li></ul><p>A category <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code> if</p><ol>
<li>for every pair of objects there exists another object "to the left",</li>
<li>for every pair of parallel morphisms there exists a morphism to the left so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><p>See <a href="https://stacks.math.columbia.edu/tag/04AZ">https://stacks.math.columbia.edu/tag/04AZ</a>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCofiltered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L521-L526">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_semilatticeInf</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Order/Lattice.html#SemilatticeInf">SemilatticeInf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf">CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf.proof_1">CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L529-L530">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_semilatticeInf_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Order/Lattice.html#SemilatticeInf">SemilatticeInf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty">CategoryTheory.isCofiltered_of_semilatticeInf_nonempty</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty.proof_1">CategoryTheory.isCofiltered_of_semilatticeInf_nonempty.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L533-L540">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_directed_ge</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Init/Algebra/Order.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun <span class="fn">x</span> <span class="fn">x_1</span> =&gt <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofilteredOrEmpty_of_directed_ge">CategoryTheory.isCofilteredOrEmpty_of_directed_ge</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofilteredOrEmpty_of_directed_ge.proof_1">CategoryTheory.isCofilteredOrEmpty_of_directed_ge.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_directed_ge_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L543-L544">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofiltered_of_directed_ge_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_directed_ge_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Init/Algebra/Order.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun <span class="fn">x</span> <span class="fn">x_1</span> =&gt <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofiltered_of_directed_ge_nonempty">CategoryTheory.isCofiltered_of_directed_ge_nonempty</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofiltered_of_directed_ge_nonempty.proof_1">CategoryTheory.isCofiltered_of_directed_ge_nonempty.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L552-L557">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredDiscretePUnitDiscreteCategory</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory">CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory.proof_1">CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.min"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L580-L581">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.min"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">min</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> is an arbitrary choice of object to the left of both <code>j</code> and <code>j'</code>,
whose existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.min">CategoryTheory.IsCofiltered.min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ <span class="fn">W</span> <span class="fn">x</span> <span class="fn">x</span>, <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsCofiltered.min" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.minToLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L587-L588">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.minToLeft"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.min">CategoryTheory.IsCofiltered.min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.minToLeft">minToLeft</a> j j'</code> is an arbitrary choice of morphism from <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> to <code>j</code>,
whose existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.minToLeft">CategoryTheory.IsCofiltered.minToLeft</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ <span class="fn">x</span> <span class="fn">x</span>, <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsCofiltered.minToLeft" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.minToRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L594-L595">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.minToRight"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.min">CategoryTheory.IsCofiltered.min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.minToRight">minToRight</a> j j'</code> is an arbitrary choice of morphism from <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> to <code>j'</code>,
whose existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.minToRight">CategoryTheory.IsCofiltered.minToRight</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ <span class="fn">x</span>, <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsCofiltered.minToRight" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L603-L604">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq">eq</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' : <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq">eq</a> f f' ⟶ j</code> such that
<code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> : <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.
Its existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq">CategoryTheory.IsCofiltered.eq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ <span class="fn">W</span> <span class="fn">h</span>, <span class="fn"><span class="fn"><span class="fn">h</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">h</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f'</span></span></span></span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsCofiltered.eq" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eqHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L612-L613">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eqHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq">CategoryTheory.IsCofiltered.eq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of morphism
<code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' : <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq">eq</a> f f' ⟶ j</code> such that
<code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> : <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.
Its existence is ensured by <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ <span class="fn">h</span>, <span class="fn"><span class="fn"><span class="fn">h</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">h</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f'</span></span></span></span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsCofiltered.eqHom" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq_condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L620-L620">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">h</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn"><span class="fn">f'</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq_condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L621-L622">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f'</span></span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is the proof that
<code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cospan"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L627-L631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.cospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cospan</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">k</span> <span class="fn">g</span> <span class="fn">g'</span>, <span class="fn"><span class="fn"><span class="fn">g</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g'</span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f'</span></span></span></span></div></div><p>For every cospan <code>j ⟶ i ⟵ j'</code>,
there exists a cone <code>j ⟵ k ⟶ j'</code> such that the square commutes.</p></div></div><div class="decl" id="CategoryTheory.Functor.ranges_directed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L634-L637">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.Functor.ranges_directed"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">ranges_directed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <a href="../.././foundational_types.html">Type</a> u_1</span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Directed.html#Directed">Directed</a> (<span class="fn">fun <span class="fn">x</span> <span class="fn">x_1</span> =&gt <span class="fn"><span class="fn">x</span> <a href="../.././Std/Classes/SetNotation.html#Superset">⊇</a> <span class="fn">x_1</span></span></span>) <span class="fn">fun <span class="fn">f</span> =&gt <span class="fn"><a href="../.././Mathlib/Data/Set/Image.html#Set.range">Set.range</a> (<span class="fn"><span class="fn">F</span>.map <span class="fn"><span class="fn">f</span>.snd</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L654-L660">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_left_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered or empty, and we have a functor <code>L : C ⥤ D</code> with a right adjoint,
then <code>D</code> is cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L664-L665">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_isLeftAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(L : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.IsLeftAdjoint">CategoryTheory.IsLeftAdjoint</a> <span class="fn">L</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered or empty, and we have a left adjoint functor <code>L : C ⥤ D</code>, then <code>D</code> is
cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L668-L669">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>Being cofiltered or empty is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf_objs_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L684-L693">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.inf_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_objs_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">S</span>, <span class="fn">∀ {<span class="fn">X</span> : <span class="fn">C</span>}, <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><span class="fn">S</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span></span></span></div></div><p>Any finite collection of objects in a cofiltered category has an object "to the left".</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L703-L732">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.inf_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' (<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">S</span> <span class="fn">T</span>,
  <span class="fn">∀ {<span class="fn">X </span>Y : <span class="fn">C</span>} (<span class="fn">mX</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) (<span class="fn">mY</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) {<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>},
    <span class="fn"><span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">X</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">Y</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mX</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mY</span>, <span class="fn">snd</span> := <span class="fn">f</span> }</span> }</span> }</span> }</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">T</span> <span class="fn">X</span> <span class="fn">mX</span></span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">T</span> <span class="fn">Y</span> <span class="fn">mY</span></span></span></span></span></span></div></div><p>Given any <code><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code> of objects <code>{X, ...}</code> and
indexed collection of <code><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>s of morphisms <code>{f, ...}</code> in <code>C</code>,
there exists an object <code>S</code>, with a morphism <code>T X : S ⟶ X</code> from each <code>X</code>,
such that the triangles commute: <code>T X ≫ f = T Y</code>, for <code>f : X ⟶ Y</code> in the <code><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L739-L740">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.inf"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' (<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>An arbitrary choice of object "to the left"
of a finite collection of objects <code>O</code> and morphisms <code>H</code>,
making all the triangles commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsCofiltered.inf" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.infTo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L745-L746">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.infTo"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' (<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.inf">CategoryTheory.IsCofiltered.inf</a> <span class="fn">O</span> <span class="fn">H</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></div></div><p>The morphisms from <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.inf">inf</a> O H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsCofiltered.infTo" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.infTo_commutes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L751-L754">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.infTo_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo_commutes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' (<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mX : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(mY : <span class="fn"><span class="fn">Y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mf : <span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">X</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">Y</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mX</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mY</span>, <span class="fn">snd</span> := <span class="fn">f</span> }</span> }</span> }</span> }</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.infTo">CategoryTheory.IsCofiltered.infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mX</span></span> <a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">≫</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.infTo">CategoryTheory.IsCofiltered.infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mY</span></span></span></div></div><p>The triangles consisting of a morphism in <code>H</code> and the maps from <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.inf">inf</a> O H</code> commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L762-L778">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/FinCategory.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">J</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></div></div><p>If we have <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">IsCofiltered</a> C</code>, then for any functor <code>F : J ⥤ C</code> with <code>FinCategory J</code>,
there exists a cone over <code>F</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L783-L784">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.cone"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/FinCategory.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">J</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span></div></div><p>An arbitrary choice of cone over <code>F : J ⥤ C</code>, for <code>FinCategory J</code> and <code><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">IsCofiltered</a> C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.cone">CategoryTheory.IsCofiltered.cone</a> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">(_ : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span>)</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-CategoryTheory.IsCofiltered.cone" class="instances-for-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_left_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L792-L794">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_left_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered, and we have a functor <code>L : C ⥤ D</code> with a right adjoint,
then <code>D</code> is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_isLeftAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L798-L799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isLeftAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(L : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">⥤</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.IsLeftAdjoint">CategoryTheory.IsLeftAdjoint</a> <span class="fn">L</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered, and we have a left adjoint functor <code>L : C ⥤ D</code>, then <code>D</code> is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L803-L804">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">D</span></span></div></div><p>Being cofiltered is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L815-L824">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_op_of_isFilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty">CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty.proof_1">CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofiltered_op_of_isFiltered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L826-L827">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofiltered_op_of_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_of_isFiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofiltered_op_of_isFiltered">CategoryTheory.isCofiltered_op_of_isFiltered</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofiltered_op_of_isFiltered.proof_1">CategoryTheory.isCofiltered_op_of_isFiltered.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L830-L839">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_op_of_isCofilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty">CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty.proof_1">CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFiltered_op_of_isCofiltered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L841-L842">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFiltered_op_of_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_of_isCofiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFiltered_op_of_isCofiltered">CategoryTheory.isFiltered_op_of_isCofiltered</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFiltered_op_of_isCofiltered.proof_1">CategoryTheory.isFiltered_op_of_isCofiltered.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L846-L847">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_isFilteredOrEmpty_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is filtered or empty, then C is cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L850-L851">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_isCofilteredOrEmpty_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is cofiltered or empty, then C is filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_isFiltered_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L854-L855">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isCofiltered_of_isFiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_isFiltered_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is filtered, then C is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.isFiltered_of_isCofiltered_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L858-L859">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.isFiltered_of_isCofiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_isCofiltered_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is cofiltered, then C is filtered.</p></div></div><div class="decl" id="CategoryTheory.instIsFilteredULiftUliftCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L865-L866">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredULiftUliftCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftUliftCategory</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> (<span class="fn"><a href="../.././Init/Prelude.html#ULift">ULift</a> <span class="fn">C</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredULiftUliftCategory">CategoryTheory.instIsFilteredULiftUliftCategory</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredULiftUliftCategory.proof_1">CategoryTheory.instIsFilteredULiftUliftCategory.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredULiftUliftCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L868-L869">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredULiftUliftCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftUliftCategory</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> (<span class="fn"><a href="../.././Init/Prelude.html#ULift">ULift</a> <span class="fn">C</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredULiftUliftCategory">CategoryTheory.instIsCofilteredULiftUliftCategory</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredULiftUliftCategory.proof_1">CategoryTheory.instIsCofilteredULiftUliftCategory.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsFilteredULiftHomCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L871-L872">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredULiftHomCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftHomCategory</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">CategoryTheory.ULiftHom</a> <span class="fn">C</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredULiftHomCategory">CategoryTheory.instIsFilteredULiftHomCategory</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredULiftHomCategory.proof_1">CategoryTheory.instIsFilteredULiftHomCategory.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredULiftHomCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L874-L875">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredULiftHomCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftHomCategory</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">CategoryTheory.ULiftHom</a> <span class="fn">C</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredULiftHomCategory">CategoryTheory.instIsCofilteredULiftHomCategory</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredULiftHomCategory.proof_1">CategoryTheory.instIsCofilteredULiftHomCategory.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsFilteredAsSmallInstSmallCategoryAsSmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L877-L878">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredAsSmallInstSmallCategoryAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredAsSmallInstSmallCategoryAsSmall</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">CategoryTheory.AsSmall</a> <span class="fn">C</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredAsSmallInstSmallCategoryAsSmall">CategoryTheory.instIsFilteredAsSmallInstSmallCategoryAsSmall</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsFilteredAsSmallInstSmallCategoryAsSmall.proof_1">CategoryTheory.instIsFilteredAsSmallInstSmallCategoryAsSmall.proof_1</a></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredAsSmallInstSmallCategoryAsSmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/CategoryTheory/Filtered.lean#L880-L881">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredAsSmallInstSmallCategoryAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredAsSmallInstSmallCategoryAsSmall</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">CategoryTheory.AsSmall</a> <span class="fn">C</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredAsSmallInstSmallCategoryAsSmall">CategoryTheory.instIsCofilteredAsSmallInstSmallCategoryAsSmall</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Mathlib/CategoryTheory/Filtered.html#CategoryTheory.instIsCofilteredAsSmallInstSmallCategoryAsSmall.proof_1">CategoryTheory.instIsCofilteredAsSmallInstSmallCategoryAsSmall.proof_1</a></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>