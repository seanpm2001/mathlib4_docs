<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.GroupTheory.FreeProduct</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.GroupTheory.FreeProduct";</script><script type="module" src="../.././search.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">GroupTheory</span>.<span class="name">FreeProduct</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">Mathlib</span>.<span class="name">GroupTheory</span>.<span class="name">FreeProduct</span></a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/GroupTheory/Congruence.html">Mathlib.GroupTheory.Congruence</a></li><li><a href="../.././Mathlib/GroupTheory/IsFreeGroup.html">Mathlib.GroupTheory.IsFreeGroup</a></li><li><a href="../.././Mathlib/Algebra/FreeMonoid/Basic.html">Mathlib.Algebra.FreeMonoid.Basic</a></li><li><a href="../.././Mathlib/Data/List/Chain.html">Mathlib.Data.List.Chain</a></li><li><a href="../.././Mathlib/SetTheory/Cardinal/Ordinal.html">Mathlib.SetTheory.Cardinal.Ordinal</a></li><li><a href="../.././Mathlib/Data/Set/Pointwise/SMul.html">Mathlib.Data.Set.Pointwise.SMul</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.GroupTheory.FreeProduct" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Rel"><span class="name">FreeProduct</span>.<span class="name">Rel</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct"><span class="name">FreeProduct</span></a></div><div class="nav_link"><a class="break_within" href="#instMonoidFreeProduct"><span class="name">instMonoidFreeProduct</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedFreeProduct"><span class="name">instInhabitedFreeProduct</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.ext_iff"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.ext"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word"><span class="name">FreeProduct</span>.<span class="name">Word</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.of"><span class="name">FreeProduct</span>.<span class="name">of</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.of_apply"><span class="name">FreeProduct</span>.<span class="name">of_apply</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.ext_hom"><span class="name">FreeProduct</span>.<span class="name">ext_hom</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift_symm_apply"><span class="name">FreeProduct</span>.<span class="name">lift_symm_apply</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift"><span class="name">FreeProduct</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift_of"><span class="name">FreeProduct</span>.<span class="name">lift_of</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.induction_on"><span class="name">FreeProduct</span>.<span class="name">induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.of_leftInverse"><span class="name">FreeProduct</span>.<span class="name">of_leftInverse</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.of_injective"><span class="name">FreeProduct</span>.<span class="name">of_injective</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift_mrange_le"><span class="name">FreeProduct</span>.<span class="name">lift_mrange_le</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.mrange_eq_iSup"><span class="name">FreeProduct</span>.<span class="name">mrange_eq_iSup</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.instInvFreeProductToMonoidToDivInvMonoid"><span class="name">FreeProduct</span>.<span class="name">instInvFreeProductToMonoidToDivInvMonoid</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.inv_def"><span class="name">FreeProduct</span>.<span class="name">inv_def</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.instGroupFreeProductToMonoidToDivInvMonoid"><span class="name">FreeProduct</span>.<span class="name">instGroupFreeProductToMonoidToDivInvMonoid</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift_range_le"><span class="name">FreeProduct</span>.<span class="name">lift_range_le</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.range_eq_iSup"><span class="name">FreeProduct</span>.<span class="name">range_eq_iSup</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.empty"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.instInhabitedWord"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">instInhabitedWord</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.prod"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">prod</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.prod_empty"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">prod_empty</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.fstIdx"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">fstIdx</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.fstIdx_ne_iff"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">fstIdx_ne_iff</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.Pair.ext_iff"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">Pair</span>.<span class="name">ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.Pair.ext"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">Pair</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.Pair"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">Pair</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.instInhabitedPair"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">instInhabitedPair</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.rcons"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">rcons</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.cons_eq_rcons"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">cons_eq_rcons</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.prod_rcons"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">prod_rcons</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.rcons_inj"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">rcons_inj</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.equivPair"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">equivPair</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.equivPair_symm"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">equivPair_symm</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.equivPair_eq_of_fstIdx_ne"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">equivPair_eq_of_fstIdx_ne</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.summandAction"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">summandAction</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.instMulActionFreeProductWordInstMonoidFreeProduct"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">instMulActionFreeProductWordInstMonoidFreeProduct</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.of_smul_def"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">of_smul_def</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.cons_eq_smul"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">cons_eq_smul</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.smul_induction"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">smul_induction</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.prod_smul"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">prod_smul</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.equiv"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">equiv</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.instDecidableEqWord"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">instDecidableEqWord</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.Word.instDecidableEqFreeProduct"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">instDecidableEqFreeProduct</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord"><span class="name">FreeProduct</span>.<span class="name">NeWord</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.toList"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.toList_ne_nil"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">toList_ne_nil</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">head</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.last"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">last</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.toList_head?"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">toList_head?</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.toList_getLast?"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">toList_getLast?</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.toWord"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">toWord</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.of_word"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">of_word</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.prod"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">prod</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.singleton_head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">singleton_head</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.singleton_last"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">singleton_last</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.prod_singleton"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">prod_singleton</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.append_head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">append_head</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.append_last"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">append_last</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.append_prod"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">append_prod</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.replaceHead"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">replaceHead</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.replaceHead_head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">replaceHead_head</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.mulHead"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">mulHead</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.mulHead_head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">mulHead_head</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.mulHead_prod"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">mulHead_prod</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.inv"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">inv</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.inv_prod"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">inv_prod</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.inv_head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">inv_head</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.NeWord.inv_last"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">inv_last</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift_word_ping_pong"><span class="name">FreeProduct</span>.<span class="name">lift_word_ping_pong</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift_word_prod_nontrivial_of_other_i"><span class="name">FreeProduct</span>.<span class="name">lift_word_prod_nontrivial_of_other_i</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift_word_prod_nontrivial_of_head_eq_last"><span class="name">FreeProduct</span>.<span class="name">lift_word_prod_nontrivial_of_head_eq_last</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift_word_prod_nontrivial_of_head_card"><span class="name">FreeProduct</span>.<span class="name">lift_word_prod_nontrivial_of_head_card</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift_word_prod_nontrivial_of_not_empty"><span class="name">FreeProduct</span>.<span class="name">lift_word_prod_nontrivial_of_not_empty</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.empty_of_word_prod_eq_one"><span class="name">FreeProduct</span>.<span class="name">empty_of_word_prod_eq_one</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.lift_injective_of_ping_pong"><span class="name">FreeProduct</span>.<span class="name">lift_injective_of_ping_pong</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_MulEquiv'_apply"><span class="name">FreeProduct</span>.<span class="name">instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_MulEquiv'_apply</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_MulEquiv'_symm_apply"><span class="name">FreeProduct</span>.<span class="name">instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_MulEquiv'_symm_apply</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_Generators"><span class="name">FreeProduct</span>.<span class="name">instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_Generators</span></a></div><div class="nav_link"><a class="break_within" href="#FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid"><span class="name">FreeProduct</span>.<span class="name">instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid</span></a></div><div class="nav_link"><a class="break_within" href="#freeGroupEquivFreeProduct_symm_apply"><span class="name">freeGroupEquivFreeProduct_symm_apply</span></a></div><div class="nav_link"><a class="break_within" href="#freeGroupEquivFreeProduct_apply"><span class="name">freeGroupEquivFreeProduct_apply</span></a></div><div class="nav_link"><a class="break_within" href="#freeGroupEquivFreeProduct"><span class="name">freeGroupEquivFreeProduct</span></a></div><div class="nav_link"><a class="break_within" href="#FreeGroup.injective_lift_of_ping_pong"><span class="name">FreeGroup</span>.<span class="name">injective_lift_of_ping_pong</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-free-product-of-groups-or-monoids">The free product of groups or monoids <a class="hover-link" href="#The-free-product-of-groups-or-monoids">#</a></h1><p>Given an <code>ι</code>-indexed family <code>M</code> of monoids, we define their free product (categorical coproduct)
<code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code>. When <code>ι</code> and all <code>M i</code> have decidable equality, the free product bijects with the
type <code>word M</code> of reduced words. This bijection is constructed by defining an action of
<code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code> on <code>word M</code>.</p><p>When <code>M i</code> are all groups, <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code> is also a group (and the coproduct in the category of
groups).</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code>: the free product, defined as a quotient of a free monoid.</li>
<li><code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.of">FreeProduct.of</a> {i} : M i →* <a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code>.</li>
<li><code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift">FreeProduct.lift</a> : (Π {i}, M i →* N) ≃ (FreeProduct M →* N)</code>: the universal property.</li>
<li><code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> M</code>: the type of reduced words.</li>
<li><code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.equiv">FreeProduct.Word.equiv</a> M : <a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M ≃ word M</code>.</li>
<li><code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> M i j</code>: an inductive description of non-empty words with first letter from
<code>M i</code> and last letter from <code>M j</code>, together with an API (<code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">singleton</a></code>, <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">append</a></code>, <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.head">head</a></code>, <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.tail">tail</a></code>,
<code>to_word</code>, <code><a href="../.././Init/Prelude.html#Prod">Prod</a></code>, <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv">inv</a></code>). Used in the proof of the Ping-Pong-lemma.</li>
<li><code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_injective_of_ping_pong">FreeProduct.lift_injective_of_ping_pong</a></code>: The Ping-Pong-lemma, proving injectivity of the
<code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift">lift</a></code>. See the documentation of that theorem for more information.</li>
</ul><h2 class="markdown-heading" id="Remarks">Remarks <a class="hover-link" href="#Remarks">#</a></h2><p>There are many answers to the question "what is the free product of a family <code>M</code> of monoids?", and
they are all equivalent but not obviously equivalent. We provide two answers. The first, almost
tautological answer is given by <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code>, which is a quotient of the type of words in the
alphabet <code>Σ i, M i</code>. It's straightforward to define and easy to prove its universal property. But
this answer is not completely satisfactory, because it's difficult to tell when two elements
<code>x y : <a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code> are distinct since <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code> is defined as a quotient.</p><p>The second, maximally efficient answer is given by <code>word M</code>. An element of <code>word M</code> is a word in the
alphabet <code>Σ i, M i</code>, where the letter <code>⟨i, 1⟩</code> doesn't occur and no adjacent letters share an index
<code>i</code>. Since we only work with reduced words, there is no need for quotienting, and it is easy to tell
when two elements are distinct. However it's not obvious that this is even a monoid!</p><p>We prove that every element of <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code> can be represented by a unique reduced word, i.e.
<code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code> and <code>word M</code> are equivalent types. This means that <code>word M</code> can be given a monoid
structure, and it lets us tell when two elements of <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code> are distinct.</p><p>There is also a completely tautological, maximally inefficient answer given by
<code>algebra.category.Mon.colimits</code>. Whereas <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> M</code> at least ensures that (any instance of)
associativity holds by reflexivity, in this answer associativity holds because of quotienting. Yet
another answer, which is constructively more satisfying, could be obtained by showing that
<code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Rel">FreeProduct.Rel</a></code> is confluent.</p><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><p>[van der Waerden, <em>Free products of groups</em>][MR25465]</p></div><div class="decl" id="FreeProduct.Rel"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L79-L83">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Rel"><span class="name">FreeProduct</span>.<span class="name">Rel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Algebra/FreeMonoid/Basic.html#FreeMonoid">FreeMonoid</a> (<span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>)</span> → <span class="fn"><a href="../.././Mathlib/Algebra/FreeMonoid/Basic.html#FreeMonoid">FreeMonoid</a> (<span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>)</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><ul class="constructors"><li class="constructor" id="FreeProduct.Rel.of_one">of_one: <span class="fn">∀ {<span class="fn">ι</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">M</span> : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>} [<span class="fn">inst</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>] (<span class="fn">i</span> : <span class="fn">ι</span>),
  <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Rel">FreeProduct.Rel</a> <span class="fn">M</span> (<span class="fn"><a href="../.././Mathlib/Algebra/FreeMonoid/Basic.html#FreeMonoid.of">FreeMonoid.of</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">1</span> }</span></span>) <span class="fn">1</span></span></span></li><li class="constructor" id="FreeProduct.Rel.of_mul">of_mul: <span class="fn">∀ {<span class="fn">ι</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">M</span> : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>} [<span class="fn">inst</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>] {<span class="fn">i</span> : <span class="fn">ι</span>} (<span class="fn">x </span>y : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>),
  <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Rel">FreeProduct.Rel</a> <span class="fn">M</span> (<span class="fn"><span class="fn"><a href="../.././Mathlib/Algebra/FreeMonoid/Basic.html#FreeMonoid.of">FreeMonoid.of</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">x</span> }</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../.././Mathlib/Algebra/FreeMonoid/Basic.html#FreeMonoid.of">FreeMonoid.of</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">y</span> }</span></span></span>)
    (<span class="fn"><a href="../.././Mathlib/Algebra/FreeMonoid/Basic.html#FreeMonoid.of">FreeMonoid.of</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">y</span></span> }</span></span>)</span></span></li></ul><p>A relation on the free monoid on alphabet <code>Σ i, M i</code>, relating <code>⟨i, 1⟩</code> with <code>1</code> and
<code>⟨i, x⟩ * ⟨i, y⟩</code> with <code>⟨i, x * y⟩</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.Rel" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L87-L88">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct"><span class="name">FreeProduct</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (maxu_1u_2)</div></div><p>The free product (categorical coproduct) of an indexed family of monoids.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/Congruence.html#Con.Quotient">Con.Quotient</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/Congruence.html#conGen">conGen</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Rel">FreeProduct.Rel</a> <span class="fn">M</span></span>)</span>)</span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct" class="instances-for-list"></ul></details></div></div><div class="decl" id="instMonoidFreeProduct"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L92-L93">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#instMonoidFreeProduct"><span class="name">instMonoidFreeProduct</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#instMonoidFreeProduct">instMonoidFreeProduct</a> <span class="fn">M</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#id">id</a> <span class="fn">inferInstance</span></span></span></li></ul></details></div></div><div class="decl" id="instInhabitedFreeProduct"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L95-L96">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#instInhabitedFreeProduct"><span class="name">instInhabitedFreeProduct</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#instInhabitedFreeProduct">instInhabitedFreeProduct</a> <span class="fn">M</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">1</span> }</span></span></li></ul></details></div></div><div class="decl" id="FreeProduct.Word.ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L102-L102">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.ext_iff"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">inst</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>} (<span class="fn">x </span>y : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>), <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">x</span>.toList</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.toList</span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L102-L102">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.ext"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">inst</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>} (<span class="fn">x </span>y : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.toList</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.toList</span></span> → <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L103-L110">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word"><span class="name">FreeProduct</span>.<span class="name">Word</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (maxu_1u_2)</div></div><ul class="structure_fields" id="FreeProduct.Word.mk"><li id="FreeProduct.Word.toList" class="structure_field"><div class="structure_field_doc"><p>A <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">Word</a></code> is a <code><a href="../.././Init/Prelude.html#List">List</a> (Σ i, M i)</code>, such that <code>1</code> is not in the list, and no
two adjacent letters are from the same summand</p></div><div class="structure_field_info">toList : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> (<span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>)</span></div></li><li id="FreeProduct.Word.ne_one" class="structure_field"><div class="structure_field_doc"><p>A reduced word does not contain <code>1</code></p></div><div class="structure_field_info">ne_one : <span class="fn">∀ (<span class="fn">l</span> : <span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>), <span class="fn"><span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toList</span></span> → <span class="fn"><span class="fn"><span class="fn">l</span>.snd</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span></span></span></div></li><li id="FreeProduct.Word.chain_ne" class="structure_field"><div class="structure_field_doc"><p>Adjacent letters are not from the same summand.</p></div><div class="structure_field_info">chain_ne : <span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Chain'">List.Chain'</a> (<span class="fn">fun <span class="fn">l</span> <span class="fn">l'</span> =&gt <span class="fn"><span class="fn"><span class="fn">l</span>.fst</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">l'</span>.fst</span></span></span>) <span class="fn">toList</span></span></div></li></ul><p>The type of reduced words. A reduced word cannot contain a letter <code>1</code>, and no two adjacent
letters can come from the same summand.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.Word" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.of"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L116-L120">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.of"><span class="name">FreeProduct</span>.<span class="name">of</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">M</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span></span></div></div><p>The inclusion of a summand into the free product.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.of" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.of_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L123-L124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.of_apply"><span class="name">FreeProduct</span>.<span class="name">of_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">FreeProduct.of</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">↑(<span class="fn"><a href="../.././Mathlib/GroupTheory/Congruence.html#Con.mk'">Con.mk'</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/Congruence.html#conGen">conGen</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Rel">FreeProduct.Rel</a> <span class="fn">M</span></span>)</span>)</span>) (<span class="fn"><a href="../.././Mathlib/Algebra/FreeMonoid/Basic.html#FreeMonoid.of">FreeMonoid.of</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">m</span> }</span></span>)</span></span></div></div></div></div><div class="decl" id="FreeProduct.ext_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L132-L136">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.ext_hom"><span class="name">FreeProduct</span>.<span class="name">ext_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{N : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">N</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">N</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom.comp">MonoidHom.comp</a> <span class="fn">f</span> <span class="fn">FreeProduct.of</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom.comp">MonoidHom.comp</a> <span class="fn">g</span> <span class="fn">FreeProduct.of</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div><p>See note [partially-applied ext lemmas].</p></div></div><div class="decl" id="FreeProduct.lift_symm_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L141-L141">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_symm_apply"><span class="name">FreeProduct</span>.<span class="name">lift_symm_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{N : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">N</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">ι</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn"><span class="fn">FreeProduct.lift</span>.symm</span> <span class="fn">f</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom.comp">MonoidHom.comp</a> <span class="fn">f</span> <span class="fn">FreeProduct.of</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.lift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L142-L163">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift"><span class="name">FreeProduct</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{N : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">M</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">N</span></span></span>) <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> (<span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">N</span></span>)</span></div></div><p>A map out of the free product corresponds to a family of maps out of the summands. This is the
universal property of the free product, characterizing it as a categorical coproduct.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.lift" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.lift_of"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L167-L168">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_of"><span class="name">FreeProduct</span>.<span class="name">lift_of</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{N : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(fi : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">M</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">N</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">fi</span></span>) (<span class="fn">↑<span class="fn">FreeProduct.of</span> <span class="fn">m</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">↑(<span class="fn"><span class="fn">fi</span> <span class="fn">i</span></span>) <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L172-L183">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.induction_on"><span class="name">FreeProduct</span>.<span class="name">induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_one : <span class="fn"><span class="fn">C</span> <span class="fn">1</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_of : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn">(<span class="fn">m</span> : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>) → <span class="fn"><span class="fn">C</span> (<span class="fn">↑<span class="fn">FreeProduct.of</span> <span class="fn">m</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_mul : <span class="fn">(<span class="fn">x </span>y : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span>) → <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">C</span> (<span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">y</span></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">C</span> <span class="fn">m</span></span></div></div></div></div><div class="decl" id="FreeProduct.of_leftInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L186-L188">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.of_leftInverse"><span class="name">FreeProduct</span>.<span class="name">of_leftInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">ι</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Function.html#Function.LeftInverse">Function.LeftInverse</a> <span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> (<span class="fn"><a href="../.././Mathlib/Data/Pi/Algebra.html#Pi.mulSingle">Pi.mulSingle</a> <span class="fn">i</span> (<span class="fn"><a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom.id">MonoidHom.id</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span>)</span>)</span>)</span> <span class="fn">↑<span class="fn">FreeProduct.of</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.of_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L191-L192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.of_injective"><span class="name">FreeProduct</span>.<span class="name">of_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">ι</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Function.html#Function.Injective">Function.Injective</a> <span class="fn">↑<span class="fn">FreeProduct.of</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.lift_mrange_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L195-L203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_mrange_le"><span class="name">FreeProduct</span>.<span class="name">lift_mrange_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{N : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">M</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">N</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/GroupTheory/Submonoid/Basic.html#Submonoid">Submonoid</a> <span class="fn">N</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/Submonoid/Operations.html#MonoidHom.mrange">MonoidHom.mrange</a> (<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>)</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/Submonoid/Operations.html#MonoidHom.mrange">MonoidHom.mrange</a> (<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>)</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="FreeProduct.mrange_eq_iSup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L206-L211">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.mrange_eq_iSup"><span class="name">FreeProduct</span>.<span class="name">mrange_eq_iSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{N : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">M</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">N</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/Submonoid/Operations.html#MonoidHom.mrange">MonoidHom.mrange</a> (<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨆ (i : <span class="fn">ι</span>), <span class="fn"><a href="../.././Mathlib/GroupTheory/Submonoid/Operations.html#MonoidHom.mrange">MonoidHom.mrange</a> (<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.instInvFreeProductToMonoidToDivInvMonoid"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L218-L220">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.instInvFreeProductToMonoidToDivInvMonoid"><span class="name">FreeProduct</span>.<span class="name">instInvFreeProductToMonoidToDivInvMonoid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Inv">Inv</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">G</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="FreeProduct.inv_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L222-L226">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.inv_def"><span class="name">FreeProduct</span>.<span class="name">inv_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span><a href="../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Algebra/Opposites.html#MulOpposite.unop">MulOpposite.unop</a>
    (<span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">fun <span class="fn">i</span> =&gt
          <span class="fn"><a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom.comp">MonoidHom.comp</a> (<span class="fn">↑<span class="fn">MonoidHom.op</span> <span class="fn">FreeProduct.of</span></span>) (<span class="fn"><a href="../.././Mathlib/Algebra/Hom/Equiv/Basic.html#MulEquiv.toMonoidHom">MulEquiv.toMonoidHom</a> (<span class="fn"><a href="../.././Mathlib/Algebra/Group/Opposite.html#MulEquiv.inv'">MulEquiv.inv'</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span>)</span>)</span></span></span>)
      <span class="fn">x</span></span>)</span></span></div></div></div></div><div class="decl" id="FreeProduct.instGroupFreeProductToMonoidToDivInvMonoid"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L229-L241">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.instGroupFreeProductToMonoidToDivInvMonoid"><span class="name">FreeProduct</span>.<span class="name">instGroupFreeProductToMonoidToDivInvMonoid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">G</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="FreeProduct.lift_range_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L243-L251">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_range_le"><span class="name">FreeProduct</span>.<span class="name">lift_range_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{N : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">G</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">N</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/GroupTheory/Subgroup/Basic.html#Subgroup">Subgroup</a> <span class="fn">N</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/Subgroup/Basic.html#MonoidHom.range">MonoidHom.range</a> (<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>)</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/Subgroup/Basic.html#MonoidHom.range">MonoidHom.range</a> (<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>)</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="FreeProduct.range_eq_iSup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L254-L258">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.range_eq_iSup"><span class="name">FreeProduct</span>.<span class="name">range_eq_iSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{N : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">G</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">N</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/Subgroup/Basic.html#MonoidHom.range">MonoidHom.range</a> (<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨆ (i : <span class="fn">ι</span>), <span class="fn"><a href="../.././Mathlib/GroupTheory/Subgroup/Basic.html#MonoidHom.range">MonoidHom.range</a> (<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.empty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L266-L269">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.empty"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span></div></div><p>The empty reduced word.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">FreeProduct.Word.empty</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">toList</span> := <span class="fn">[]</span>, <span class="fn">ne_one</span> := <span class="fn">(_ : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">[]</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><span class="fn">a</span>.snd</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">1</span></span></span></span></span>)</span>,
    <span class="fn">chain_ne</span> := <span class="fn">(_ : <span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Chain'">List.Chain'</a> (<span class="fn">fun <span class="fn">l</span> <span class="fn">l'</span> =&gt <span class="fn"><span class="fn"><span class="fn">l</span>.fst</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">l'</span>.fst</span></span></span>) <span class="fn">[]</span></span>)</span> }</span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.Word.empty" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.Word.instInhabitedWord"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L272-L273">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.instInhabitedWord"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">instInhabitedWord</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">FreeProduct.Word.instInhabitedWord</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">FreeProduct.Word.empty</span> }</span></span></li></ul></details></div></div><div class="decl" id="FreeProduct.Word.prod"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L276-L277">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span></div></div><p>A reduced word determines an element of the free product, given by multiplication.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod">FreeProduct.Word.prod</a> <span class="fn">w</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Data/List/Defs.html#List.prod">List.prod</a> (<span class="fn"><a href="../.././Init/Data/List/Basic.html#List.map">List.map</a> (<span class="fn">fun <span class="fn">l</span> =&gt <span class="fn">↑<span class="fn">FreeProduct.of</span> <span class="fn"><span class="fn">l</span>.snd</span></span></span>) <span class="fn"><span class="fn">w</span>.toList</span></span>)</span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.Word.prod" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.Word.prod_empty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L281-L282">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod_empty"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">prod_empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod">FreeProduct.Word.prod</a> <span class="fn">FreeProduct.Word.empty</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">1</span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.fstIdx"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L287-L288">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.fstIdx"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">fstIdx</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <span class="fn">ι</span></span></div></div><p><code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.fstIdx">fstIdx</a> w</code> is <code>some i</code> if the first letter of <code>w</code> is <code>⟨i, m⟩</code> with <code>m : M i</code>. If <code>w</code> is empty
then it's <code>none</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.fstIdx">FreeProduct.Word.fstIdx</a> <span class="fn">w</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">Sigma.fst</span> (<span class="fn"><a href="../.././Init/Data/List/BasicAux.html#List.head?">List.head?</a> <span class="fn"><span class="fn">w</span>.toList</span></span>)</span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.Word.fstIdx" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.Word.fstIdx_ne_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L291-L293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.fstIdx_ne_iff"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">fstIdx_ne_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.fstIdx">FreeProduct.Word.fstIdx</a> <span class="fn">w</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><a href="../.././Init/Prelude.html#Option.some">some</a> <span class="fn">i</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">l</span> : <span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>), <span class="fn"><span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Init/Data/List/BasicAux.html#List.head?">List.head?</a> <span class="fn"><span class="fn">w</span>.toList</span></span></span> → <span class="fn"><span class="fn">i</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">l</span>.fst</span></span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.Pair.ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L302-L302">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.ext_iff"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">Pair</span>.<span class="name">ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">inst</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>} {<span class="fn">i</span> : <span class="fn">ι</span>} (<span class="fn">x </span>y : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair">FreeProduct.Word.Pair</a> <span class="fn">M</span> <span class="fn">i</span></span>), <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.head</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.head</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">x</span>.tail</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.tail</span></span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.Pair.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L302-L302">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.ext"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">Pair</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">inst</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>} {<span class="fn">i</span> : <span class="fn">ι</span>} (<span class="fn">x </span>y : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair">FreeProduct.Word.Pair</a> <span class="fn">M</span> <span class="fn">i</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.head</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.head</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.tail</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.tail</span></span> → <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.Pair"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L303-L309">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">Pair</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">ι</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (maxu_1u_2)</div></div><ul class="structure_fields" id="FreeProduct.Word.Pair.mk"><li id="FreeProduct.Word.Pair.head" class="structure_field"><div class="structure_field_doc"><p>An element of <code>M i</code>, the first letter of the word.</p></div><div class="structure_field_info">head : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></div></li><li id="FreeProduct.Word.Pair.tail" class="structure_field"><div class="structure_field_doc"><p>The remaining letters of the word, excluding the first letter</p></div><div class="structure_field_info">tail : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span></div></li><li id="FreeProduct.Word.Pair.fstIdx_ne" class="structure_field"><div class="structure_field_doc"><p>The index first letter of tail of a <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair">Pair</a> M i</code> is not equal to <code>i</code></p></div><div class="structure_field_info">fstIdx_ne : <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.fstIdx">FreeProduct.Word.fstIdx</a> <span class="fn">tail</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><a href="../.././Init/Prelude.html#Option.some">some</a> <span class="fn">i</span></span></span></div></li></ul><p>Given an index <code>i : ι</code>, <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair">Pair</a> M i</code> is the type of pairs <code>(head, tail)</code> where <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.head">head</a> : M i</code> and
<code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.tail">tail</a> : <a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">Word</a> M</code>, subject to the constraint that first letter of <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.tail">tail</a></code> can't be <code>⟨i, m⟩</code>.
By prepending <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.head">head</a></code> to <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.tail">tail</a></code>, one obtains a new word. We'll show that any word can be uniquely
obtained in this way.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.Word.Pair" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.Word.instInhabitedPair"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L312-L313">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.instInhabitedPair"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">instInhabitedPair</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">ι</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair">FreeProduct.Word.Pair</a> <span class="fn">M</span> <span class="fn">i</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="FreeProduct.Word.rcons"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L322-L331">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.rcons"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">rcons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair">FreeProduct.Word.Pair</a> <span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span></div></div><p>Given a pair <code>(head, tail)</code>, we can form a word by prepending <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.head">head</a></code> to <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.tail">tail</a></code>, except if <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair.head">head</a></code>
is <code>1 : M i</code> then we have to just return <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">Word</a></code> since we need the result to be reduced.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.Word.rcons" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.Word.cons_eq_rcons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L340-L344">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.cons_eq_rcons"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">cons_eq_rcons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ls : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> (<span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h1 : <span class="fn">∀ (<span class="fn">l</span> : <span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>), <span class="fn"><span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">m</span> }</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">ls</span></span></span> → <span class="fn"><span class="fn"><span class="fn">l</span>.snd</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h2 : <span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Chain'">List.Chain'</a> (<span class="fn">fun <span class="fn">l</span> <span class="fn">l'</span> =&gt <span class="fn"><span class="fn"><span class="fn">l</span>.fst</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">l'</span>.fst</span></span></span>) (<span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">m</span> }</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">ls</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">toList</span> := <span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">m</span> }</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">ls</span></span>, <span class="fn">ne_one</span> := <span class="fn">h1</span>, <span class="fn">chain_ne</span> := <span class="fn">h2</span> }</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.rcons">FreeProduct.Word.rcons</a>
    <span class="fn">{ <span class="fn">head</span> := <span class="fn">m</span>, <span class="fn">tail</span> := <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#_private.Mathlib.GroupTheory.FreeProduct.0.FreeProduct.Word.mkAux">FreeProduct.Word.mkAux</a> <span class="fn">ls</span> <span class="fn">h1</span> <span class="fn">h2</span></span>,
      <span class="fn">fstIdx_ne</span> := <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.fstIdx">FreeProduct.Word.fstIdx</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#_private.Mathlib.GroupTheory.FreeProduct.0.FreeProduct.Word.mkAux">FreeProduct.Word.mkAux</a> <span class="fn">ls</span> <span class="fn">h1</span> <span class="fn">h2</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><a href="../.././Init/Prelude.html#Option.some">some</a> <span class="fn">i</span></span></span>)</span> }</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.prod_rcons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L348-L350">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod_rcons"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">prod_rcons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair">FreeProduct.Word.Pair</a> <span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod">FreeProduct.Word.prod</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.rcons">FreeProduct.Word.rcons</a> <span class="fn">p</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">↑<span class="fn">FreeProduct.of</span> <span class="fn"><span class="fn">p</span>.head</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod">FreeProduct.Word.prod</a> <span class="fn"><span class="fn">p</span>.tail</span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.rcons_inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L353-L371">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.rcons_inj"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">rcons_inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Function.html#Function.Injective">Function.Injective</a> <span class="fn">FreeProduct.Word.rcons</span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.equivPair"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L394-L398">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.equivPair"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">equivPair</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">ι</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair">FreeProduct.Word.Pair</a> <span class="fn">M</span> <span class="fn">i</span></span></span></div></div><p>The equivalence between words and pairs. Given a word, it decomposes it as a pair by removing
the first letter if it comes from <code>M i</code>. Given a pair, it prepends the head to the tail.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.Word.equivPair" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.Word.equivPair_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L401-L402">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.equivPair_symm"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">equivPair_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">ι</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.Pair">FreeProduct.Word.Pair</a> <span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">(<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.equivPair">FreeProduct.Word.equivPair</a> <span class="fn">i</span></span>).symm</span> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.rcons">FreeProduct.Word.rcons</a> <span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.equivPair_eq_of_fstIdx_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L405-L407">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.equivPair_eq_of_fstIdx_ne"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">equivPair_eq_of_fstIdx_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.fstIdx">FreeProduct.Word.fstIdx</a> <span class="fn">w</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><a href="../.././Init/Prelude.html#Option.some">some</a> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.equivPair">FreeProduct.Word.equivPair</a> <span class="fn">i</span></span>) <span class="fn">w</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">head</span> := <span class="fn">1</span>, <span class="fn">tail</span> := <span class="fn">w</span>, <span class="fn">fstIdx_ne</span> := <span class="fn">h</span> }</span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.summandAction"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L410-L417">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.summandAction"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">summandAction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">ι</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction">MulAction</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>) (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="FreeProduct.Word.instMulActionFreeProductWordInstMonoidFreeProduct"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L420-L421">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.instMulActionFreeProductWordInstMonoidFreeProduct"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">instMulActionFreeProductWordInstMonoidFreeProduct</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction">MulAction</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span>) (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">FreeProduct.Word.instMulActionFreeProductWordInstMonoidFreeProduct</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction.ofEndHom">MulAction.ofEndHom</a> (<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">MulAction.toEndHom</span></span></span>)</span></span></li></ul></details></div></div><div class="decl" id="FreeProduct.Word.of_smul_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L423-L425">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.of_smul_def"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">of_smul_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">ι</span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">↑<span class="fn">FreeProduct.of</span> <span class="fn">m</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">w</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.rcons">FreeProduct.Word.rcons</a>
    (<span class="fn">let src := <span class="fn">↑(<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.equivPair">FreeProduct.Word.equivPair</a> <span class="fn">i</span></span>) <span class="fn">w</span></span>;
    <span class="fn">{ <span class="fn">head</span> := <span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">(<span class="fn">↑(<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.equivPair">FreeProduct.Word.equivPair</a> <span class="fn">i</span></span>) <span class="fn">w</span></span>).head</span></span>, <span class="fn">tail</span> := <span class="fn"><span class="fn">src</span>.tail</span>,
      <span class="fn">fstIdx_ne</span> := <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.fstIdx">FreeProduct.Word.fstIdx</a> <span class="fn"><span class="fn">src</span>.tail</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><a href="../.././Init/Prelude.html#Option.some">some</a> <span class="fn">i</span></span></span>)</span> }</span></span>)</span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.cons_eq_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L428-L433">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.cons_eq_smul"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">cons_eq_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ls : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> (<span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h1 : <span class="fn">∀ (<span class="fn">l</span> : <span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>), <span class="fn"><span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">m</span> }</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">ls</span></span></span> → <span class="fn"><span class="fn"><span class="fn">l</span>.snd</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h2 : <span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Chain'">List.Chain'</a> (<span class="fn">fun <span class="fn">l</span> <span class="fn">l'</span> =&gt <span class="fn"><span class="fn"><span class="fn">l</span>.fst</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">l'</span>.fst</span></span></span>) (<span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">m</span> }</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">ls</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">toList</span> := <span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">m</span> }</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">ls</span></span>, <span class="fn">ne_one</span> := <span class="fn">h1</span>, <span class="fn">chain_ne</span> := <span class="fn">h2</span> }</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">↑<span class="fn">FreeProduct.of</span> <span class="fn">m</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#_private.Mathlib.GroupTheory.FreeProduct.0.FreeProduct.Word.mkAux">FreeProduct.Word.mkAux</a> <span class="fn">ls</span> <span class="fn">h1</span> <span class="fn">h2</span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.smul_induction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L436-L443">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.smul_induction"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">smul_induction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_empty : <span class="fn"><span class="fn">C</span> <span class="fn">FreeProduct.Word.empty</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_smul : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn">(<span class="fn">m</span> : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>) → <span class="fn">(<span class="fn">w</span> : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>) → <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">w</span></span> → <span class="fn"><span class="fn">C</span> (<span class="fn"><span class="fn">↑<span class="fn">FreeProduct.of</span> <span class="fn">m</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">w</span></span>)</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">C</span> <span class="fn">w</span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.prod_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L447-L458">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod_smul"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">prod_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod">FreeProduct.Word.prod</a> (<span class="fn"><span class="fn">m</span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod">FreeProduct.Word.prod</a> <span class="fn">w</span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.Word.equiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L462-L472">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.equiv"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">equiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span></span></div></div><p>Each element of the free product corresponds to a unique reduced word.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.Word.equiv" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.Word.instDecidableEqWord"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L475-L476">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.instDecidableEqWord"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">instDecidableEqWord</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">FreeProduct.Word.instDecidableEqWord</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Logic/Function/Basic.html#Function.Injective.decidableEq">Function.Injective.decidableEq</a> <span class="fn">(_ : <span class="fn">∀ (<span class="fn">x </span>y : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.toList</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.toList</span></span> → <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="FreeProduct.Word.instDecidableEqFreeProduct"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L478-L479">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.instDecidableEqFreeProduct"><span class="name">FreeProduct</span>.<span class="name">Word</span>.<span class="name">instDecidableEqFreeProduct</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">FreeProduct.Word.instDecidableEqFreeProduct</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv.decidableEq">Equiv.decidableEq</a> <span class="fn">FreeProduct.Word.equiv</span></span></span></li></ul></details></div></div><div class="decl" id="FreeProduct.NeWord"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L489-L491">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord"><span class="name">FreeProduct</span>.<span class="name">NeWord</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">ι</span> → <span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> (maxu_1u_2)</span></div></div><ul class="constructors"><li class="constructor" id="FreeProduct.NeWord.singleton">singleton: <span class="fn">{<span class="fn">ι</span> : <a href="../.././foundational_types.html">Type</a> u_1} →
  <span class="fn">{<span class="fn">M</span> : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>} → <span class="fn">[<span class="fn">inst</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>] → <span class="fn">{<span class="fn">i</span> : <span class="fn">ι</span>} → <span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>) → <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span> → <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">i</span></span></span></span></span></span></span></span></li><li class="constructor" id="FreeProduct.NeWord.append">append: <span class="fn">{<span class="fn">ι</span> : <a href="../.././foundational_types.html">Type</a> u_1} →
  <span class="fn">{<span class="fn">M</span> : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>} →
    <span class="fn">[<span class="fn">inst</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>] →
      <span class="fn">{<span class="fn">i </span>j k l : <span class="fn">ι</span>} → <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span> → <span class="fn"><span class="fn"><span class="fn">j</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">k</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">k</span> <span class="fn">l</span></span> → <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">l</span></span></span></span></span></span></span></span></span></li></ul><p>A <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">NeWord</a> M i j</code> is a representation of a non-empty reduced words where the first letter comes
from <code>M i</code> and the last letter comes from <code>M j</code>. It can be constructed from singletons and via
concatenation, and thus provides a useful induction principle.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.NeWord" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.NeWord.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L502-L504">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(_w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> (<span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></span>)</span></div></div><p>The list represented by a given <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">NeWord</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList">FreeProduct.NeWord.toList</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">FreeProduct.NeWord.singleton</a> <span class="fn">x_3</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">[<span class="fn">{ <span class="fn">fst</span> := <span class="fn">x</span>, <span class="fn">snd</span> := <span class="fn">x_3</span> }</span>]</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList">FreeProduct.NeWord.toList</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">FreeProduct.NeWord.append</a> <span class="fn">w₁</span> <span class="fn">_hne</span> <span class="fn">w₂</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList">FreeProduct.NeWord.toList</a> <span class="fn">w₁</span></span> <a href="../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList">FreeProduct.NeWord.toList</a> <span class="fn">w₂</span></span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.NeWord.toList" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.NeWord.toList_ne_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L507-L511">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList_ne_nil"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">toList_ne_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList">FreeProduct.NeWord.toList</a> <span class="fn">w</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">[]</span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.head"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L516-L518">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(_w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">M</span> <span class="fn">i</span></span></div></div><p>The first letter of a <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">NeWord</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">FreeProduct.NeWord.singleton</a> <span class="fn">x_3</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x_3</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">FreeProduct.NeWord.append</a> <span class="fn">w₁</span> <span class="fn">_hne</span> <span class="fn">w₂</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> <span class="fn">w₁</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.NeWord.head" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.NeWord.last"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L523-L525">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.last"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">last</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(_w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">M</span> <span class="fn">j</span></span></div></div><p>The last letter of a <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">NeWord</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.last">FreeProduct.NeWord.last</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">FreeProduct.NeWord.singleton</a> <span class="fn">x_3</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x_3</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.last">FreeProduct.NeWord.last</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">FreeProduct.NeWord.append</a> <span class="fn">w₁</span> <span class="fn">_hne</span> <span class="fn">w₂</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.last">FreeProduct.NeWord.last</a> <span class="fn">w₂</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.NeWord.last" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.NeWord.toList_head?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L529-L534">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList_head?"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">toList_head?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Data/List/BasicAux.html#List.head?">List.head?</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList">FreeProduct.NeWord.toList</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Option.some">some</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> <span class="fn">w</span></span> }</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.toList_getLast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L538-L543">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList_getLast?"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">toList_getLast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Data/List/BasicAux.html#List.getLast?">List.getLast?</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toList">FreeProduct.NeWord.toList</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Option.some">some</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">j</span>, <span class="fn">snd</span> := <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.last">FreeProduct.NeWord.last</a> <span class="fn">w</span></span> }</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.toWord"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L547-L565">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toWord"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">toWord</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span></div></div><p>The <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">Word</a> M</code> represented by a <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">NeWord</a> M i j</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.NeWord.toWord" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.NeWord.of_word"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L569-L587">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.of_word"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">of_word</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">w</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">FreeProduct.Word.empty</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">i</span> <span class="fn">j</span> <span class="fn">w'</span>, <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toWord">FreeProduct.NeWord.toWord</a> <span class="fn">w'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">w</span></span></span></div></div><p>Every nonempty <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">Word</a> M</code> can be constructed as a <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">NeWord</a> M i j</code></p></div></div><div class="decl" id="FreeProduct.NeWord.prod"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L591-L592">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">M</span></span></div></div><p>A non-empty reduced word determines an element of the free product, given by multiplication.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> <span class="fn">w</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod">FreeProduct.Word.prod</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.toWord">FreeProduct.NeWord.toWord</a> <span class="fn">w</span></span>)</span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.NeWord.prod" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.NeWord.singleton_head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L596-L597">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton_head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">singleton_head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hne_one : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">FreeProduct.NeWord.singleton</a> <span class="fn">x</span> <span class="fn">hne_one</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.singleton_last"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L601-L602">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton_last"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">singleton_last</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hne_one : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.last">FreeProduct.NeWord.last</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">FreeProduct.NeWord.singleton</a> <span class="fn">x</span> <span class="fn">hne_one</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.prod_singleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L606-L607">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod_singleton"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">prod_singleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hne_one : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">FreeProduct.NeWord.singleton</a> <span class="fn">x</span> <span class="fn">hne_one</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">↑<span class="fn">FreeProduct.of</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.append_head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L611-L613">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append_head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">append_head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hne : <span class="fn"><span class="fn">j</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₂ : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">k</span> <span class="fn">l</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">FreeProduct.NeWord.append</a> <span class="fn">w₁</span> <span class="fn">hne</span> <span class="fn">w₂</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> <span class="fn">w₁</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.append_last"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L617-L619">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append_last"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">append_last</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hne : <span class="fn"><span class="fn">j</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₂ : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">k</span> <span class="fn">l</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.last">FreeProduct.NeWord.last</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">FreeProduct.NeWord.append</a> <span class="fn">w₁</span> <span class="fn">hne</span> <span class="fn">w₂</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.last">FreeProduct.NeWord.last</a> <span class="fn">w₂</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.append_prod"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L623-L624">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append_prod"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">append_prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hne : <span class="fn"><span class="fn">j</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₂ : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">k</span> <span class="fn">l</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">FreeProduct.NeWord.append</a> <span class="fn">w₁</span> <span class="fn">hne</span> <span class="fn">w₂</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> <span class="fn">w₁</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> <span class="fn">w₂</span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.replaceHead"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L629-L631">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.replaceHead"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">replaceHead</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(_hnotone : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(_w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span></div></div><p>One can replace the first letter in a non-empty reduced word by an element of the same
group</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.replaceHead">FreeProduct.NeWord.replaceHead</a> <span class="fn">x_1</span> <span class="fn">x_2</span> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">FreeProduct.NeWord.singleton</a> <span class="fn">x_7</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">FreeProduct.NeWord.singleton</a> <span class="fn">x_1</span> <span class="fn">x_2</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.replaceHead">FreeProduct.NeWord.replaceHead</a> <span class="fn">x_2</span> <span class="fn">x_3</span> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">FreeProduct.NeWord.append</a> <span class="fn">w₁</span> <span class="fn">hne</span> <span class="fn">w₂</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">FreeProduct.NeWord.append</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.replaceHead">FreeProduct.NeWord.replaceHead</a> <span class="fn">x_2</span> <span class="fn">x_3</span> <span class="fn">w₁</span></span>) <span class="fn">hne</span> <span class="fn">w₂</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.NeWord.replaceHead" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.NeWord.replaceHead_head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L635-L639">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.replaceHead_head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">replaceHead_head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hnotone : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.replaceHead">FreeProduct.NeWord.replaceHead</a> <span class="fn">x</span> <span class="fn">hnotone</span> <span class="fn">w</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.mulHead"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L644-L645">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.mulHead"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">mulHead</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hnotone : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> <span class="fn">w</span></span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span></div></div><p>One can multiply an element from the left to a non-empty reduced word if it does not cancel
with the first element in the word.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.mulHead">FreeProduct.NeWord.mulHead</a> <span class="fn">w</span> <span class="fn">x</span> <span class="fn">hnotone</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.replaceHead">FreeProduct.NeWord.replaceHead</a> (<span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> <span class="fn">w</span></span></span>) <span class="fn">hnotone</span> <span class="fn">w</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.NeWord.mulHead" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.NeWord.mulHead_head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L649-L653">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.mulHead_head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">mulHead_head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hnotone : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> <span class="fn">w</span></span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.mulHead">FreeProduct.NeWord.mulHead</a> <span class="fn">w</span> <span class="fn">x</span> <span class="fn">hnotone</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> <span class="fn">w</span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.mulHead_prod"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L657-L665">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.mulHead_prod"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">mulHead_prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Monoid">Monoid</a> (<span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">M</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">M</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hnotone : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> <span class="fn">w</span></span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.mulHead">FreeProduct.NeWord.mulHead</a> <span class="fn">w</span> <span class="fn">x</span> <span class="fn">hnotone</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">↑<span class="fn">FreeProduct.of</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> <span class="fn">w</span></span></span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.inv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L673-L675">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(_w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">G</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">G</span> <span class="fn">j</span> <span class="fn">i</span></span></div></div><p>The inverse of a non-empty reduced word</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv">FreeProduct.NeWord.inv</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">FreeProduct.NeWord.singleton</a> <span class="fn">x_4</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.singleton">FreeProduct.NeWord.singleton</a> <span class="fn"><span class="fn">x_4</span><a href="../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <span class="fn">(_ : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><span class="fn">x_4</span><a href="../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">1</span></span></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv">FreeProduct.NeWord.inv</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">FreeProduct.NeWord.append</a> <span class="fn">w₁</span> <span class="fn">h</span> <span class="fn">w₂</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.append">FreeProduct.NeWord.append</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv">FreeProduct.NeWord.inv</a> <span class="fn">w₂</span></span>) <span class="fn">(_ : <span class="fn"><span class="fn">k</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">j</span></span>)</span> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv">FreeProduct.NeWord.inv</a> <span class="fn">w₁</span></span>)</span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-FreeProduct.NeWord.inv" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeProduct.NeWord.inv_prod"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L679-L680">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv_prod"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">inv_prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">G</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv">FreeProduct.NeWord.inv</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> <span class="fn">w</span></span>)<a href="../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.inv_head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L684-L685">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv_head"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">inv_head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">G</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv">FreeProduct.NeWord.inv</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.last">FreeProduct.NeWord.last</a> <span class="fn">w</span></span>)<a href="../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span></span></div></div></div></div><div class="decl" id="FreeProduct.NeWord.inv_last"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L689-L690">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv_last"><span class="name">FreeProduct</span>.<span class="name">NeWord</span>.<span class="name">inv_last</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">G</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.last">FreeProduct.NeWord.last</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.inv">FreeProduct.NeWord.inv</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.head">FreeProduct.NeWord.head</a> <span class="fn">w</span></span>)<a href="../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span></span></div></div></div></div><div class="decl" id="FreeProduct.lift_word_ping_pong"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L727-L735">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_word_ping_pong"><span class="name">FreeProduct</span>.<span class="name">lift_word_ping_pong</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> <span class="fn">G</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">H</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">G</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction">MulAction</a> <span class="fn">G</span> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpp : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>), <span class="fn"><span class="fn"><span class="fn">h</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span> → <span class="fn"><span class="fn"><span class="fn">↑(<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>) <span class="fn">h</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span></span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">H</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hk : <span class="fn"><span class="fn">j</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">k</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>) (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> <span class="fn">w</span></span>)</span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn">X</span> <span class="fn">k</span></span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.lift_word_prod_nontrivial_of_other_i"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L740-L745">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_word_prod_nontrivial_of_other_i"><span class="name">FreeProduct</span>.<span class="name">lift_word_prod_nontrivial_of_other_i</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> <span class="fn">G</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">H</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">G</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction">MulAction</a> <span class="fn">G</span> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXnonempty : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../.././Mathlib/Data/Set/Basic.html#Set.Nonempty">Set.Nonempty</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXdisj : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn"><a href="../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpp : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>), <span class="fn"><span class="fn"><span class="fn">h</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span> → <span class="fn"><span class="fn"><span class="fn">↑(<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>) <span class="fn">h</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span></span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">H</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hhead : <span class="fn"><span class="fn">k</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hlast : <span class="fn"><span class="fn">k</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>) (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span></div></div></div></div><div class="decl" id="FreeProduct.lift_word_prod_nontrivial_of_head_eq_last"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L750-L752">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_word_prod_nontrivial_of_head_eq_last"><span class="name">FreeProduct</span>.<span class="name">lift_word_prod_nontrivial_of_head_eq_last</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[hnontriv : <span class="fn"><a href="../.././Mathlib/Logic/Nontrivial.html#Nontrivial">Nontrivial</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> <span class="fn">G</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">H</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">G</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction">MulAction</a> <span class="fn">G</span> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXnonempty : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../.././Mathlib/Data/Set/Basic.html#Set.Nonempty">Set.Nonempty</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXdisj : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn"><a href="../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpp : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>), <span class="fn"><span class="fn"><span class="fn">h</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span> → <span class="fn"><span class="fn"><span class="fn">↑(<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>) <span class="fn">h</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span></span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">H</span> <span class="fn">i</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>) (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span></div></div></div></div><div class="decl" id="FreeProduct.lift_word_prod_nontrivial_of_head_card"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L755-L768">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_word_prod_nontrivial_of_head_card"><span class="name">FreeProduct</span>.<span class="name">lift_word_prod_nontrivial_of_head_card</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[hnontriv : <span class="fn"><a href="../.././Mathlib/Logic/Nontrivial.html#Nontrivial">Nontrivial</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> <span class="fn">G</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">H</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">G</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction">MulAction</a> <span class="fn">G</span> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXnonempty : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../.././Mathlib/Data/Set/Basic.html#Set.Nonempty">Set.Nonempty</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXdisj : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn"><a href="../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpp : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>), <span class="fn"><span class="fn"><span class="fn">h</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span> → <span class="fn"><span class="fn"><span class="fn">↑(<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>) <span class="fn">h</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span></span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">H</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hcard : <span class="fn"><span class="fn">3</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk">Cardinal.mk</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hheadtail : <span class="fn"><span class="fn">i</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>) (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span></div></div></div></div><div class="decl" id="FreeProduct.lift_word_prod_nontrivial_of_not_empty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L773-L803">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_word_prod_nontrivial_of_not_empty"><span class="name">FreeProduct</span>.<span class="name">lift_word_prod_nontrivial_of_not_empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[hnontriv : <span class="fn"><a href="../.././Mathlib/Logic/Nontrivial.html#Nontrivial">Nontrivial</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> <span class="fn">G</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">H</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">G</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hcard : <span class="fn"><span class="fn"><span class="fn">3</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk">Cardinal.mk</a> <span class="fn">ι</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ <span class="fn">i</span>, <span class="fn"><span class="fn">3</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk">Cardinal.mk</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction">MulAction</a> <span class="fn">G</span> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXnonempty : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../.././Mathlib/Data/Set/Basic.html#Set.Nonempty">Set.Nonempty</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXdisj : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn"><a href="../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpp : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>), <span class="fn"><span class="fn"><span class="fn">h</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span> → <span class="fn"><span class="fn"><span class="fn">↑(<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>) <span class="fn">h</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span></span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">ι</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">ι</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord">FreeProduct.NeWord</a> <span class="fn">H</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>) (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.NeWord.prod">FreeProduct.NeWord.prod</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span></div></div></div></div><div class="decl" id="FreeProduct.empty_of_word_prod_eq_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L806-L809">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.empty_of_word_prod_eq_one"><span class="name">FreeProduct</span>.<span class="name">empty_of_word_prod_eq_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[hnontriv : <span class="fn"><a href="../.././Mathlib/Logic/Nontrivial.html#Nontrivial">Nontrivial</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> <span class="fn">G</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">H</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">G</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hcard : <span class="fn"><span class="fn"><span class="fn">3</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk">Cardinal.mk</a> <span class="fn">ι</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ <span class="fn">i</span>, <span class="fn"><span class="fn">3</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk">Cardinal.mk</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction">MulAction</a> <span class="fn">G</span> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXnonempty : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../.././Mathlib/Data/Set/Basic.html#Set.Nonempty">Set.Nonempty</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXdisj : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn"><a href="../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpp : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>), <span class="fn"><span class="fn"><span class="fn">h</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span> → <span class="fn"><span class="fn"><span class="fn">↑(<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>) <span class="fn">h</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span></span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word">FreeProduct.Word</a> <span class="fn">H</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>) (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.Word.prod">FreeProduct.Word.prod</a> <span class="fn">w</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">w</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">FreeProduct.Word.empty</span></span></div></div></div></div><div class="decl" id="FreeProduct.lift_injective_of_ping_pong"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L825-L832">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift_injective_of_ping_pong"><span class="name">FreeProduct</span>.<span class="name">lift_injective_of_ping_pong</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[hnontriv : <span class="fn"><a href="../.././Mathlib/Logic/Nontrivial.html#Nontrivial">Nontrivial</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> <span class="fn">G</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">H</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Hom/Group.html#MonoidHom">→*</a> <span class="fn">G</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hcard : <span class="fn"><span class="fn"><span class="fn">3</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk">Cardinal.mk</a> <span class="fn">ι</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ <span class="fn">i</span>, <span class="fn"><span class="fn">3</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk">Cardinal.mk</a> (<span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>)</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction">MulAction</a> <span class="fn">G</span> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXnonempty : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../.././Mathlib/Data/Set/Basic.html#Set.Nonempty">Set.Nonempty</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXdisj : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn"><a href="../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpp : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><span class="fn">H</span> <span class="fn">i</span></span>), <span class="fn"><span class="fn"><span class="fn">h</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">1</span></span> → <span class="fn"><span class="fn"><span class="fn">↑(<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>) <span class="fn">h</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Function.html#Function.Injective">Function.Injective</a> <span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">f</span></span>)</span></span></div></div><p>The Ping-Pong-Lemma.</p><p>Given a group action of <code>G</code> on <code>X</code> so that the <code>H i</code> acts in a specific way on disjoint subsets
<code>X i</code> we can prove that <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift">lift</a> f</code> is injective, and thus the image of <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift">lift</a> f</code> is isomorphic to the
free product of the <code>H i</code>.</p><p>Often the Ping-Pong-Lemma is stated with regard to subgroups <code>H i</code> that generate the whole group;
we generalize to arbitrary group homomorphisms <code>f i : H i →* G</code> and do not require the group to be
generated by the images.</p><p>Usually the Ping-Pong-Lemma requires that one group <code>H i</code> has at least three elements. This
condition is only needed if <code># ι = 2</code>, and we accept <code>3 ≤ # ι</code> as an alternative.</p></div></div><div class="decl" id="FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_MulEquiv'_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L838-L838">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_MulEquiv'_apply"><span class="name">FreeProduct</span>.<span class="name">instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_MulEquiv'_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[hG : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/GroupTheory/IsFreeGroup.html#IsFreeGroup">IsFreeGroup</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeGroup.html#FreeGroup">FreeGroup</a> (<span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><a href="../.././Mathlib/GroupTheory/IsFreeGroup.html#IsFreeGroup.Generators">IsFreeGroup.Generators</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">IsFreeGroup.MulEquiv'</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">↑(<span class="fn">↑<span class="fn">FreeGroup.lift</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">↑<span class="fn">FreeProduct.of</span> (<span class="fn"><a href="../.././Mathlib/GroupTheory/IsFreeGroup.html#IsFreeGroup.of">IsFreeGroup.of</a> <span class="fn"><span class="fn">x</span>.snd</span></span>)</span></span></span>) <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_MulEquiv'_symm_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L838-L838">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_MulEquiv'_symm_apply"><span class="name">FreeProduct</span>.<span class="name">instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_MulEquiv'_symm_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[hG : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/GroupTheory/IsFreeGroup.html#IsFreeGroup">IsFreeGroup</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Algebra/Hom/Equiv/Basic.html#MulEquiv.symm">MulEquiv.symm</a> <span class="fn">IsFreeGroup.MulEquiv'</span></span>) <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">fun <span class="fn">i</span> =&gt <span class="fn">↑<span class="fn">IsFreeGroup.lift</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeGroup.html#FreeGroup.of">FreeGroup.of</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">i</span>, <span class="fn">snd</span> := <span class="fn">x</span> }</span></span></span></span></span></span>) <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_Generators"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L838-L838">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_Generators"><span class="name">FreeProduct</span>.<span class="name">instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid_Generators</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[hG : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/GroupTheory/IsFreeGroup.html#IsFreeGroup">IsFreeGroup</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/IsFreeGroup.html#IsFreeGroup.Generators">IsFreeGroup.Generators</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">G</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">(i : <span class="fn">ι</span>) × <span class="fn"><a href="../.././Mathlib/GroupTheory/IsFreeGroup.html#IsFreeGroup.Generators">IsFreeGroup.Generators</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>)</span></div></div></div></div><div class="decl" id="FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L839-L851">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid"><span class="name">FreeProduct</span>.<span class="name">instIsFreeGroupFreeProductToMonoidToDivInvMonoidInstGroupFreeProductToMonoidToDivInvMonoid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><span class="fn">ι</span> → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[hG : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../.././Mathlib/GroupTheory/IsFreeGroup.html#IsFreeGroup">IsFreeGroup</a> (<span class="fn"><span class="fn">G</span> <span class="fn">i</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/GroupTheory/IsFreeGroup.html#IsFreeGroup">IsFreeGroup</a> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">G</span></span>)</span></div></div><p>The free product of free groups is itself a free group</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="freeGroupEquivFreeProduct_symm_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L856-L856">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#freeGroupEquivFreeProduct_symm_apply"><span class="name">freeGroupEquivFreeProduct_symm_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeGroup.html#FreeGroup">FreeGroup</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑(<span class="fn"><a href="../.././Mathlib/Algebra/Hom/Equiv/Basic.html#MulEquiv.symm">MulEquiv.symm</a> <span class="fn">freeGroupEquivFreeProduct</span></span>) <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">↑(<span class="fn">↑<span class="fn">FreeProduct.lift</span> <span class="fn">fun <span class="fn">i</span> =&gt <span class="fn">↑<span class="fn">FreeGroup.lift</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeGroup.html#FreeGroup.of">FreeGroup.of</a> <span class="fn">i</span></span></span></span></span></span>) <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="freeGroupEquivFreeProduct_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L856-L856">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#freeGroupEquivFreeProduct_apply"><span class="name">freeGroupEquivFreeProduct_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeGroup.html#FreeGroup">FreeGroup</a> <span class="fn">ι</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">freeGroupEquivFreeProduct</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">↑(<span class="fn">↑<span class="fn">FreeGroup.lift</span> <span class="fn">fun <span class="fn">i</span> =&gt <span class="fn">↑<span class="fn">FreeProduct.of</span> (<span class="fn"><a href="../.././Mathlib/GroupTheory/FreeGroup.html#FreeGroup.of">FreeGroup.of</a> <a href="../.././Init/Prelude.html#Unit.unit">()</a></span>)</span></span></span>) <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="freeGroupEquivFreeProduct"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L857-L863">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#freeGroupEquivFreeProduct"><span class="name">freeGroupEquivFreeProduct</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/GroupTheory/FreeGroup.html#FreeGroup">FreeGroup</a> <span class="fn">ι</span></span> <a href="../.././Mathlib/Algebra/Hom/Equiv/Basic.html#MulEquiv">≃*</a> <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct">FreeProduct</a> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><a href="../.././Mathlib/GroupTheory/FreeGroup.html#FreeGroup">FreeGroup</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></span></span></span></div></div><p>A free group is a free product of copies of the free_group over one generator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-freeGroupEquivFreeProduct" class="instances-for-list"></ul></details></div></div><div class="decl" id="FreeGroup.injective_lift_of_ping_pong"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/44c828ca5b12983ef1d4eea5c54f95c2ef52cb36/Mathlib/GroupTheory/FreeProduct.lean#L903-L992">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeGroup.injective_lift_of_ping_pong"><span class="name">FreeGroup</span>.<span class="name">injective_lift_of_ping_pong</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Logic/Nontrivial.html#Nontrivial">Nontrivial</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Group">Group</a> <span class="fn">G</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><span class="fn">ι</span> → <span class="fn">G</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Mathlib/GroupTheory/GroupAction/Defs.html#MulAction">MulAction</a> <span class="fn">G</span> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXnonempty : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../.././Mathlib/Data/Set/Basic.html#Set.Nonempty">Set.Nonempty</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXdisj : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn"><a href="../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hYdisj : <span class="fn"><a href="../.././Mathlib/Logic/Pairwise.html#Pairwise">Pairwise</a> <span class="fn">fun <span class="fn">i</span> <span class="fn">j</span> =&gt <span class="fn"><a href="../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> (<span class="fn"><span class="fn">Y</span> <span class="fn">i</span></span>) (<span class="fn"><span class="fn">Y</span> <span class="fn">j</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hXYdisj : <span class="fn">∀ (<span class="fn">i </span>j : <span class="fn">ι</span>), <span class="fn"><a href="../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> (<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn"><span class="fn">Y</span> <span class="fn">j</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hX : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">(<span class="fn"><span class="fn">Y</span> <span class="fn">i</span></span>)<a href="../.././Mathlib/Order/Basic.html#HasCompl.compl">ᶜ</a></span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hY : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">(<span class="fn"><span class="fn">ι</span> → <span class="fn">G</span></span>)<a href="../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></a> <span class="fn">Pi.instInv</span> <span class="fn">a</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">(<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)<a href="../.././Mathlib/Order/Basic.html#HasCompl.compl">ᶜ</a></span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">Y</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Function.html#Function.Injective">Function.Injective</a> <span class="fn">↑(<span class="fn">↑<span class="fn">FreeGroup.lift</span> <span class="fn">a</span></span>)</span></span></div></div><p>The Ping-Pong-Lemma.</p><p>Given a group action of <code>G</code> on <code>X</code> so that the generators of the free groups act in specific
ways on disjoint subsets <code>X i</code> and <code>Y i</code> we can prove that <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift">lift</a> f</code> is injective, and thus the image
of <code><a href="../.././Mathlib/GroupTheory/FreeProduct.html#FreeProduct.lift">lift</a> f</code> is isomorphic to the free group.</p><p>Often the Ping-Pong-Lemma is stated with regard to group elements that generate the whole group;
we generalize to arbitrary group homomorphisms from the free group to <code>G</code>  and do not require the
group to be generated by the elements.</p></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>